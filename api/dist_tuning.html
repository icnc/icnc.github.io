<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>CnC: Tuning for distributed memory</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />

<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>

</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">CnC
   
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="headertitle">
<div class="title">Tuning for distributed memory </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>The <a class="el" href="namespace_cn_c.html" title="CnC API.">CnC</a> tuning interface provides convenient ways to control the distribution of work and data across the address spaces. The tuning interface is separate from the actual step-code and its declarative nature allows flexible and productive experiments with different distribution strategies.</p>
<h2><a class="anchor" id="dist_work"></a>
Distributing the work</h2>
<p>Let's first look at the distribution of work/steps. You can specify the distribution of work (e.g. steps) across the network by providing a tuner to a step-collection (the second template argument to <a class="el" href="class_cn_c_1_1step__collection.html" title="A step collection is logical set of step instances.">CnC::step_collection</a>, see <a class="el" href="tuning.html">The Tuners</a>). Similar to other tuning features, the tuner defines the distribution plan based on the control-tags and item-tags. For a given instance (identified by the control-tag) the tuner defines the placement of the instance in the communication network. This mechanism allows a declarative definition of the distribution and keeps it separate from the actual program code</p>
<ul>
<li>you can change the distribution without changing the actual program.</li>
</ul>
<p>The method for distributing steps is called "compute_on". It takes the tag of the step and the context as arguments and has to return the process number to run the step on. The numbering of processes is similar to ranks in MPI. Running on "N" processes, the host process is "0" and the last client "N-1".</p>
<div class="fragment"><pre class="fragment">   <span class="keyword">struct </span>my_tuner : <span class="keyword">public</span> CnC::step_tuner&lt;&gt;
   {
       <span class="keywordtype">int</span> compute_on( <span class="keyword">const</span> tag_type &amp; tag, context_type &amp; )<span class="keyword"> const </span>{ <span class="keywordflow">return</span> tag % numProcs(); }
   };
</pre></div><p>The shown tuner is derived from <a class="el" href="struct_cn_c_1_1step__tuner.html" title="Default (NOP) implementations of the step_tuner interface.">CnC::step_tuner</a>. To allow a flexible and generic definition of the distribution <a class="el" href="struct_cn_c_1_1step__tuner.html" title="Default (NOP) implementations of the step_tuner interface.">CnC::step_tuner</a> provides information specific for distributed memory: <a class="el" href="class_cn_c_1_1tuner__base.html#aef1047092ade8db731c56fbf2f708e76">CnC::tuner_base::numProcs()</a> and <a class="el" href="class_cn_c_1_1tuner__base.html#ae52a37bb28b0d5fdd7fc105ac989ac46">CnC::tuner_base::myPid()</a>. Both return the values of the current run of your application. Using those allows defining a distribution plan which adapts to the current runtime configuration.</p>
<p>If you wonder how the necessary gets distributed - this will be covered soon. Let's first look at the computation side a bit more closely; but if you can't wait see <a class="el" href="dist_tuning.html#dist_data">Distributing the data</a>.</p>
<p>The given tuner above simply distributes the tags in a round-robin fashion by applying the modulo operator on the tag. Here's an example of how a given set of tags would be mapped to 4 processes (e.g. numProcs()==4): </p>
<div class="fragment"><pre class="fragment">
1  -&gt; 1
3  -&gt; 3
4  -&gt; 0
5  -&gt; 1
10 -&gt; 2
20 -&gt; 0
31 -&gt; 3
34 -&gt; 2
</pre></div><p>An example of such a simple tuner is <a class="el" href="samples.html#bs_tuner">samples/blackscholes/blackscholes/blackscholes.h</a>.</p>
<p>Now let's do something a little more interesting. Let's assume our tag is a pair of x and y coordinates. To distribute the work per row, we could simply do something like</p>
<div class="fragment"><pre class="fragment">   <span class="keyword">struct </span>my_tuner : <span class="keyword">public</span> CnC::step_tuner&lt;&gt;
   {
       <span class="keywordtype">int</span> compute_on( <span class="keyword">const</span> tag_type &amp; tag, context_type &amp; )<span class="keyword"> const </span>{ <span class="keywordflow">return</span> tag.y % numProcs(); }
   };
</pre></div><p>As you see, the tuner entirely ignores the x-part of the tag. This means that all entries on a given row (identified by tag.y) gets executed on the same process. Similarly, if you want to distribute the work per column instead, you simply change it to</p>
<div class="fragment"><pre class="fragment">   <span class="keyword">struct </span>my_tuner : <span class="keyword">public</span> CnC::step_tuner&lt;&gt;
   {
       <span class="keywordtype">int</span> compute_on( <span class="keyword">const</span> tag_type &amp; tag, context_type &amp; )<span class="keyword"> const </span>{ <span class="keywordflow">return</span> tag.x % numProcs(); }
   };
</pre></div><p>As we'll also see later, you can certainly also conditionally switch between row- and column-wise (or any other) distribution within compute_on.</p>
<p>To avoid the afore-mentioned problem of becoming globally inconsistent, you should make sure that the return value is independent of the process it is executed on.</p>
<p><a class="el" href="namespace_cn_c.html" title="CnC API.">CnC</a> provides special values to make working with compute_on more convenient, more generic and more effective: <a class="el" href="namespace_cn_c.html#a06fc87d81c62e9abb8790b6e5713c55ba35fbeddaf90adeadc3ee9915ab152883" title="let tuner::compute_on return COMPUTE_ON_LOCAL if the step should be executed locally">CnC::COMPUTE_ON_LOCAL</a>, <a class="el" href="namespace_cn_c.html#a06fc87d81c62e9abb8790b6e5713c55ba18307992bab1042ac81c243a9c1130fe" title="let tuner::compute_on return COMPUTE_ON_ROUND_ROBIN to let the scheduler distribute it in a round-rob...">CnC::COMPUTE_ON_ROUND_ROBIN</a>, <a class="el" href="namespace_cn_c.html#a06fc87d81c62e9abb8790b6e5713c55ba24c0ab89e0013408b8011ccd01249d50" title="let tuner::compute_on return COMPUTE_ON_ALL if the step should be executed on all processes...">CnC::COMPUTE_ON_ALL</a>, <a class="el" href="namespace_cn_c.html#a06fc87d81c62e9abb8790b6e5713c55ba8a1fa14817ef3975a9c1f5d40090b869" title="let tuner::compute_on return COMPUTE_ON_ALL_OTHERS if the step should be executed on all processes...">CnC::COMPUTE_ON_ALL_OTHERS</a>.</p>
<h2><a class="anchor" id="dist_data"></a>
Distributing the data</h2>
<p>By default, the <a class="el" href="namespace_cn_c.html" title="CnC API.">CnC</a> runtime will deliver data items automatically to where they are needed. In its current form, the C++ API does not express the dependencies between instances of steps and/or items. Hence, without additional information, the runtime does not know what step-instances produce and consume which item-instances. Even when the step-distribution is known automatically automatic distribution of data requires global communication. Apparently this constitutes a considerable bottleneck. The <a class="el" href="namespace_cn_c.html" title="CnC API.">CnC</a> tuner interface provides two ways to reduce this overhead.</p>
<p>The ideal, most flexible and most efficient approach is to map items to their consumers. It will convert the default pull-model to a push-model: whenever an item becomes produced, it will be sent only to those processes, which actually need it without any other communication/synchronization. If you can determine which steps are going to consume a given item, you can use the above compute_on to map the consumer step to the actual address spaces. This allows changing the distribution at a single place (compute_on) and the data distribution will be automatically optimized to the minimum needed data transfer.</p>
<p>The runtime evaluates the tuner provided to the item-collection when an item is put. If its method consumed_on (from <a class="el" href="struct_cn_c_1_1item__tuner.html" title="Default implementations of the item-tuner interface for item-collections.">CnC::item_tuner</a>) returns anything other than <a class="el" href="namespace_cn_c.html#a06fc87d81c62e9abb8790b6e5713c55ba4e54235189ce408ee733a5a9d9e0d386" title="consumer process of given item is unkown">CnC::CONSUMER_UNKNOWN</a> it will send the item to the returned process id and avoid all the overhead of requesting the item when consumed. </p>
<div class="fragment"><pre class="fragment">   <span class="keyword">struct </span>my_tuner : <span class="keyword">public</span> CnC::item_tuner&lt; tag_type, item_type &gt;
   {
       <span class="keywordtype">int</span> consumed_on( <span class="keyword">const</span> tag_type &amp; tag ) 
       {
           <span class="keywordflow">return</span> my_step_tuner::consumed_on( consumer_step );
       }
   };
</pre></div><p>As more than one process might consume the item, you can also return a vector of ids (instead of a single id) and the runtime will send the item to all given processes. </p>
<div class="fragment"><pre class="fragment">   <span class="keyword">struct </span>my_tuner : <span class="keyword">public</span> CnC::item_tuner&lt; tag_type, item_type &gt;
   {
       std::vector&lt; int &gt; consumed_on( <span class="keyword">const</span> tag_type &amp; tag ) 
       {
           std::vector&lt; int &gt; consumers;
           <span class="keywordflow">foreach</span>( consumer_step of tag ) {
               <span class="keywordtype">int</span> _tmp = my_step_tuner::consumed_on( consumer_step );
               consumers.push_back( _tmp );
           }
           <span class="keywordflow">return</span> consumers;
       }
   };
</pre></div><p>Like for compute_on, <a class="el" href="namespace_cn_c.html" title="CnC API.">CnC</a> provides special values to facilitate and generalize the use of consumed_on: <a class="el" href="namespace_cn_c.html#a06fc87d81c62e9abb8790b6e5713c55ba4e54235189ce408ee733a5a9d9e0d386" title="consumer process of given item is unkown">CnC::CONSUMER_UNKNOWN</a>, <a class="el" href="namespace_cn_c.html#a06fc87d81c62e9abb8790b6e5713c55ba43a7cdb0ac2922d3bfc5c28d1bc0c4d5" title="consumer process of given item is the local process">CnC::CONSUMER_LOCAL</a>, <a class="el" href="namespace_cn_c.html#a06fc87d81c62e9abb8790b6e5713c55bacb8c5ed4d3811219521bd6e8a1c5adbc" title="all processes consume given item">CnC::CONSUMER_ALL</a> and <a class="el" href="namespace_cn_c.html#a06fc87d81c62e9abb8790b6e5713c55ba75e76d0582be09de368a1e11e6622144" title="all processes but this consume given item">CnC::CONSUMER_ALL_OTHERS</a>.</p>
<p>Note that consumed_on can return CnC::CONSUMER_UNKOWN for some item-instances, and process rank(s) for others.</p>
<p>Sometimes the program semantics make it easier to think about the producer of an item. <a class="el" href="namespace_cn_c.html" title="CnC API.">CnC</a> provides a mechanism to keep the pull-model but allows declaring the owner/producer of the item. If the producer of an item is specified the CnC-runtime can significantly reduce the communication overhead because it on longer requires global communication to find the owner of the item. For this, simply define the depends-method in your step-tuner (derived from <a class="el" href="struct_cn_c_1_1step__tuner.html" title="Default (NOP) implementations of the step_tuner interface.">CnC::step_tuner</a>) and provide the owning/producing process as an additional argument.</p>
<div class="fragment"><pre class="fragment">   <span class="keyword">struct </span>my_tuner : <span class="keyword">public</span> CnC::step_tuner&lt;&gt;
   {
       <span class="keywordtype">int</span> produced_on( <span class="keyword">const</span> tag_type &amp; tag )<span class="keyword"> const</span>
<span class="keyword">       </span>{
           <span class="keywordflow">return</span> producer_known ? my_step_tuner::consumed_on( tag ) : tag % numProcs();
       }
   };
</pre></div><p>Like for consumed_on, <a class="el" href="namespace_cn_c.html" title="CnC API.">CnC</a> provides special values <a class="el" href="namespace_cn_c.html#a06fc87d81c62e9abb8790b6e5713c55bae1773e9ebdd06da9b2c30eea415d4791" title="producer process of dependent item is unknown">CnC::PRODUCER_UNKNOWN</a> and <a class="el" href="namespace_cn_c.html#a06fc87d81c62e9abb8790b6e5713c55ba456fc1c1ea987d5ab7632ae5b76e2353" title="producer process of dependent item is local process">CnC::PRODUCER_LOCAL</a> to facilitate and generalize the use of produced_on.</p>
<p>The push-model consumed_on smoothly cooperates with the pull-model as long as they don't conflict.</p>
<h2><a class="anchor" id="dist_sync"></a>
Keeping data and work distribution in sync</h2>
<p>For a more productive development, you might consider implementing consumed_on by thinking about which other steps (not processes) consume the item. With that knowledge you can easily use the appropriate compute_on function to determine the consuming process. The great benefit here is that you can then change compute distribution (e.g. change compute_on) and the data will automatically follow in an optimal way; data and work distribution will always be in sync. It allows experimenting with different distribution plans with much less trouble and lets you define different strategies at a single place. Here is a simple example code which lets you select different strategies at runtime. Adding a new strategy only requires extending the compute_on function: <a class="el" href="samples.html#bs_tuner">samples/blackscholes/blackscholes/blackscholes.h</a> A more complex example is this one: <a class="el" href="samples.html#cholesky_tuner">samples/cholesky/cholesky/cholesky.h</a></p>
<h2><a class="anchor" id="dist_global"></a>
Using global read-only data with distCnC</h2>
<p>Many algorithms require global data that is initialized once and during computation it stays read-only (dynamic single assignment, DSA). In principle this is aligned with the <a class="el" href="namespace_cn_c.html" title="CnC API.">CnC</a> methodology as long as the initialization is done from the environment. The <a class="el" href="namespace_cn_c.html" title="CnC API.">CnC</a> API allows global DSA data through the context, e.g. you can store global data in the context, initialize it there and then use it in a read-only fashion within your step codes.</p>
<p>The internal mechanism works as follows: on remote processes the user context is default constructed and then de-serialized/un-marshaled. On the host, construction and serialization/marshaling is done in a lazy manner, e.g. not before something actually needs being transferred. This allows creating contexts on the host with non-default constructors, but it requires overloading the serialize method of the context. The actual time of transfer is not statically known, the earliest possible time is the first item- or tag-put. All changes to the context until that point will be duplicated remotely, later changes will not.</p>
<p>Here is a simple example code which uses this feature: <a class="el" href="samples.html#bs_tuner">samples/blackscholes/blackscholes/blackscholes.h</a></p>
<p>Next: <a class="el" href="non_cnc.html">Beyond And With CnC</a> </p>
</div></div><!-- contents -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Friends</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>



<hr class="footer"/><address class="footer"><small>
Generated on Fri Jun 6 2014 15:18:33 for CnC by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.7.6.1
</small></address>

</body>
</html>
