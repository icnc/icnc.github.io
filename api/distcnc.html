<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>CnC: Running CnC applications on distributed memory</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />

<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>

</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">CnC
   
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="headertitle">
<div class="title">Running <a class="el" href="namespace_cn_c.html" title="CnC API.">CnC</a> applications on distributed memory </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>In principle, every clean <a class="el" href="namespace_cn_c.html" title="CnC API.">CnC</a> program should be immediately applicable for distributed memory systems. With only a few trivial changes most <a class="el" href="namespace_cn_c.html" title="CnC API.">CnC</a> programs can be made distribution-ready. You will get a binary that runs on shared and distributed memory. Most of the mechanics of data distribution etc. is handled inside the runtime and the programmer does not need to bother about the gory details. Of course, there are a few minor changes needed to make a program distribution-ready, but once that's done, it will run on distributed <a class="el" href="namespace_cn_c.html" title="CnC API.">CnC</a> as well as on "normal" <a class="el" href="namespace_cn_c.html" title="CnC API.">CnC</a> (decided at runtime).</p>
<h2><a class="anchor" id="dc_comm"></a>
Inter-process communication</h2>
<p>Conceptually, <a class="el" href="namespace_cn_c.html" title="CnC API.">CnC</a> allows data and computation distribution across any kind of network; currently <a class="el" href="namespace_cn_c.html" title="CnC API.">CnC</a> supports SOCKETS and MPI.</p>
<h2><a class="anchor" id="dc_link"></a>
Linking for distCnC</h2>
<p>Support for distributed memory is part of the "normal" <a class="el" href="namespace_cn_c.html" title="CnC API.">CnC</a> distribution, e.g. it comes with the necessary communication libraries (cnc_socket, cnc_mpi). The communication library is loaded on demand at runtime, hence you do not need to link against extra libraries to create distribution-ready applications. Just link your binaries like a "traditional" <a class="el" href="namespace_cn_c.html" title="CnC API.">CnC</a> application (explained in the <a class="el" href="namespace_cn_c.html" title="CnC API.">CnC</a> User Guide, which can be found in the doc directory). </p>
<dl class="note"><dt><b>Note:</b></dt><dd>a distribution-ready <a class="el" href="namespace_cn_c.html" title="CnC API.">CnC</a> application-binary has no dependencies on an MPI library, it can be run on shared memory or over SOCKETS even if no MPI is available on the system</dd></dl>
<p>Even though it is not a separate package or module in the CNC kit, in the following we will refer to features that are specific for distributed memory with "distCnC".</p>
<h2><a class="anchor" id="dc_prog"></a>
Making your program distCnC-ready</h2>
<p>As a distributed version of a <a class="el" href="namespace_cn_c.html" title="CnC API.">CnC</a> program needs to do things which are not required in a shared memory version, the extra code for distCnC is hidden from "normal" <a class="el" href="namespace_cn_c.html" title="CnC API.">CnC</a> headers. To include the features required for a distributed version you need to </p>
<div class="fragment"><pre class="fragment"><span class="preprocessor"> #include &lt;cnc/dist_cnc.h&gt;</span> 
</pre></div><p> instead of </p>
<div class="fragment"><pre class="fragment"><span class="preprocessor"> #include &lt;cnc/cnc.h&gt;</span> 
</pre></div><p> . If you want to be able to create optimized binaries for shared memory and distributed memory from the same source, you might consider protecting distCnC specifics like this: </p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">   #ifdef _DIST_</span>
<span class="preprocessor"></span><span class="preprocessor">   # include &lt;cnc/dist_cnc.h&gt;</span>
<span class="preprocessor">   #else</span>
<span class="preprocessor"></span><span class="preprocessor">   # include &lt;cnc/cnc.h&gt;</span>
<span class="preprocessor">   #endif</span>
</pre></div><p>In "main", initialize an object <a class="el" href="struct_cn_c_1_1dist__cnc__init.html">CnC::dist_cnc_init</a>&lt; list-of-contexts &gt; before anything else; parameters should be all context-types that you would like to be distributed. Context-types not listed in here will stay local. You may mix local and distributed contexts, but in most cases only one context is needed/used anyway. </p>
<div class="fragment"><pre class="fragment"><span class="preprocessor">   #ifdef _DIST_</span>
<span class="preprocessor"></span>       <a class="code" href="struct_cn_c_1_1dist__cnc__init.html">CnC::dist_cnc_init</a>&lt; my_context_type_1 <span class="comment">//, my_context_type_2, ...</span>
                         &gt; _dinit;
<span class="preprocessor">   #endif</span>
</pre></div><p>Even though the communication between process is entirely handled by the <a class="el" href="namespace_cn_c.html" title="CnC API.">CnC</a> runtime, C++ doesn't allow automatic marshaling/serialization of arbitrary data-types. Hence, if and only if your items and/or tags are non-standard data types, the compiler will notify you about the need for serialization/marshaling capability. If you are using standard data types only then marshaling will be handled by <a class="el" href="namespace_cn_c.html" title="CnC API.">CnC</a> automatically.</p>
<p>Marshaling doesn't involve sending messages or alike, it only specifies how an object/variable is packed/unpacked into/from a buffer. Marshaling of structs/classes without pointers or virtual functions can easily be enabled using </p>
<div class="fragment"><pre class="fragment"> <a class="code" href="group__serialization.html#ga7315edf5ecbcdbc4c086d2ba9a262b3a">CNC_BITWISE_SERIALIZABLE</a>( type); 
</pre></div><p> others need a "serialize" method or function. The <a class="el" href="namespace_cn_c.html" title="CnC API.">CnC</a> kit comes with an convenient interface for this which is similar to BOOST serialization. It is very simple to use and requires only one function/method for packing and unpacking. See <a class="el" href="group__serialization.html">Serialization</a> for more details.</p>
<p><b>This is it! Your <a class="el" href="namespace_cn_c.html" title="CnC API.">CnC</a> program will now run on distributed memory!</b></p>
<dl class="attention"><dt><b>Attention:</b></dt><dd>Global variables are evil and must not be used within the execution scope of steps. Read <a class="el" href="dist_tuning.html#dist_global">Using global read-only data with distCnC</a> about how <a class="el" href="namespace_cn_c.html" title="CnC API.">CnC</a> supports global read-only data. Apparently, pointers are nothing else than global variables and hence need special treatment in distCnC (see <a class="el" href="group__serialization.html">Serialization</a>). </dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>Even if your program runs on distributed memory, that does not necessarily imply that the trivial extension above will make it run fast. Please consult <a class="el" href="dist_tuning.html">Tuning for distributed memory</a> for the tuning options for distributed memory.</dd></dl>
<p>The above describes the default "single-program" approach for distribution. Please refer to to <a class="el" href="struct_cn_c_1_1dist__cnc__init.html">CnC::dist_cnc_init</a> for more advanced modes which allow SPMD-style interaction as well as distributing parts of the <a class="el" href="namespace_cn_c.html" title="CnC API.">CnC</a> program over groups of processes.</p>
<h2><a class="anchor" id="dc_run"></a>
Running distCnC</h2>
<p>The communication infrastructure used by distCnC is chosen at runtime. By default, the <a class="el" href="namespace_cn_c.html" title="CnC API.">CnC</a> runtime will run your application in shared memory mode. When starting up, the runtime will evaluate the environment variable "DIST_CNC". Currently it accepts the following values</p>
<ul>
<li>SHMEM : shared memory (default)</li>
<li>SOCKETS : communication through TCP sockets</li>
<li>MPI : using Intel(R) MPI</li>
</ul>
<p>Please see <a class="el" href="itac.html">Using Intel(R) Trace Analyzer and Collector with CnC</a> on how to profile distributed programs</p>
<h3><a class="anchor" id="dc_sockets"></a>
Using SOCKETS</h3>
<p>On application start-up, when DIST_CNC=SOCKETS, <a class="el" href="namespace_cn_c.html" title="CnC API.">CnC</a> checks the environment variable "CNC_SOCKET_HOST". If it is set to a number, it will print a contact string and wait for the given number of clients to connect. Usually this means that clients need to be started "manually" as follows: set DIST_CNC=SOCKETS and "CNC_SOCKET_CLIENT" to the given contact string and launch the same executable on the desired machine.</p>
<p>If "CNC_SOCKET_HOST" is not a number it is interpreted as a name of a script. <a class="el" href="namespace_cn_c.html" title="CnC API.">CnC</a> executes the script twice: First with "-n" it expects the script to return the number of clients it will start. The second invocation is expected to launch the client processes.</p>
<p>There is a sample script "misc/start.sh" which you can use. Usually all you need is setting the number of clients and replacing "localhost" with the names of the machines you want the application(-clients) to be started on. It requires password-less login via ssh. It also gives some details of the start-up procedure. For windows, the script "start.bat" does the same, except that it will start the clients on the same machine without ssh or alike. Adjust the script to use your preferred remote login mechanism.</p>
<h3><a class="anchor" id="dc_mpi"></a>
MPI</h3>
<p><a class="el" href="namespace_cn_c.html" title="CnC API.">CnC</a> comes with a communication layer based on MPI. You need the Intel(R) MPI runtime to use it. You can download a free version of the MPI runtime from <a href="http://software.intel.com/en-us/articles/intel-mpi-library/">http://software.intel.com/en-us/articles/intel-mpi-library/</a> (under "Resources"). A distCnC application is launched like any other MPI application with mpirun or mpiexec, but DIST_CNC must be set to MPI: </p>
<div class="fragment"><pre class="fragment">env DIST_CNC=MPI mpiexec -n 4 my_cnc_program
</pre></div><p> Alternatively, just run the app as usually (with DIST_CNC=MPI) and control the number (n) of additionally spawned processes with CNC_MPI_SPAWN=n. If host and client applications need to be different, set CNC_MPI_EXECUTABLE to the client-program name. Here's an example: </p>
<div class="fragment"><pre class="fragment">env DIST_CNC=MPI env CNC_MPI_SPAWN=3 env CNC_MPI_EXECUTABLE=cnc_client cnc_host
</pre></div><p> It starts your host executable "cnc_host" and then spawns 3 additional processes which all execute the client executable "cnc_client".</p>
<h3><a class="anchor" id="dc_mic"></a>
Intel Xeon Phi(TM) (MIC)</h3>
<p>for <a class="el" href="namespace_cn_c.html" title="CnC API.">CnC</a> a MIC process is just another process where work can be computed on. So all you need to do is</p>
<ul>
<li>Build your application for MIC (see <a href="http://software.intel.com/en-us/articles/intel-concurrent-collections-getting-started">http://software.intel.com/en-us/articles/intel-concurrent-collections-getting-started</a>)</li>
<li>Start a process with the MIC executable on each MIC card just like on a CPU. Communication and Startup is equivalent to how it works on intel64 (<a class="el" href="distcnc.html#dc_mpi">MPI</a> and <a class="el" href="distcnc.html#dc_sockets">Using SOCKETS</a>).</li>
</ul>
<dl class="note"><dt><b>Note:</b></dt><dd>Of course the normal mechanics for MIC need to be considered (like getting applications and dependent libraries to the MIC first). You'll find documentation about this on IDZ, like <a href="http://software.intel.com/en-us/articles/how-to-run-intel-mpi-on-xeon-phi">here</a> and/or <a href="http://software.intel.com/en-us/articles/using-the-intel-mpi-library-on-intel-xeon-phi-coprocessor-systems">here</a> </dd>
<dd>
We recommend starting only 2 threads per MIC-core, e.g. if your card has 60 cores, set CNC_NUM_THREADS=120 </dd>
<dd>
To start different binaries with one mpirun/mpiexec command you can use a syntax like this:<br/>
 mpirun -genv DIST_CNC=MPI -n 2 -host xeon xeonbinary : -n 1 -host mic0 -env CNC_NUM_THREADS=120 micbinary</dd></dl>
<h2><a class="anchor" id="def_dist"></a>
Default Distribution</h2>
<p>Step instances are distributed across clients and the host. By default, they are distributed in a round-robin fashion. Note that every process can put tags (and so prescribe new step instances). The round-robin distribution decision is made locally on each process (not globally).</p>
<p>If the same tag is put multiple times, the default scheduling might execute the multiply prescribed steps on different processes and the preserveTags attribute of tag_collections will then not have the desired effect.</p>
<p>The default scheduling is intended primarily as a development aid. your <a class="el" href="namespace_cn_c.html" title="CnC API.">CnC</a> application will be distribution ready with only little effort. In some cases it might lead to good performance, in other cases a sensible distribution is needed to achieve good performance. See <a class="el" href="dist_tuning.html">Tuning for distributed memory</a>.</p>
<p>Next: <a class="el" href="dist_tuning.html">Tuning for distributed memory</a> </p>
</div></div><!-- contents -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Friends</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>



<hr class="footer"/><address class="footer"><small>
Generated on Fri Jun 6 2014 15:18:33 for CnC by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.7.6.1
</small></address>

</body>
</html>
