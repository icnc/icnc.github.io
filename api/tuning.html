<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>CnC: The Tuners</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />

<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>

</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">CnC
   
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="headertitle">
<div class="title">The Tuners </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>The <a class="el" href="namespace_cn_c.html" title="CnC API.">CnC</a> concepts allow tuning the program independently of the actual program core. Without touching the code in steps and only adding a few declarations in the collection definitions the tuning interface allows providing tuning hints. In the following you will learn about the features of the modular, flexible and easy-to-use tuning interface.</p>
<h2><a class="anchor" id="tuner_deps"></a>
Pre-declaring data dependencies</h2>
<p>Supporting the full generality of the <a class="el" href="namespace_cn_c.html" title="CnC API.">CnC</a> programming model obviously comes at some cost in the runtime. In order to accelerate the evaluation of a specific application, the API provides capabilities to influence the execution performance. Most importantly it allows the specification of a "tuner" for each collection. Through the tuners you can provide various hints to the <a class="el" href="namespace_cn_c.html" title="CnC API.">CnC</a> runtime. The tuner-type is an optional template argument to the collection classes. Here is an example of how the tuner type "fib_tuner" is assigned to the step-collection:  <div class="fragment"><pre class="fragment">    <a class="code" href="class_cn_c_1_1step__collection.html" title="A step collection is logical set of step instances.">CnC::step_collection&lt; fib_step, fib_tuner &gt;</a> m_steps;
</pre></div></p>
<p>To define a tuner, you should derive your tuner-class from the default implementations which are provided by the <a class="el" href="namespace_cn_c.html" title="CnC API.">CnC</a> runtime. Otherwise you will need to provide the entire tuner interface even if you intend to use only parts of the interface. The appropriate class for a step-collection tuner is CNC::step_tuner&lt;&gt;:  <div class="fragment"><pre class="fragment"><span class="keyword">struct </span>fib_tuner : <span class="keyword">public</span> CnC::step_tuner&lt;&gt;
</pre></div></p>
<p>The funky "&lt;&gt;" stems from the way C++ handles default template parameters. This default parameter is only needed for the more advanced use of ranges (<a class="el" href="tag_ranges.html#tune_ranges">Tuning Ranges</a>).</p>
<p>Besides features for distributed memory (<a class="el" href="distcnc.html">Running CnC applications on distributed memory</a>) probably the most relevant feature of a step-tuner is the ability to pre-declare item-dependencies. Upon putting a tag normal <a class="el" href="namespace_cn_c.html" title="CnC API.">CnC</a> execution will create a step-instance and hand it over to the underlying scheduler which will eventually launch the step. Only during the actual execution the runtime will observe the unavailability of items (e.g. if a get fails) and needs to re-schedule the step. If the tuner pre-declares items the step-instances will not be scheduled before those items are actually available. To pre-declare item-dependencies you need to provide a template method named "depends", which accepts the same arguments as the step::execute method and an additional parameter. Here's how this would look like in our Fibonacci example:  <div class="fragment"><pre class="fragment"><span class="keyword">struct </span>fib_tuner : <span class="keyword">public</span> CnC::step_tuner&lt;&gt;
{
    <span class="keyword">template</span>&lt; <span class="keyword">class</span> dependency_consumer &gt;
    <span class="keywordtype">void</span> depends( <span class="keyword">const</span> <span class="keywordtype">int</span> &amp; tag, fib_context &amp; c, dependency_consumer &amp; dC ) <span class="keyword">const</span>;
};
</pre></div> Declaring dependencies is straight-forward through calling "depends" on the provided template object. <div class="fragment"><pre class="fragment"><span class="keyword">template</span>&lt; <span class="keyword">class</span> dependency_consumer &gt;
<span class="keywordtype">void</span> fib_tuner::depends( <span class="keyword">const</span> <span class="keywordtype">int</span> &amp; tag, fib_context &amp; c, dependency_consumer &amp; dC )<span class="keyword"> const</span>
<span class="keyword"></span>{
    <span class="comment">// we have item-dependencies only if tag &gt; 1</span>
    <span class="keywordflow">if</span>( tag &gt; 1 ) {
      dC.depends( c.m_fibs, tag - 1 );
      dC.depends( c.m_fibs, tag - 2 );
    }
}
</pre></div></p>
<p>You can find the full code here: <a class="el" href="samples.html#fib_tuner_code">samples/fib/fib_tuner/fib_tuner.cpp</a></p>
<p>A similar effect can be achieved by pre-scheduling a step, which executes a step on the same thread which puts the prescribing tag until the first unavailable item was accessed. Obviously this mechanism will not exploit parallelism if all items are available, because the entire step will be executed. Still, this mechanism is much simpler and can yield performance improvements.</p>
<p>Pre-scheduling is enabled by providing a tuner which provides the method "pre-schedule" returning true (<a class="el" href="samples.html#fib_preschedule_code">samples/fib/fib_preschedule/fib_preschedule.cpp</a>):  <div class="fragment"><pre class="fragment"><span class="keyword">struct </span>fib_tuner : <span class="keyword">public</span> CnC::step_tuner&lt;&gt;
{
    <span class="keywordtype">bool</span> preschedule()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> <span class="keyword">true</span>; }
};
</pre></div></p>
<p>In combination with the unsafe version of get and context::flush_gets() pre-scheduling allows interesting things. For example you can inhibit step execution beyond a call to context::flush_gets() within the pre-scheduling phase, which might increase parallelism. Just uncomment  <div class="fragment"><pre class="fragment">            <span class="comment">// ctxt.flush_gets(); // uncomment this line to prohibit pre-scheduling from completing full step-execution</span>
</pre></div> and see how the scheduler statistics change.</p>
<h2><a class="anchor" id="moresteptuner"></a>
More Tuning of Steps</h2>
<p>The step_tuner interface provides more advanced capabilities:</p>
<ul>
<li>Specifying priorities (<a class="el" href="struct_cn_c_1_1step__tuner.html#a0b65c492133b446f0545916662062ad6" title="Allows definition of priorities to individual steps (which are identified by the tag).">CnC::step_tuner::priority</a>, see also CNCROOT/samples/floyd_warshall)</li>
<li>Define affinity (to threads) (<a class="el" href="struct_cn_c_1_1step__tuner.html#ad3355a96d25a98e04b711ad53acc5ce7" title="Tell the scheduler the preferred thread for executing given step.">CnC::step_tuner::affinity</a>)</li>
<li>Step cancellation (<a class="el" href="struct_cn_c_1_1step__tuner.html#a1912a093f2e5ce572a627fcc1d404bec" title="check for cancelation of given step">CnC::step_tuner::was_canceled</a>, <a class="el" href="class_cn_c_1_1cancel__tuner.html" title="Step tuner with convenient cancelation capabilities.">CnC::cancel_tuner</a>, see also CNCROOT/samples/nqueens)</li>
</ul>
<p>They all work on individual step instances (identified by their control tag) and are used similar to the above.</p>
<h2><a class="anchor" id="tune_items"></a>
Tuning item-collections</h2>
<p>Without additional information the runtime cannot decide when no more gets to a data item will be issued. However, Without this information it is not possible to remove a data item from the internal storage. As the <a class="el" href="namespace_cn_c.html" title="CnC API.">CnC</a> programming model never declares "when" something happens, it is also not generally possible to let the user indicate which is the last get of an item.</p>
<p>As keeping data items in memory for ever can quickly (and unnecessarily) blow the available memory a mechanism preventing this is needed. When putting an data item, the <a class="el" href="namespace_cn_c.html" title="CnC API.">CnC</a> C++ API lets you declare the number of gets that will ever be issued. When this "get-count" number of gets has been reached the <a class="el" href="namespace_cn_c.html" title="CnC API.">CnC</a> runtime will remove the item from its internal store and free the memory for other use.</p>
<p>In our Fibonacci example we know that each intermediate item 'x' will be accessed exactly twice: once by fib(x+1) and once again by fib(x+2). Hence the get-count for every Fibonacci item is exactly "2".</p>
<p>The get-count is an attribute of an item, hence the necessary functionality is located in the item-tuners. Declaration of the get-count is straight-forward by providing a const method actually putting the item:  <div class="fragment"><pre class="fragment"><span class="keywordtype">int</span> item_tuner::get_count( <span class="keyword">const</span> <span class="keywordtype">int</span> &amp; tag ) <span class="keyword">const</span>
{
    <span class="keywordflow">return</span> tag &gt; 0 ? 2 : 1;
}
</pre></div></p>
<p>Like with tag- and step-collections, the tuner needs to made available in the item-collection definition:  <div class="fragment"><pre class="fragment">    <a class="code" href="class_cn_c_1_1item__collection.html" title="An item collection is a mapping from tags to items.">CnC::item_collection&lt; int, fib_type, item_tuner &gt;</a> m_fibs;
</pre></div></p>
<p>Each data item will now be freed once it was accessed the second time. The full code (<a class="el" href="samples.html#fib_getcount_code">samples/fib/fib_getcount/fib_getcount.cpp</a>, <a class="el" href="samples.html#fib_getcount_h">samples/fib/fib_getcount/fib.h</a>) also accounts for the corner case 0 but also ignores the smaller real get-count for n and n-1.</p>
<p>The get-count features helps a lot keeping the memory-footprint under control and hence can significantly improve application performance.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>The current version does not decrement the get-count for gets issued by the environment (e.g. when outside a step). To avoid get-count warnings return <a class="el" href="namespace_cn_c.html#a06fc87d81c62e9abb8790b6e5713c55ba2e499248088579f87f684676c9ebac27" title="no get-count specified">CnC::NO_GETCOUNT</a> for items which the environment consumes (gets).</dd></dl>
<h2><a class="anchor" id="memoize"></a>
Tag/Step Memoization</h2>
<p>As the execution of step-instances is state-less, e.g. functional, executing the same function more than once does not alter the result; it only adds unnecessary overhead. In Fibonacci, most of the tags which prescribe steps are put many times. By default, the <a class="el" href="namespace_cn_c.html" title="CnC API.">CnC</a> runtime will execute the corresponding steps as many times as the same tag is put. By providing a simple hint to the runtime, it will automatically elide duplicate steps. This feature is not enabled by default, because duplicate tags are not common and the automatic memoization apparently adds some overhead.</p>
<p>The memoization is a matter of the tag-collections, hence the corresponding tuning feature is provided by assigning a tuner to the tag-collection. The memoization is enabled by requesting to preserve tags. <a class="el" href="namespace_cn_c.html" title="CnC API.">CnC</a> provides special base-class for tag-tuners to make this extremely convenient:  <div class="fragment"><pre class="fragment">    <a class="code" href="class_cn_c_1_1tag__collection.html" title="A tag collection is a set of tags of the same type. It is used to prescribe steps. By default, tags are not stored.">CnC::tag_collection&lt; int, CnC::preserve_tuner&lt; int &gt;</a> &gt; m_tags;
</pre></div></p>
<p>That's all what's needed to let the runtime memoize step executions. In the Fibonacci example this feature has an amazing effect on performance as it elides most of the computation, because due to the nature of the algorithm it stems from redundant computation (also apparent when comparing scheduling statistics).</p>
<p>Next: <a class="el" href="tag_ranges.html">Tag-Ranges</a> </p>
</div></div><!-- contents -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Friends</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>



<hr class="footer"/><address class="footer"><small>
Generated on Fri Jun 6 2014 15:18:33 for CnC by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.7.6.1
</small></address>

</body>
</html>
