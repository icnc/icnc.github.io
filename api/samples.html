<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>CnC: Samples used in this documentation</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />

<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>

</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">CnC
   
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="headertitle">
<div class="title">Samples used in this documentation </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h2><a class="anchor" id="fib_code"></a>
samples/fib/fib_tutorial/fibTutorial.cpp</h2>
<div class="fragment"><pre class="fragment"><span class="comment">//********************************************************************************</span>
<span class="comment">// Copyright (c) 2007-2014 Intel Corporation. All rights reserved.              **</span>
<span class="comment">//                                                                              **</span>
<span class="comment">// Redistribution and use in source and binary forms, with or without           **</span>
<span class="comment">// modification, are permitted provided that the following conditions are met:  **</span>
<span class="comment">//   * Redistributions of source code must retain the above copyright notice,   **</span>
<span class="comment">//     this list of conditions and the following disclaimer.                    **</span>
<span class="comment">//   * Redistributions in binary form must reproduce the above copyright        **</span>
<span class="comment">//     notice, this list of conditions and the following disclaimer in the      **</span>
<span class="comment">//     documentation and/or other materials provided with the distribution.     **</span>
<span class="comment">//   * Neither the name of Intel Corporation nor the names of its contributors  **</span>
<span class="comment">//     may be used to endorse or promote products derived from this software    **</span>
<span class="comment">//     without specific prior written permission.                               **</span>
<span class="comment">//                                                                              **</span>
<span class="comment">// This software is provided by the copyright holders and contributors &quot;as is&quot;  **</span>
<span class="comment">// and any express or implied warranties, including, but not limited to, the    **</span>
<span class="comment">// implied warranties of merchantability and fitness for a particular purpose   **</span>
<span class="comment">// are disclaimed. In no event shall the copyright owner or contributors be     **</span>
<span class="comment">// liable for any direct, indirect, incidental, special, exemplary, or          **</span>
<span class="comment">// consequential damages (including, but not limited to, procurement of         **</span>
<span class="comment">// substitute goods or services; loss of use, data, or profits; or business     **</span>
<span class="comment">// interruption) however caused and on any theory of liability, whether in      **</span>
<span class="comment">// contract, strict liability, or tort (including negligence or otherwise)      **</span>
<span class="comment">// arising in any way out of the use of this software, even if advised of       **</span>
<span class="comment">// the possibility of such damage.                                              **</span>
<span class="comment">//********************************************************************************</span>

<span class="comment">// compute fibonacci numbers</span>
<span class="comment">//</span>

<span class="preprocessor">#define _CRT_SECURE_NO_DEPRECATE // to keep the VS compiler happy with TBB</span>
<span class="preprocessor"></span>
<span class="preprocessor">#include &lt;cnc/cnc.h&gt;</span>

<span class="comment">// let&#39;s use a large type to store fib numbers</span>
<span class="keyword">typedef</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span> fib_type;
<span class="comment">// forward declaration</span>
<span class="keyword">struct </span>fib_context;

<span class="comment">// declaration of compute step class</span>
<span class="keyword">struct </span>fib_step
{
    <span class="comment">// declaration of execute method goes here</span>
    <span class="keywordtype">int</span> execute( <span class="keyword">const</span> <span class="keywordtype">int</span> &amp; tag, fib_context &amp; c ) <span class="keyword">const</span>;
};

<span class="comment">// this is our context containing collections and defining their depndencies</span>
<span class="keyword">struct </span>fib_context : <span class="keyword">public</span> CnC::context&lt; fib_context &gt; <span class="comment">// derive from CnC::context</span>
{
    <span class="comment">// the step collection for the instances of the compute-kernel</span>
    <a class="code" href="class_cn_c_1_1step__collection.html" title="A step collection is logical set of step instances.">CnC::step_collection&lt; fib_step &gt;</a>       m_steps;
    <span class="comment">// item collection holding the fib number(s)</span>
    <a class="code" href="class_cn_c_1_1item__collection.html" title="An item collection is a mapping from tags to items.">CnC::item_collection&lt; int, fib_type &gt;</a>  m_fibs;
    <span class="comment">// tag collection to control steps</span>
    <a class="code" href="class_cn_c_1_1tag__collection.html" title="A tag collection is a set of tags of the same type. It is used to prescribe steps. By default, tags are not stored.">CnC::tag_collection&lt; int &gt;</a>             m_tags;

    <span class="comment">// constructor</span>
    fib_context();
};

fib_context::fib_context()
        : CnC::context&lt; fib_context &gt;(),
          <span class="comment">// pass context to collection constructors</span>
          m_steps( *this ),
          m_fibs( *this ),
          m_tags( *this )
{
    <span class="comment">// prescribe compute steps with this (context) as argument</span>
    m_tags.<a class="code" href="class_cn_c_1_1tag__collection.html#a83f2782bc18578a2018851f0356c8b2a" title="Declare the prescription relationship between the tag collection and a step collection.">prescribes</a>( m_steps, *<span class="keyword">this</span> );
    <span class="comment">// step consumes m_fibs</span>
    m_steps.<a class="code" href="class_cn_c_1_1step__collection.html#aa91192651c08408d430829b6e4bca8b0" title="Declare this step-collecation as consumer of given item-collection.">consumes</a>( m_fibs );
    <span class="comment">// step also produces m_fibs</span>
    m_steps.<a class="code" href="class_cn_c_1_1step__collection.html#a7e5f64f200a66bba4228f17bfded35ca" title="Declare this step-collecation as producer for given item-collection.">produces</a>( m_fibs );
}

<span class="comment">// the actual step code computing the fib numbers goes here</span>
<span class="keywordtype">int</span> fib_step::execute( <span class="keyword">const</span> <span class="keywordtype">int</span> &amp; tag, fib_context &amp; ctxt )<span class="keyword"> const</span>
<span class="keyword"></span>{
    <span class="keywordflow">switch</span>( tag ) {
        <span class="keywordflow">case</span> 0 : ctxt.m_fibs.put( tag, 0 ); <span class="keywordflow">break</span>;
        <span class="keywordflow">case</span> 1 : ctxt.m_fibs.put( tag, 1 ); <span class="keywordflow">break</span>;
        <span class="keywordflow">default</span> : 
            <span class="comment">// get previous 2 results</span>
            fib_type f_1; ctxt.m_fibs.get( tag - 1, f_1 );
            fib_type f_2; ctxt.m_fibs.get( tag - 2, f_2 );
            <span class="comment">// put our result</span>
            ctxt.m_fibs.put( tag, f_1 + f_2 );
    }
    <span class="keywordflow">return</span> <a class="code" href="namespace_cn_c.html#ae34016c7f648af87668a0d8115b03860" title="Steps return CNC_Success if execution was successful.">CnC::CNC_Success</a>;
}

<span class="keywordtype">int</span> main( <span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>* argv[] )
{
    <span class="keywordtype">int</span> n = 42;
    <span class="comment">// eval command line args</span>
    <span class="keywordflow">if</span>( argc &lt; 2 ) {
        std::cerr &lt;&lt; <span class="stringliteral">&quot;usage: &quot;</span> &lt;&lt; argv[0] &lt;&lt; <span class="stringliteral">&quot; n\nUsing default value &quot;</span> &lt;&lt; n &lt;&lt; std::endl;
    } <span class="keywordflow">else</span> n = atol( argv[1] );

    <span class="comment">// create context</span>
    fib_context ctxt; 

    <span class="comment">// put tags to initiate evaluation</span>
    <span class="keywordflow">for</span>( <span class="keywordtype">int</span> i = 0; i &lt;= n; ++i ) ctxt.m_tags.put( i );

    <span class="comment">// wait for completion</span>
    ctxt.wait(); 

    <span class="comment">// get result</span>
    fib_type res2;
    ctxt.m_fibs.get( n, res2 );

    <span class="comment">// print result</span>
    std::cout &lt;&lt; <span class="stringliteral">&quot;fib (&quot;</span> &lt;&lt; n &lt;&lt; <span class="stringliteral">&quot;): &quot;</span> &lt;&lt; res2 &lt;&lt; std::endl;

    <span class="keywordflow">return</span> 0;
}
</pre></div> <h2><a class="anchor" id="fib_trace_code"></a>
samples/fib/fib_trace/fib_trace.cpp</h2>
<div class="fragment"><pre class="fragment"><span class="comment">//********************************************************************************</span>
<span class="comment">// Copyright (c) 2007-2014 Intel Corporation. All rights reserved.              **</span>
<span class="comment">//                                                                              **</span>
<span class="comment">// Redistribution and use in source and binary forms, with or without           **</span>
<span class="comment">// modification, are permitted provided that the following conditions are met:  **</span>
<span class="comment">//   * Redistributions of source code must retain the above copyright notice,   **</span>
<span class="comment">//     this list of conditions and the following disclaimer.                    **</span>
<span class="comment">//   * Redistributions in binary form must reproduce the above copyright        **</span>
<span class="comment">//     notice, this list of conditions and the following disclaimer in the      **</span>
<span class="comment">//     documentation and/or other materials provided with the distribution.     **</span>
<span class="comment">//   * Neither the name of Intel Corporation nor the names of its contributors  **</span>
<span class="comment">//     may be used to endorse or promote products derived from this software    **</span>
<span class="comment">//     without specific prior written permission.                               **</span>
<span class="comment">//                                                                              **</span>
<span class="comment">// This software is provided by the copyright holders and contributors &quot;as is&quot;  **</span>
<span class="comment">// and any express or implied warranties, including, but not limited to, the    **</span>
<span class="comment">// implied warranties of merchantability and fitness for a particular purpose   **</span>
<span class="comment">// are disclaimed. In no event shall the copyright owner or contributors be     **</span>
<span class="comment">// liable for any direct, indirect, incidental, special, exemplary, or          **</span>
<span class="comment">// consequential damages (including, but not limited to, procurement of         **</span>
<span class="comment">// substitute goods or services; loss of use, data, or profits; or business     **</span>
<span class="comment">// interruption) however caused and on any theory of liability, whether in      **</span>
<span class="comment">// contract, strict liability, or tort (including negligence or otherwise)      **</span>
<span class="comment">// arising in any way out of the use of this software, even if advised of       **</span>
<span class="comment">// the possibility of such damage.                                              **</span>
<span class="comment">//********************************************************************************</span>

<span class="comment">// compute fibonacci numbers</span>
<span class="comment">//</span>

<span class="preprocessor">#define _CRT_SECURE_NO_DEPRECATE // to keep the VS compiler happy with TBB</span>
<span class="preprocessor"></span>
<span class="comment">// let&#39;s use a large type to store fib numbers</span>
<span class="keyword">typedef</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span> fib_type;

<span class="preprocessor">#include &quot;fib.h&quot;</span>

<span class="comment">// the actual step code computing the fib numbers goes here</span>
<span class="keywordtype">int</span> fib_step::execute( <span class="keyword">const</span> <span class="keywordtype">int</span> &amp; tag, fib_context &amp; ctxt )<span class="keyword"> const</span>
<span class="keyword"></span>{
    <span class="keywordflow">switch</span>( tag ) {
        <span class="keywordflow">case</span> 0 : ctxt.m_fibs.put( tag, 0 ); <span class="keywordflow">break</span>;
        <span class="keywordflow">case</span> 1 : ctxt.m_fibs.put( tag, 1 ); <span class="keywordflow">break</span>;
        <span class="keywordflow">default</span> : 
            <span class="comment">// get previous 2 results</span>
            fib_type f_1; ctxt.m_fibs.get( tag - 1, f_1 );
            fib_type f_2; ctxt.m_fibs.get( tag - 2, f_2 );
            <span class="comment">// put our result</span>
            ctxt.m_fibs.put( tag, f_1 + f_2 );
    }
    <span class="keywordflow">return</span> <a class="code" href="namespace_cn_c.html#ae34016c7f648af87668a0d8115b03860" title="Steps return CNC_Success if execution was successful.">CnC::CNC_Success</a>;
}

<span class="keywordtype">int</span> main( <span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>* argv[] )
{
    <span class="keywordtype">int</span> n = 42;
    <span class="comment">// eval command line args</span>
    <span class="keywordflow">if</span>( argc &lt; 2 ) {
        std::cerr &lt;&lt; <span class="stringliteral">&quot;usage: &quot;</span> &lt;&lt; argv[0] &lt;&lt; <span class="stringliteral">&quot; n\nUsing default value &quot;</span> &lt;&lt; n &lt;&lt; std::endl;
    } <span class="keywordflow">else</span> n = atol( argv[1] );

    <span class="comment">// create context</span>
    fib_context ctxt; 

    <span class="comment">// enable debug output for steps</span>
    <a class="code" href="struct_cn_c_1_1debug.html#a037ca57a050741fda23a61a18cac27b3" title="enable tracing of a given tag collection at a given level">CnC::debug::trace</a>( ctxt.m_steps );
    <span class="comment">// also enable debug output for our items</span>
    <a class="code" href="struct_cn_c_1_1debug.html#a037ca57a050741fda23a61a18cac27b3" title="enable tracing of a given tag collection at a given level">CnC::debug::trace</a>( ctxt.m_fibs );

    <span class="comment">// put tags to initiate evaluation</span>
    <span class="keywordflow">for</span>( <span class="keywordtype">int</span> i = 0; i &lt;= n; ++i ) ctxt.m_tags.put( i );

    <span class="comment">// wait for completion</span>
    ctxt.wait(); 

    <span class="comment">// get result</span>
    fib_type res2;
    ctxt.m_fibs.get( n, res2 );

    <span class="comment">// print result</span>
    std::cout &lt;&lt; <span class="stringliteral">&quot;fib (&quot;</span> &lt;&lt; n &lt;&lt; <span class="stringliteral">&quot;): &quot;</span> &lt;&lt; res2 &lt;&lt; std::endl;

    <span class="keywordflow">return</span> 0;
}
</pre></div> <h2><a class="anchor" id="fib_trace_h"></a>
samples/fib/fib_trace/fib.h</h2>
<div class="fragment"><pre class="fragment"><span class="comment">//********************************************************************************</span>
<span class="comment">// Copyright (c) 2007-2014 Intel Corporation. All rights reserved.              **</span>
<span class="comment">//                                                                              **</span>
<span class="comment">// Redistribution and use in source and binary forms, with or without           **</span>
<span class="comment">// modification, are permitted provided that the following conditions are met:  **</span>
<span class="comment">//   * Redistributions of source code must retain the above copyright notice,   **</span>
<span class="comment">//     this list of conditions and the following disclaimer.                    **</span>
<span class="comment">//   * Redistributions in binary form must reproduce the above copyright        **</span>
<span class="comment">//     notice, this list of conditions and the following disclaimer in the      **</span>
<span class="comment">//     documentation and/or other materials provided with the distribution.     **</span>
<span class="comment">//   * Neither the name of Intel Corporation nor the names of its contributors  **</span>
<span class="comment">//     may be used to endorse or promote products derived from this software    **</span>
<span class="comment">//     without specific prior written permission.                               **</span>
<span class="comment">//                                                                              **</span>
<span class="comment">// This software is provided by the copyright holders and contributors &quot;as is&quot;  **</span>
<span class="comment">// and any express or implied warranties, including, but not limited to, the    **</span>
<span class="comment">// implied warranties of merchantability and fitness for a particular purpose   **</span>
<span class="comment">// are disclaimed. In no event shall the copyright owner or contributors be     **</span>
<span class="comment">// liable for any direct, indirect, incidental, special, exemplary, or          **</span>
<span class="comment">// consequential damages (including, but not limited to, procurement of         **</span>
<span class="comment">// substitute goods or services; loss of use, data, or profits; or business     **</span>
<span class="comment">// interruption) however caused and on any theory of liability, whether in      **</span>
<span class="comment">// contract, strict liability, or tort (including negligence or otherwise)      **</span>
<span class="comment">// arising in any way out of the use of this software, even if advised of       **</span>
<span class="comment">// the possibility of such damage.                                              **</span>
<span class="comment">//********************************************************************************</span>
<span class="preprocessor">#ifndef fib_H_ALREADY_INCLUDED</span>
<span class="preprocessor"></span><span class="preprocessor">#define fib_H_ALREADY_INCLUDED</span>
<span class="preprocessor"></span>
<span class="preprocessor">#include &lt;cnc/cnc.h&gt;</span>
<span class="preprocessor">#include &lt;cnc/debug.h&gt;</span>

<span class="comment">// Forward declaration of the context class (also known as graph)</span>
<span class="keyword">struct </span>fib_context;

<span class="comment">// The step classes</span>

<span class="keyword">struct </span>fib_step
{
    <span class="keywordtype">int</span> execute( <span class="keyword">const</span> <span class="keywordtype">int</span> &amp; t, fib_context &amp; c ) <span class="keyword">const</span>;
};

<span class="comment">// The context class</span>
<span class="keyword">struct </span>fib_context : <span class="keyword">public</span> CnC::context&lt; fib_context &gt;
{
    <span class="comment">// the step collection for the instances of the compute-kernel</span>
    <a class="code" href="class_cn_c_1_1step__collection.html" title="A step collection is logical set of step instances.">CnC::step_collection&lt; fib_step &gt;</a>      m_steps;
    <span class="comment">// Item collections</span>
    <a class="code" href="class_cn_c_1_1item__collection.html" title="An item collection is a mapping from tags to items.">CnC::item_collection&lt; int, fib_type &gt;</a> m_fibs;
    <span class="comment">// Tag collections</span>
    <a class="code" href="class_cn_c_1_1tag__collection.html" title="A tag collection is a set of tags of the same type. It is used to prescribe steps. By default, tags are not stored.">CnC::tag_collection&lt; int &gt;</a>            m_tags;

    <span class="comment">// The context class constructor</span>
    fib_context()
        : CnC::context&lt; fib_context &gt;(),
          <span class="comment">// Initialize each step collection</span>
          m_steps( *this, <span class="stringliteral">&quot;fib_step&quot;</span> ),
          <span class="comment">// Initialize each tag collection</span>
          m_fibs( *this, <span class="stringliteral">&quot;fibs&quot;</span> ),
          <span class="comment">// Initialize each item collection</span>
          m_tags( *this, <span class="stringliteral">&quot;tags&quot;</span> )
    {
        <span class="comment">// prescribe compute steps with this (context) as argument</span>
        m_tags.<a class="code" href="class_cn_c_1_1tag__collection.html#a83f2782bc18578a2018851f0356c8b2a" title="Declare the prescription relationship between the tag collection and a step collection.">prescribes</a>( m_steps, *<span class="keyword">this</span> );
        <span class="comment">// step consumes m_fibs</span>
        m_steps.<a class="code" href="class_cn_c_1_1step__collection.html#aa91192651c08408d430829b6e4bca8b0" title="Declare this step-collecation as consumer of given item-collection.">consumes</a>( m_fibs );
        <span class="comment">// step also produces m_fibs</span>
        m_steps.<a class="code" href="class_cn_c_1_1step__collection.html#a7e5f64f200a66bba4228f17bfded35ca" title="Declare this step-collecation as producer for given item-collection.">produces</a>( m_fibs );
    }
};

<span class="preprocessor">#endif // fib_H_ALREADY_INCLUDED</span>
</pre></div> <h2><a class="anchor" id="fib_stats_code"></a>
samples/fib/fib_stats/fib_stats.cpp</h2>
<div class="fragment"><pre class="fragment"><span class="comment">//********************************************************************************</span>
<span class="comment">// Copyright (c) 2010-2014 Intel Corporation. All rights reserved.              **</span>
<span class="comment">//                                                                              **</span>
<span class="comment">// Redistribution and use in source and binary forms, with or without           **</span>
<span class="comment">// modification, are permitted provided that the following conditions are met:  **</span>
<span class="comment">//   * Redistributions of source code must retain the above copyright notice,   **</span>
<span class="comment">//     this list of conditions and the following disclaimer.                    **</span>
<span class="comment">//   * Redistributions in binary form must reproduce the above copyright        **</span>
<span class="comment">//     notice, this list of conditions and the following disclaimer in the      **</span>
<span class="comment">//     documentation and/or other materials provided with the distribution.     **</span>
<span class="comment">//   * Neither the name of Intel Corporation nor the names of its contributors  **</span>
<span class="comment">//     may be used to endorse or promote products derived from this software    **</span>
<span class="comment">//     without specific prior written permission.                               **</span>
<span class="comment">//                                                                              **</span>
<span class="comment">// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;  **</span>
<span class="comment">// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE    **</span>
<span class="comment">// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE   **</span>
<span class="comment">// ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE     **</span>
<span class="comment">// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR          **</span>
<span class="comment">// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF         **</span>
<span class="comment">// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS     **</span>
<span class="comment">// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN      **</span>
<span class="comment">// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)      **</span>
<span class="comment">// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF       **</span>
<span class="comment">// THE POSSIBILITY OF SUCH DAMAGE.                                              **</span>
<span class="comment">//********************************************************************************</span>

<span class="comment">// compute fibonacci numbers</span>
<span class="comment">//</span>

<span class="preprocessor">#define _CRT_SECURE_NO_DEPRECATE // to keep the VS compiler happy with TBB</span>
<span class="preprocessor"></span>
<span class="comment">// let&#39;s use a large type to store fib numbers</span>
<span class="keyword">typedef</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span> fib_type;

<span class="preprocessor">#include &quot;fib.h&quot;</span>

<span class="comment">// the actual step code computing the fib numbers goes here</span>
<span class="keywordtype">int</span> fib_step::execute( <span class="keyword">const</span> <span class="keywordtype">int</span> &amp; tag, fib_context &amp; ctxt )<span class="keyword"> const</span>
<span class="keyword"></span>{
    <span class="keywordflow">switch</span>( tag ) {
        <span class="keywordflow">case</span> 0 : ctxt.m_fibs.put( tag, 0 ); <span class="keywordflow">break</span>;
        <span class="keywordflow">case</span> 1 : ctxt.m_fibs.put( tag, 1 ); <span class="keywordflow">break</span>;
        <span class="keywordflow">default</span> : 
            <span class="comment">// get previous 2 results</span>
            fib_type f_1; ctxt.m_fibs.get( tag - 1, f_1 );
            fib_type f_2; ctxt.m_fibs.get( tag - 2, f_2 );
            <span class="comment">// put our result</span>
            ctxt.m_fibs.put( tag, f_1 + f_2 );
    }
    <span class="keywordflow">return</span> <a class="code" href="namespace_cn_c.html#ae34016c7f648af87668a0d8115b03860" title="Steps return CNC_Success if execution was successful.">CnC::CNC_Success</a>;
}

<span class="keywordtype">int</span> main( <span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>* argv[] )
{
    <span class="keywordtype">int</span> n = 42;
    <span class="comment">// eval command line args</span>
    <span class="keywordflow">if</span>( argc &lt; 2 ) {
        std::cerr &lt;&lt; <span class="stringliteral">&quot;usage: &quot;</span> &lt;&lt; argv[0] &lt;&lt; <span class="stringliteral">&quot; n\nUsing default value &quot;</span> &lt;&lt; n &lt;&lt; std::endl;
    } <span class="keywordflow">else</span> n = atol( argv[1] );

    <span class="comment">// create context</span>
    fib_context ctxt; 

    <span class="comment">// show scheduler statistics when done</span>
    <a class="code" href="struct_cn_c_1_1debug.html#af8de6416eab708937bbd263a4a17719a" title="enable collection scheduler statistics per context">CnC::debug::collect_scheduler_statistics</a>( ctxt );

    <span class="comment">// put tags to initiate evaluation</span>
    <span class="keywordflow">for</span>( <span class="keywordtype">int</span> i = 0; i &lt;= n; ++i ) ctxt.m_tags.put( i );

    <span class="comment">// wait for completion</span>
    ctxt.wait(); 

    <span class="comment">// get result</span>
    fib_type res2;
    ctxt.m_fibs.get( n, res2 );

    <span class="comment">// print result</span>
    std::cout &lt;&lt; <span class="stringliteral">&quot;fib (&quot;</span> &lt;&lt; n &lt;&lt; <span class="stringliteral">&quot;): &quot;</span> &lt;&lt; res2 &lt;&lt; std::endl;

    <span class="keywordflow">return</span> 0;
}
</pre></div> <h2><a class="anchor" id="fib_stats_h"></a>
samples/fib/fib_stats/fib.h</h2>
<div class="fragment"><pre class="fragment"><span class="comment">//********************************************************************************</span>
<span class="comment">// Copyright (c) 2007-2014 Intel Corporation. All rights reserved.              **</span>
<span class="comment">//                                                                              **</span>
<span class="comment">// Redistribution and use in source and binary forms, with or without           **</span>
<span class="comment">// modification, are permitted provided that the following conditions are met:  **</span>
<span class="comment">//   * Redistributions of source code must retain the above copyright notice,   **</span>
<span class="comment">//     this list of conditions and the following disclaimer.                    **</span>
<span class="comment">//   * Redistributions in binary form must reproduce the above copyright        **</span>
<span class="comment">//     notice, this list of conditions and the following disclaimer in the      **</span>
<span class="comment">//     documentation and/or other materials provided with the distribution.     **</span>
<span class="comment">//   * Neither the name of Intel Corporation nor the names of its contributors  **</span>
<span class="comment">//     may be used to endorse or promote products derived from this software    **</span>
<span class="comment">//     without specific prior written permission.                               **</span>
<span class="comment">//                                                                              **</span>
<span class="comment">// This software is provided by the copyright holders and contributors &quot;as is&quot;  **</span>
<span class="comment">// and any express or implied warranties, including, but not limited to, the    **</span>
<span class="comment">// implied warranties of merchantability and fitness for a particular purpose   **</span>
<span class="comment">// are disclaimed. In no event shall the copyright owner or contributors be     **</span>
<span class="comment">// liable for any direct, indirect, incidental, special, exemplary, or          **</span>
<span class="comment">// consequential damages (including, but not limited to, procurement of         **</span>
<span class="comment">// substitute goods or services; loss of use, data, or profits; or business     **</span>
<span class="comment">// interruption) however caused and on any theory of liability, whether in      **</span>
<span class="comment">// contract, strict liability, or tort (including negligence or otherwise)      **</span>
<span class="comment">// arising in any way out of the use of this software, even if advised of       **</span>
<span class="comment">// the possibility of such damage.                                              **</span>
<span class="comment">//********************************************************************************</span>
<span class="preprocessor">#ifndef fib_H_ALREADY_INCLUDED</span>
<span class="preprocessor"></span><span class="preprocessor">#define fib_H_ALREADY_INCLUDED</span>
<span class="preprocessor"></span>
<span class="preprocessor">#include &lt;cnc/cnc.h&gt;</span>
<span class="preprocessor">#include &lt;cnc/debug.h&gt;</span>

<span class="comment">// Forward declaration of the context class (also known as graph)</span>
<span class="keyword">struct </span>fib_context;

<span class="comment">// The step classes</span>

<span class="keyword">struct </span>fib_step
{
    <span class="keywordtype">int</span> execute( <span class="keyword">const</span> <span class="keywordtype">int</span> &amp; t, fib_context &amp; c ) <span class="keyword">const</span>;
};

<span class="comment">// The context class</span>
<span class="keyword">struct </span>fib_context : <span class="keyword">public</span> CnC::context&lt; fib_context &gt;
{
    <span class="comment">// the step collection for the instances of the compute-kernel</span>
    <a class="code" href="class_cn_c_1_1step__collection.html" title="A step collection is logical set of step instances.">CnC::step_collection&lt; fib_step &gt;</a>      m_steps;
    <span class="comment">// Item collections</span>
    <a class="code" href="class_cn_c_1_1item__collection.html" title="An item collection is a mapping from tags to items.">CnC::item_collection&lt; int, fib_type &gt;</a> m_fibs;
    <span class="comment">// Tag collections</span>
    <a class="code" href="class_cn_c_1_1tag__collection.html" title="A tag collection is a set of tags of the same type. It is used to prescribe steps. By default, tags are not stored.">CnC::tag_collection&lt; int &gt;</a>            m_tags;

    <span class="comment">// The context class constructor</span>
    fib_context()
        : CnC::context&lt; fib_context &gt;(),
          <span class="comment">// Initialize each step collection</span>
          m_steps( *this, <span class="stringliteral">&quot;fib_step&quot;</span> ),
          <span class="comment">// Initialize each tag collection</span>
          m_fibs( *this, <span class="stringliteral">&quot;fibs&quot;</span> ),
          <span class="comment">// Initialize each item collection</span>
          m_tags( *this, <span class="stringliteral">&quot;tags&quot;</span> )
    {
        <span class="comment">// prescribe compute steps with this (context) as argument</span>
        m_tags.<a class="code" href="class_cn_c_1_1tag__collection.html#a83f2782bc18578a2018851f0356c8b2a" title="Declare the prescription relationship between the tag collection and a step collection.">prescribes</a>( m_steps, *<span class="keyword">this</span> );
        <span class="comment">// step consumes m_fibs</span>
        m_steps.<a class="code" href="class_cn_c_1_1step__collection.html#aa91192651c08408d430829b6e4bca8b0" title="Declare this step-collecation as consumer of given item-collection.">consumes</a>( m_fibs );
        <span class="comment">// step also produces m_fibs</span>
        m_steps.<a class="code" href="class_cn_c_1_1step__collection.html#a7e5f64f200a66bba4228f17bfded35ca" title="Declare this step-collecation as producer for given item-collection.">produces</a>( m_fibs );
    }
};

<span class="preprocessor">#endif // fib_H_ALREADY_INCLUDED</span>
</pre></div> <h2><a class="anchor" id="fib_tuner_code"></a>
samples/fib/fib_tuner/fib_tuner.cpp</h2>
<div class="fragment"><pre class="fragment"><span class="comment">//********************************************************************************</span>
<span class="comment">// Copyright (c) 2010-2014 Intel Corporation. All rights reserved.              **</span>
<span class="comment">//                                                                              **</span>
<span class="comment">// Redistribution and use in source and binary forms, with or without           **</span>
<span class="comment">// modification, are permitted provided that the following conditions are met:  **</span>
<span class="comment">//   * Redistributions of source code must retain the above copyright notice,   **</span>
<span class="comment">//     this list of conditions and the following disclaimer.                    **</span>
<span class="comment">//   * Redistributions in binary form must reproduce the above copyright        **</span>
<span class="comment">//     notice, this list of conditions and the following disclaimer in the      **</span>
<span class="comment">//     documentation and/or other materials provided with the distribution.     **</span>
<span class="comment">//   * Neither the name of Intel Corporation nor the names of its contributors  **</span>
<span class="comment">//     may be used to endorse or promote products derived from this software    **</span>
<span class="comment">//     without specific prior written permission.                               **</span>
<span class="comment">//                                                                              **</span>
<span class="comment">// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;  **</span>
<span class="comment">// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE    **</span>
<span class="comment">// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE   **</span>
<span class="comment">// ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE     **</span>
<span class="comment">// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR          **</span>
<span class="comment">// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF         **</span>
<span class="comment">// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS     **</span>
<span class="comment">// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN      **</span>
<span class="comment">// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)      **</span>
<span class="comment">// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF       **</span>
<span class="comment">// THE POSSIBILITY OF SUCH DAMAGE.                                              **</span>
<span class="comment">//********************************************************************************</span>

<span class="comment">// compute fibonacci numbers</span>
<span class="comment">//</span>

<span class="preprocessor">#define _CRT_SECURE_NO_DEPRECATE // to keep the VS compiler happy with TBB</span>
<span class="preprocessor"></span>
<span class="comment">// let&#39;s use a large type to store fib numbers</span>
<span class="keyword">typedef</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span> fib_type;

<span class="preprocessor">#include &quot;cnc/cnc.h&quot;</span>

<span class="keyword">struct </span>fib_context;

<span class="comment">// let&#39;s use a tuner to pre-declare dependencies</span>
<span class="keyword">struct </span>fib_tuner : <span class="keyword">public</span> CnC::step_tuner&lt;&gt;
{
    <span class="keyword">template</span>&lt; <span class="keyword">class</span> dependency_consumer &gt;
    <span class="keywordtype">void</span> depends( <span class="keyword">const</span> <span class="keywordtype">int</span> &amp; tag, fib_context &amp; c, dependency_consumer &amp; dC ) <span class="keyword">const</span>;
};

<span class="preprocessor">#include &quot;fib.h&quot;</span>

<span class="keyword">template</span>&lt; <span class="keyword">class</span> dependency_consumer &gt;
<span class="keywordtype">void</span> fib_tuner::depends( <span class="keyword">const</span> <span class="keywordtype">int</span> &amp; tag, fib_context &amp; c, dependency_consumer &amp; dC )<span class="keyword"> const</span>
<span class="keyword"></span>{
    <span class="comment">// we have item-dependencies only if tag &gt; 1</span>
    <span class="keywordflow">if</span>( tag &gt; 1 ) {
      dC.depends( c.m_fibs, tag - 1 );
      dC.depends( c.m_fibs, tag - 2 );
    }
}

<span class="comment">// the actual step code computing the fib numbers goes here</span>
<span class="keywordtype">int</span> fib_step::execute( <span class="keyword">const</span> <span class="keywordtype">int</span> &amp; tag, fib_context &amp; ctxt )<span class="keyword"> const</span>
<span class="keyword"></span>{
    <span class="keywordflow">switch</span>( tag ) {
        <span class="keywordflow">case</span> 0 : ctxt.m_fibs.put( tag, 0 ); <span class="keywordflow">break</span>;
        <span class="keywordflow">case</span> 1 : ctxt.m_fibs.put( tag, 1 ); <span class="keywordflow">break</span>;
        <span class="keywordflow">default</span> : 
            <span class="comment">// get previous 2 results</span>
            fib_type f_1; ctxt.m_fibs.get( tag - 1, f_1 );
            fib_type f_2; ctxt.m_fibs.get( tag - 2, f_2 );
            <span class="comment">// put our result</span>
            ctxt.m_fibs.put( tag, f_1 + f_2 );
    }
    <span class="keywordflow">return</span> <a class="code" href="namespace_cn_c.html#ae34016c7f648af87668a0d8115b03860" title="Steps return CNC_Success if execution was successful.">CnC::CNC_Success</a>;
}

<span class="keywordtype">int</span> main( <span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>* argv[] )
{
    <span class="keywordtype">int</span> n = 42;
    <span class="comment">// eval command line args</span>
    <span class="keywordflow">if</span>( argc &lt; 2 ) {
        std::cerr &lt;&lt; <span class="stringliteral">&quot;usage: &quot;</span> &lt;&lt; argv[0] &lt;&lt; <span class="stringliteral">&quot; n\nUsing default value &quot;</span> &lt;&lt; n &lt;&lt; std::endl;
    } <span class="keywordflow">else</span> n = atol( argv[1] );

    <span class="comment">// create context</span>
    fib_context ctxt; 

    <span class="comment">// show scheduler statistics when done</span>
    <a class="code" href="struct_cn_c_1_1debug.html#af8de6416eab708937bbd263a4a17719a" title="enable collection scheduler statistics per context">CnC::debug::collect_scheduler_statistics</a>( ctxt );

    <span class="comment">// put tags to initiate evaluation</span>
    <span class="keywordflow">for</span>( <span class="keywordtype">int</span> i = 0; i &lt;= n; ++i ) ctxt.m_tags.put( i );

    <span class="comment">// wait for completion</span>
    ctxt.wait(); 

    <span class="comment">// get result</span>
    fib_type res2;
    ctxt.m_fibs.get( n, res2 );

    <span class="comment">// print result</span>
    std::cout &lt;&lt; <span class="stringliteral">&quot;fib (&quot;</span> &lt;&lt; n &lt;&lt; <span class="stringliteral">&quot;): &quot;</span> &lt;&lt; res2 &lt;&lt; std::endl;

    <span class="keywordflow">return</span> 0;
}
</pre></div> <h2><a class="anchor" id="fib_preschedule_code"></a>
samples/fib/fib_preschedule/fib_preschedule.cpp</h2>
<div class="fragment"><pre class="fragment"><span class="comment">//********************************************************************************</span>
<span class="comment">// Copyright (c) 2007-2014 Intel Corporation. All rights reserved.              **</span>
<span class="comment">//                                                                              **</span>
<span class="comment">// Redistribution and use in source and binary forms, with or without           **</span>
<span class="comment">// modification, are permitted provided that the following conditions are met:  **</span>
<span class="comment">//   * Redistributions of source code must retain the above copyright notice,   **</span>
<span class="comment">//     this list of conditions and the following disclaimer.                    **</span>
<span class="comment">//   * Redistributions in binary form must reproduce the above copyright        **</span>
<span class="comment">//     notice, this list of conditions and the following disclaimer in the      **</span>
<span class="comment">//     documentation and/or other materials provided with the distribution.     **</span>
<span class="comment">//   * Neither the name of Intel Corporation nor the names of its contributors  **</span>
<span class="comment">//     may be used to endorse or promote products derived from this software    **</span>
<span class="comment">//     without specific prior written permission.                               **</span>
<span class="comment">//                                                                              **</span>
<span class="comment">// This software is provided by the copyright holders and contributors &quot;as is&quot;  **</span>
<span class="comment">// and any express or implied warranties, including, but not limited to, the    **</span>
<span class="comment">// implied warranties of merchantability and fitness for a particular purpose   **</span>
<span class="comment">// are disclaimed. In no event shall the copyright owner or contributors be     **</span>
<span class="comment">// liable for any direct, indirect, incidental, special, exemplary, or          **</span>
<span class="comment">// consequential damages (including, but not limited to, procurement of         **</span>
<span class="comment">// substitute goods or services; loss of use, data, or profits; or business     **</span>
<span class="comment">// interruption) however caused and on any theory of liability, whether in      **</span>
<span class="comment">// contract, strict liability, or tort (including negligence or otherwise)      **</span>
<span class="comment">// arising in any way out of the use of this software, even if advised of       **</span>
<span class="comment">// the possibility of such damage.                                              **</span>
<span class="comment">//********************************************************************************</span>

<span class="comment">// compute fibonacci numbers</span>
<span class="comment">//</span>

<span class="preprocessor">#define _CRT_SECURE_NO_DEPRECATE // to keep the VS compiler happy with TBB</span>
<span class="preprocessor"></span>
<span class="comment">// let&#39;s use a large type to store fib numbers</span>
<span class="keyword">typedef</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span> fib_type;

<span class="preprocessor">#include &quot;cnc/cnc.h&quot;</span>

<span class="keyword">struct </span>fib_context;

<span class="comment">// let&#39;s use a tuner to pre-declare dependencies</span>
<span class="keyword">struct </span>fib_tuner : <span class="keyword">public</span> CnC::step_tuner&lt;&gt;
{
    <span class="keywordtype">bool</span> preschedule()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> <span class="keyword">true</span>; }
};

<span class="preprocessor">#include &quot;fib.h&quot;</span>

<span class="comment">// the actual step code computing the fib numbers goes here</span>
<span class="keywordtype">int</span> fib_step::execute( <span class="keyword">const</span> <span class="keywordtype">int</span> &amp; tag, fib_context &amp; ctxt )<span class="keyword"> const</span>
<span class="keyword"></span>{
    <span class="keywordflow">switch</span>( tag ) {
        <span class="keywordflow">case</span> 0 : ctxt.m_fibs.put( tag, 0 ); <span class="keywordflow">break</span>;
        <span class="keywordflow">case</span> 1 : ctxt.m_fibs.put( tag, 1 ); <span class="keywordflow">break</span>;
        <span class="keywordflow">default</span> : 
            <span class="comment">// get previous 2 results</span>
            fib_type f_1; ctxt.m_fibs.get( tag - 1, f_1 );
            fib_type f_2; ctxt.m_fibs.get( tag - 2, f_2 );
            <span class="comment">// ctxt.flush_gets(); // uncomment this line to prohibit pre-scheduling from completing full step-execution</span>
            <span class="comment">// put our result</span>
            ctxt.m_fibs.put( tag, f_1 + f_2 );
    }
    <span class="keywordflow">return</span> <a class="code" href="namespace_cn_c.html#ae34016c7f648af87668a0d8115b03860" title="Steps return CNC_Success if execution was successful.">CnC::CNC_Success</a>;
}

<span class="keywordtype">int</span> main( <span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>* argv[] )
{
    <span class="keywordtype">int</span> n = 42;
    <span class="comment">// eval command line args</span>
    <span class="keywordflow">if</span>( argc &lt; 2 ) {
        std::cerr &lt;&lt; <span class="stringliteral">&quot;usage: &quot;</span> &lt;&lt; argv[0] &lt;&lt; <span class="stringliteral">&quot; n\nUsing default value &quot;</span> &lt;&lt; n &lt;&lt; std::endl;
    } <span class="keywordflow">else</span> n = atol( argv[1] );

    <span class="comment">// create context</span>
    fib_context ctxt; 

    <span class="comment">// show scheduler statistics when done</span>
    <a class="code" href="struct_cn_c_1_1debug.html#af8de6416eab708937bbd263a4a17719a" title="enable collection scheduler statistics per context">CnC::debug::collect_scheduler_statistics</a>( ctxt );

    <span class="comment">// put tags to initiate evaluation</span>
    <span class="keywordflow">for</span>( <span class="keywordtype">int</span> i = 0; i &lt;= n; ++i ) ctxt.m_tags.put( i );

    <span class="comment">// wait for completion</span>
    ctxt.wait(); 

    <span class="comment">// get result</span>
    fib_type res2;
    ctxt.m_fibs.get( n, res2 );

    <span class="comment">// print result</span>
    std::cout &lt;&lt; <span class="stringliteral">&quot;fib (&quot;</span> &lt;&lt; n &lt;&lt; <span class="stringliteral">&quot;): &quot;</span> &lt;&lt; res2 &lt;&lt; std::endl;

    <span class="keywordflow">return</span> 0;
}
</pre></div> <h2><a class="anchor" id="fib_getcount_code"></a>
samples/fib/fib_getcount/fib_getcount.cpp</h2>
<div class="fragment"><pre class="fragment"><span class="comment">//********************************************************************************</span>
<span class="comment">// Copyright (c) 2010-2014 Intel Corporation. All rights reserved.              **</span>
<span class="comment">//                                                                              **</span>
<span class="comment">// Redistribution and use in source and binary forms, with or without           **</span>
<span class="comment">// modification, are permitted provided that the following conditions are met:  **</span>
<span class="comment">//   * Redistributions of source code must retain the above copyright notice,   **</span>
<span class="comment">//     this list of conditions and the following disclaimer.                    **</span>
<span class="comment">//   * Redistributions in binary form must reproduce the above copyright        **</span>
<span class="comment">//     notice, this list of conditions and the following disclaimer in the      **</span>
<span class="comment">//     documentation and/or other materials provided with the distribution.     **</span>
<span class="comment">//   * Neither the name of Intel Corporation nor the names of its contributors  **</span>
<span class="comment">//     may be used to endorse or promote products derived from this software    **</span>
<span class="comment">//     without specific prior written permission.                               **</span>
<span class="comment">//                                                                              **</span>
<span class="comment">// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;  **</span>
<span class="comment">// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE    **</span>
<span class="comment">// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE   **</span>
<span class="comment">// ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE     **</span>
<span class="comment">// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR          **</span>
<span class="comment">// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF         **</span>
<span class="comment">// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS     **</span>
<span class="comment">// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN      **</span>
<span class="comment">// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)      **</span>
<span class="comment">// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF       **</span>
<span class="comment">// THE POSSIBILITY OF SUCH DAMAGE.                                              **</span>
<span class="comment">//********************************************************************************</span>

<span class="comment">// compute fibonacci numbers</span>
<span class="comment">//</span>

<span class="preprocessor">#define _CRT_SECURE_NO_DEPRECATE // to keep the VS compiler happy with TBB</span>
<span class="preprocessor"></span>
<span class="preprocessor">#include &lt;cnc/cnc.h&gt;</span>

<span class="comment">// let&#39;s use a large type to store fib numbers</span>
<span class="keyword">typedef</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span> fib_type;

<span class="keyword">struct </span>fib_context;

<span class="comment">// let&#39;s use a tuner to pre-declare dependencies</span>
<span class="keyword">struct </span>fib_tuner : <span class="keyword">public</span> CnC::step_tuner&lt;&gt;
{
    <span class="comment">// pre-declare data-dependencies</span>
    <span class="keyword">template</span>&lt; <span class="keyword">class</span> dependency_consumer &gt;
    <span class="keywordtype">void</span> depends( <span class="keyword">const</span> <span class="keywordtype">int</span> &amp; tag, fib_context &amp; c, dependency_consumer &amp; dC ) <span class="keyword">const</span>;
};

<span class="keyword">struct </span>item_tuner : <span class="keyword">public</span> CnC::hashmap_tuner
{
    <span class="comment">// provide number gets to each item</span>
    <span class="keywordtype">int</span> get_count( <span class="keyword">const</span> <span class="keywordtype">int</span> &amp; tag ) <span class="keyword">const</span>;
};

<span class="preprocessor">#include &quot;fib.h&quot;</span>

<span class="keyword">template</span>&lt; <span class="keyword">class</span> dependency_consumer &gt;
<span class="keywordtype">void</span> fib_tuner::depends( <span class="keyword">const</span> <span class="keywordtype">int</span> &amp; tag, fib_context &amp; c, dependency_consumer &amp; dC )<span class="keyword"> const</span>
<span class="keyword"></span>{
    <span class="comment">// we have item-dependencies only if tag &gt; 1</span>
    <span class="keywordflow">if</span>( tag &gt; 1 ) {
      dC.depends( c.m_fibs, tag - 1 );
      dC.depends( c.m_fibs, tag - 2 );
    }
}

<span class="keywordtype">int</span> item_tuner::get_count( <span class="keyword">const</span> <span class="keywordtype">int</span> &amp; tag )<span class="keyword"> const</span>
<span class="keyword"></span>{
    <span class="keywordflow">return</span> tag &gt; 0 ? 2 : 1;
}

<span class="comment">// the actual step code computing the fib numbers goes here</span>
<span class="keywordtype">int</span> fib_step::execute( <span class="keyword">const</span> <span class="keywordtype">int</span> &amp; tag, fib_context &amp; ctxt )<span class="keyword"> const</span>
<span class="keyword"></span>{
    <span class="keywordflow">switch</span>( tag ) {
        <span class="keywordflow">case</span> 0 : ctxt.m_fibs.put( tag, 0 ); <span class="keywordflow">break</span>;
        <span class="keywordflow">case</span> 1 : ctxt.m_fibs.put( tag, 1 ); <span class="keywordflow">break</span>;
        <span class="keywordflow">default</span> : 
            <span class="comment">// get previous 2 results</span>
            fib_type f_1; ctxt.m_fibs.get( tag - 1, f_1 );
            fib_type f_2; ctxt.m_fibs.get( tag - 2, f_2 );
            <span class="comment">// put our result, and specify that this data item will be</span>
            <span class="comment">// get&#39;ed twice (i.e. for the next two fib calculations)</span>
            <span class="comment">// before it is destroyed</span>
            ctxt.m_fibs.put( tag, f_1 + f_2 );
    }
    <span class="keywordflow">return</span> <a class="code" href="namespace_cn_c.html#ae34016c7f648af87668a0d8115b03860" title="Steps return CNC_Success if execution was successful.">CnC::CNC_Success</a>;
}

<span class="keywordtype">int</span> main( <span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>* argv[] )
{
    <span class="keywordtype">int</span> n = 42;
    <span class="comment">// eval command line args</span>
    <span class="keywordflow">if</span>( argc &lt; 2 ) {
        std::cerr &lt;&lt; <span class="stringliteral">&quot;usage: &quot;</span> &lt;&lt; argv[0] &lt;&lt; <span class="stringliteral">&quot; n\nUsing default value &quot;</span> &lt;&lt; n &lt;&lt; std::endl;
    } <span class="keywordflow">else</span> n = atol( argv[1] );

    <span class="comment">// create context</span>
    fib_context ctxt; 

    <span class="comment">// show scheduler statistics when done</span>
    <a class="code" href="struct_cn_c_1_1debug.html#af8de6416eab708937bbd263a4a17719a" title="enable collection scheduler statistics per context">CnC::debug::collect_scheduler_statistics</a>( ctxt );

    <span class="comment">// put tags to initiate evaluation</span>
    <span class="keywordflow">for</span>( <span class="keywordtype">int</span> i = 0; i &lt;= n; ++i ) ctxt.m_tags.put( i );

    <span class="comment">// wait for completion</span>
    ctxt.wait(); 

    <span class="comment">// get result</span>
    fib_type res2;
    ctxt.m_fibs.get( n, res2 );

    <span class="comment">// print result</span>
    std::cout &lt;&lt; <span class="stringliteral">&quot;fib (&quot;</span> &lt;&lt; n &lt;&lt; <span class="stringliteral">&quot;): &quot;</span> &lt;&lt; res2 &lt;&lt; std::endl;

    <span class="keywordflow">return</span> 0;
}
</pre></div> <h2><a class="anchor" id="fib_getcount_h"></a>
samples/fib/fib_getcount/fib.h</h2>
<div class="fragment"><pre class="fragment"><span class="comment">//********************************************************************************</span>
<span class="comment">// Copyright (c) 2007-2014 Intel Corporation. All rights reserved.              **</span>
<span class="comment">//                                                                              **</span>
<span class="comment">// Redistribution and use in source and binary forms, with or without           **</span>
<span class="comment">// modification, are permitted provided that the following conditions are met:  **</span>
<span class="comment">//   * Redistributions of source code must retain the above copyright notice,   **</span>
<span class="comment">//     this list of conditions and the following disclaimer.                    **</span>
<span class="comment">//   * Redistributions in binary form must reproduce the above copyright        **</span>
<span class="comment">//     notice, this list of conditions and the following disclaimer in the      **</span>
<span class="comment">//     documentation and/or other materials provided with the distribution.     **</span>
<span class="comment">//   * Neither the name of Intel Corporation nor the names of its contributors  **</span>
<span class="comment">//     may be used to endorse or promote products derived from this software    **</span>
<span class="comment">//     without specific prior written permission.                               **</span>
<span class="comment">//                                                                              **</span>
<span class="comment">// This software is provided by the copyright holders and contributors &quot;as is&quot;  **</span>
<span class="comment">// and any express or implied warranties, including, but not limited to, the    **</span>
<span class="comment">// implied warranties of merchantability and fitness for a particular purpose   **</span>
<span class="comment">// are disclaimed. In no event shall the copyright owner or contributors be     **</span>
<span class="comment">// liable for any direct, indirect, incidental, special, exemplary, or          **</span>
<span class="comment">// consequential damages (including, but not limited to, procurement of         **</span>
<span class="comment">// substitute goods or services; loss of use, data, or profits; or business     **</span>
<span class="comment">// interruption) however caused and on any theory of liability, whether in      **</span>
<span class="comment">// contract, strict liability, or tort (including negligence or otherwise)      **</span>
<span class="comment">// arising in any way out of the use of this software, even if advised of       **</span>
<span class="comment">// the possibility of such damage.                                              **</span>
<span class="comment">//********************************************************************************</span>
<span class="preprocessor">#ifndef fib_H_ALREADY_INCLUDED</span>
<span class="preprocessor"></span><span class="preprocessor">#define fib_H_ALREADY_INCLUDED</span>
<span class="preprocessor"></span>
<span class="preprocessor">#include &lt;cnc/cnc.h&gt;</span>
<span class="preprocessor">#include &lt;cnc/debug.h&gt;</span>

<span class="comment">// Forward declaration of the context class (also known as graph)</span>
<span class="keyword">struct </span>fib_context;

<span class="comment">// The step classes</span>

<span class="keyword">struct </span>fib_step
{
    <span class="keywordtype">int</span> execute( <span class="keyword">const</span> <span class="keywordtype">int</span> &amp; t, fib_context &amp; c ) <span class="keyword">const</span>;
};

<span class="comment">// The context class</span>
<span class="keyword">struct </span>fib_context : <span class="keyword">public</span> CnC::context&lt; fib_context &gt;
{
    <span class="comment">// the step collection for the instances of the compute-kernel</span>
    <a class="code" href="class_cn_c_1_1step__collection.html" title="A step collection is logical set of step instances.">CnC::step_collection&lt; fib_step, fib_tuner &gt;</a> m_steps;
    <span class="comment">// Item collections</span>
    <a class="code" href="class_cn_c_1_1item__collection.html" title="An item collection is a mapping from tags to items.">CnC::item_collection&lt; int, fib_type, item_tuner &gt;</a> m_fibs;
    <span class="comment">// Tag collections</span>
    <a class="code" href="class_cn_c_1_1tag__collection.html" title="A tag collection is a set of tags of the same type. It is used to prescribe steps. By default, tags are not stored.">CnC::tag_collection&lt; int &gt;</a>            m_tags;

    <span class="comment">// The context class constructor</span>
    fib_context()
        : CnC::context&lt; fib_context &gt;(),
          <span class="comment">// Initialize each step collection</span>
          m_steps( *this, <span class="stringliteral">&quot;fib_step&quot;</span> ),
          <span class="comment">// Initialize each tag collection</span>
          m_fibs( *this, <span class="stringliteral">&quot;fibs&quot;</span> ),
          <span class="comment">// Initialize each item collection</span>
          m_tags( *this, <span class="stringliteral">&quot;tags&quot;</span> )
    {
        <span class="comment">// prescribe compute steps with this (context) as argument</span>
        m_tags.<a class="code" href="class_cn_c_1_1tag__collection.html#a83f2782bc18578a2018851f0356c8b2a" title="Declare the prescription relationship between the tag collection and a step collection.">prescribes</a>( m_steps, *<span class="keyword">this</span> );
        <span class="comment">// step consumes m_fibs</span>
        m_steps.<a class="code" href="class_cn_c_1_1step__collection.html#aa91192651c08408d430829b6e4bca8b0" title="Declare this step-collecation as consumer of given item-collection.">consumes</a>( m_fibs );
        <span class="comment">// step also produces m_fibs</span>
        m_steps.<a class="code" href="class_cn_c_1_1step__collection.html#a7e5f64f200a66bba4228f17bfded35ca" title="Declare this step-collecation as producer for given item-collection.">produces</a>( m_fibs );
    }
};

<span class="preprocessor">#endif // fib_H_ALREADY_INCLUDED</span>
</pre></div> <h2><a class="anchor" id="primes_range_code"></a>
samples/primes/primes_range/primes_range.cpp</h2>
<div class="fragment"><pre class="fragment"><span class="comment">//********************************************************************************</span>
<span class="comment">// Copyright (c) 2007-2014 Intel Corporation. All rights reserved.              **</span>
<span class="comment">//                                                                              **</span>
<span class="comment">// Redistribution and use in source and binary forms, with or without           **</span>
<span class="comment">// modification, are permitted provided that the following conditions are met:  **</span>
<span class="comment">//   * Redistributions of source code must retain the above copyright notice,   **</span>
<span class="comment">//     this list of conditions and the following disclaimer.                    **</span>
<span class="comment">//   * Redistributions in binary form must reproduce the above copyright        **</span>
<span class="comment">//     notice, this list of conditions and the following disclaimer in the      **</span>
<span class="comment">//     documentation and/or other materials provided with the distribution.     **</span>
<span class="comment">//   * Neither the name of Intel Corporation nor the names of its contributors  **</span>
<span class="comment">//     may be used to endorse or promote products derived from this software    **</span>
<span class="comment">//     without specific prior written permission.                               **</span>
<span class="comment">//                                                                              **</span>
<span class="comment">// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;  **</span>
<span class="comment">// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE    **</span>
<span class="comment">// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE   **</span>
<span class="comment">// ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE     **</span>
<span class="comment">// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR          **</span>
<span class="comment">// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF         **</span>
<span class="comment">// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS     **</span>
<span class="comment">// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN      **</span>
<span class="comment">// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)      **</span>
<span class="comment">// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF       **</span>
<span class="comment">// THE POSSIBILITY OF SUCH DAMAGE.                                              **</span>
<span class="comment">//********************************************************************************</span>
<span class="comment">//</span>
<span class="preprocessor">#include &lt;stdio.h&gt;</span>
<span class="preprocessor">#include &lt;stdlib.h&gt;</span>
<span class="preprocessor">#include &lt;string.h&gt;</span>
<span class="preprocessor">#include &lt;tbb/tick_count.h&gt;</span>
<span class="preprocessor">#ifdef _DIST_</span>
<span class="preprocessor"></span><span class="preprocessor">#include &lt;cnc/dist_cnc.h&gt;</span>
<span class="preprocessor">#include &lt;cnc/internal/dist/distributor.h&gt;</span>
<span class="preprocessor">#else</span>
<span class="preprocessor"></span><span class="preprocessor">#include &lt;cnc/cnc.h&gt;</span>
<span class="preprocessor">#endif</span>
<span class="preprocessor"></span>

<span class="keyword">struct </span>my_context;

<span class="keyword">struct </span>FindPrimes
{
    <span class="keywordtype">int</span> execute( <span class="keywordtype">int</span> n, my_context &amp; c ) <span class="keyword">const</span>;
};

<span class="keyword">struct </span>primes_tuner : <span class="keyword">public</span> CnC::step_tuner&lt;&gt;
{
    <span class="keywordtype">int</span> compute_on( <span class="keyword">const</span> <span class="keywordtype">int</span> &amp; p, my_context &amp; )<span class="keyword"> const</span>
<span class="keyword">    </span>{
        <span class="keywordflow">return</span> ( 1 + p / ( 1000000 / 20 ) ) % numProcs();<span class="comment">//( p * 5 / 3 + 1 ) % 5;</span>
    }
};

<span class="keyword">struct </span>my_context : <span class="keyword">public</span> CnC::context&lt; my_context &gt;
{
    <a class="code" href="class_cn_c_1_1step__collection.html" title="A step collection is logical set of step instances.">CnC::step_collection&lt; FindPrimes, primes_tuner &gt;</a> m_steps;
    <a class="code" href="class_cn_c_1_1tag__collection.html" title="A tag collection is a set of tags of the same type. It is used to prescribe steps. By default, tags are not stored.">CnC::tag_collection&lt; int, CnC::tag_tuner&lt; CnC::Internal::strided_range&lt; int &gt;</a> &gt; &gt; m_tags;
    <a class="code" href="class_cn_c_1_1item__collection.html" title="An item collection is a mapping from tags to items.">CnC::item_collection&lt; int,int &gt;</a> m_primes;
    my_context() 
        : CnC::context&lt; my_context &gt;(),
          m_steps( *this ),
          m_tags( *this ),
          m_primes( *this )
    {
        m_tags.<a class="code" href="class_cn_c_1_1tag__collection.html#a83f2782bc18578a2018851f0356c8b2a" title="Declare the prescription relationship between the tag collection and a step collection.">prescribes</a>( m_steps, *<span class="keyword">this</span> );
    }
};


<span class="keywordtype">int</span> FindPrimes::execute( <span class="keywordtype">int</span> n, my_context &amp; c )<span class="keyword"> const</span>
<span class="keyword"></span>{
    <span class="keywordtype">int</span> factor = 3;

    <span class="keywordflow">while</span> ( n % factor ) factor += 2;
    <span class="keywordflow">if</span> (factor == n) c.m_primes.put(n, n);

    <span class="keywordflow">return</span> <a class="code" href="namespace_cn_c.html#ae34016c7f648af87668a0d8115b03860" title="Steps return CNC_Success if execution was successful.">CnC::CNC_Success</a>;
}


<span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>* argv[])
{
<span class="preprocessor">#ifdef _DIST_</span>
<span class="preprocessor"></span>    <a class="code" href="struct_cn_c_1_1dist__cnc__init.html">CnC::dist_cnc_init&lt; my_context &gt;</a> dc_init;
<span class="preprocessor">#endif</span>
<span class="preprocessor"></span>    <span class="keywordtype">bool</span> verbose = <span class="keyword">false</span>;
    <span class="keywordtype">int</span> n = 0;
    <span class="keywordtype">int</span> number_of_primes = 0;

    <span class="keywordflow">if</span> (argc == 2) 
    {
        n = atoi(argv[1]);
    }
    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (argc == 3 &amp;&amp; 0 == strcmp(<span class="stringliteral">&quot;-v&quot;</span>, argv[1]))
    {
        n = atoi(argv[2]);
        verbose = <span class="keyword">true</span>;
    }
    <span class="keywordflow">else</span>
    {
        fprintf(stderr,<span class="stringliteral">&quot;Usage: primes [-v] n\n&quot;</span>);
        <span class="keywordflow">return</span> -1;
    }

    my_context c;

    printf(<span class="stringliteral">&quot;Determining primes from 1-%d \n&quot;</span>,n);

    tbb::tick_count t0 = tbb::tick_count::now();

    c.m_tags.put_range( CnC::Internal::strided_range&lt; int &gt;( 3, n, 2 ) );

    c.wait();

    tbb::tick_count t1 = tbb::tick_count::now();
    <span class="comment">// FIXME we have to transfer the items to the host first (distCnC)</span>
    number_of_primes = (int)c.m_primes.size() + 1;
    printf(<span class="stringliteral">&quot;Found %d primes in %g seconds\n&quot;</span>, number_of_primes, (t1-t0).seconds());

    <span class="keywordflow">if</span> (verbose)
    {
        printf(<span class="stringliteral">&quot;%d\n&quot;</span>, 2);
        <a class="code" href="class_cn_c_1_1item__collection.html" title="An item collection is a mapping from tags to items.">CnC::item_collection&lt;int,int&gt;::const_iterator</a> cii;
        <span class="keywordflow">for</span> (cii = c.m_primes.begin(); cii != c.m_primes.end(); cii++) 
        {
            printf(<span class="stringliteral">&quot;%d\n&quot;</span>, cii-&gt;first); <span class="comment">// kludge</span>
        }
    }
}

</pre></div> <h2><a class="anchor" id="primes_parfor_code"></a>
samples/primes/primes_parfor/primes_parfor.cpp</h2>
<div class="fragment"><pre class="fragment"><span class="comment">//********************************************************************************</span>
<span class="comment">// Copyright (c) 2007-2014 Intel Corporation. All rights reserved.              **</span>
<span class="comment">//                                                                              **</span>
<span class="comment">// Redistribution and use in source and binary forms, with or without           **</span>
<span class="comment">// modification, are permitted provided that the following conditions are met:  **</span>
<span class="comment">//   * Redistributions of source code must retain the above copyright notice,   **</span>
<span class="comment">//     this list of conditions and the following disclaimer.                    **</span>
<span class="comment">//   * Redistributions in binary form must reproduce the above copyright        **</span>
<span class="comment">//     notice, this list of conditions and the following disclaimer in the      **</span>
<span class="comment">//     documentation and/or other materials provided with the distribution.     **</span>
<span class="comment">//   * Neither the name of Intel Corporation nor the names of its contributors  **</span>
<span class="comment">//     may be used to endorse or promote products derived from this software    **</span>
<span class="comment">//     without specific prior written permission.                               **</span>
<span class="comment">//                                                                              **</span>
<span class="comment">// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;  **</span>
<span class="comment">// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE    **</span>
<span class="comment">// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE   **</span>
<span class="comment">// ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE     **</span>
<span class="comment">// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR          **</span>
<span class="comment">// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF         **</span>
<span class="comment">// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS     **</span>
<span class="comment">// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN      **</span>
<span class="comment">// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)      **</span>
<span class="comment">// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF       **</span>
<span class="comment">// THE POSSIBILITY OF SUCH DAMAGE.                                              **</span>
<span class="comment">//********************************************************************************</span>
<span class="comment">//</span>
<span class="preprocessor">#include &lt;stdio.h&gt;</span>
<span class="preprocessor">#include &lt;stdlib.h&gt;</span>
<span class="preprocessor">#include &lt;string.h&gt;</span>
<span class="preprocessor">#include &lt;tbb/tick_count.h&gt;</span>
<span class="preprocessor">#include &lt;cnc/cnc.h&gt;</span>
<span class="preprocessor">#include &lt;cnc/debug.h&gt;</span>

<span class="keyword">struct </span>my_context;

<span class="keyword">struct </span>FindPrimes
{
    <span class="keywordtype">int</span> operator()( <span class="keywordtype">int</span> n ) <span class="keyword">const</span>;
};

<span class="keyword">struct </span>my_context : <span class="keyword">public</span> CnC::context&lt; my_context &gt;
{
    <a class="code" href="class_cn_c_1_1item__collection.html" title="An item collection is a mapping from tags to items.">CnC::item_collection&lt; int,int &gt;</a> m_primes;
    my_context() 
        : CnC::context&lt; my_context &gt;(),
          m_primes( *this )
    {
        <a class="code" href="struct_cn_c_1_1debug.html#af8de6416eab708937bbd263a4a17719a" title="enable collection scheduler statistics per context">CnC::debug::collect_scheduler_statistics</a>( *<span class="keyword">this</span> );
    }
};


my_context g_c;

<span class="keywordtype">int</span> FindPrimes::operator()( <span class="keywordtype">int</span> n )<span class="keyword"> const</span>
<span class="keyword"></span>{
    <span class="keywordtype">int</span> factor = 3;

    <span class="keywordflow">while</span> ( n % factor ) factor += 2;
    <span class="keywordflow">if</span> (factor == n) g_c.m_primes.put(n, n);

    <span class="keywordflow">return</span> <a class="code" href="namespace_cn_c.html#ae34016c7f648af87668a0d8115b03860" title="Steps return CNC_Success if execution was successful.">CnC::CNC_Success</a>;
}


<span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>* argv[])
{
    <span class="keywordtype">bool</span> verbose = <span class="keyword">false</span>;
    <span class="keywordtype">int</span> n = 0;
    <span class="keywordtype">int</span> number_of_primes = 0;

    <span class="keywordflow">if</span> (argc == 2) 
    {
        n = atoi(argv[1]);
    }
    <span class="keywordflow">else</span> <span class="keywordflow">if</span> (argc == 3 &amp;&amp; 0 == strcmp(<span class="stringliteral">&quot;-v&quot;</span>, argv[1]))
    {
        n = atoi(argv[2]);
        verbose = <span class="keyword">true</span>;
    }
    <span class="keywordflow">else</span>
    {
        fprintf(stderr,<span class="stringliteral">&quot;Usage: primes [-v] n\n&quot;</span>);
        <span class="keywordflow">return</span> -1;
    }


    printf(<span class="stringliteral">&quot;Determining primes from 1-%d \n&quot;</span>,n);

    tbb::tick_count t0 = tbb::tick_count::now();

    <a class="code" href="namespace_cn_c.html#ae3c2dbac829e8845b8608fae7bdf41a8" title="Execute f( i ) for every i in {first &lt;= i=first+step*x &lt; last and 0 &lt;= x}.">CnC::parallel_for</a>( 3, n+1, 2, FindPrimes(), <a class="code" href="struct_cn_c_1_1pfor__tuner.html" title="Default (NOP) implementations of the pfor_tuner interface.">CnC::pfor_tuner&lt; false &gt;</a>() );

    tbb::tick_count t1 = tbb::tick_count::now();

    number_of_primes = (int)g_c.m_primes.size() + 1;
    printf(<span class="stringliteral">&quot;Found %d primes in %g seconds\n&quot;</span>, number_of_primes, (t1-t0).seconds());

    <span class="keywordflow">if</span> (verbose)
    {
        printf(<span class="stringliteral">&quot;%d\n&quot;</span>, 2);
        <span class="keywordflow">for</span> (<a class="code" href="class_cn_c_1_1item__collection.html" title="An item collection is a mapping from tags to items.">CnC::item_collection&lt;int,int&gt;::const_iterator</a> cii = g_c.m_primes.begin(); cii != g_c.m_primes.end(); cii++) 
        {
            printf(<span class="stringliteral">&quot;%d\n&quot;</span>, cii-&gt;first); <span class="comment">// kludge</span>
        }
    }
}

</pre></div> <h2><a class="anchor" id="bs_tuner"></a>
samples/blackscholes/blackscholes/blackscholes.h</h2>
<div class="fragment"><pre class="fragment"><span class="comment">//********************************************************************************</span>
<span class="comment">// Copyright (c) 2007-2014 Intel Corporation. All rights reserved.              **</span>
<span class="comment">//                                                                              **</span>
<span class="comment">// Redistribution and use in source and binary forms, with or without           **</span>
<span class="comment">// modification, are permitted provided that the following conditions are met:  **</span>
<span class="comment">//   * Redistributions of source code must retain the above copyright notice,   **</span>
<span class="comment">//     this list of conditions and the following disclaimer.                    **</span>
<span class="comment">//   * Redistributions in binary form must reproduce the above copyright        **</span>
<span class="comment">//     notice, this list of conditions and the following disclaimer in the      **</span>
<span class="comment">//     documentation and/or other materials provided with the distribution.     **</span>
<span class="comment">//   * Neither the name of Intel Corporation nor the names of its contributors  **</span>
<span class="comment">//     may be used to endorse or promote products derived from this software    **</span>
<span class="comment">//     without specific prior written permission.                               **</span>
<span class="comment">//                                                                              **</span>
<span class="comment">// This software is provided by the copyright holders and contributors &quot;as is&quot;  **</span>
<span class="comment">// and any express or implied warranties, including, but not limited to, the    **</span>
<span class="comment">// implied warranties of merchantability and fitness for a particular purpose   **</span>
<span class="comment">// are disclaimed. In no event shall the copyright owner or contributors be     **</span>
<span class="comment">// liable for any direct, indirect, incidental, special, exemplary, or          **</span>
<span class="comment">// consequential damages (including, but not limited to, procurement of         **</span>
<span class="comment">// substitute goods or services; loss of use, data, or profits; or business     **</span>
<span class="comment">// interruption) however caused and on any theory of liability, whether in      **</span>
<span class="comment">// contract, strict liability, or tort (including negligence or otherwise)      **</span>
<span class="comment">// arising in any way out of the use of this software, even if advised of       **</span>
<span class="comment">// the possibility of such damage.                                              **</span>
<span class="comment">//********************************************************************************</span>
<span class="preprocessor">#ifndef blackscholes_H_ALREADY_INCLUDED</span>
<span class="preprocessor"></span><span class="preprocessor">#define blackscholes_H_ALREADY_INCLUDED</span>
<span class="preprocessor"></span>
<span class="preprocessor">#ifdef _DIST_</span>
<span class="preprocessor"></span><span class="preprocessor"># include &lt;cnc/dist_cnc.h&gt;</span>
<span class="preprocessor">#else</span>
<span class="preprocessor"></span><span class="preprocessor"># include &lt;cnc/cnc.h&gt;</span>
<span class="preprocessor">#endif</span>
<span class="preprocessor"></span><span class="preprocessor">#include &lt;cnc/debug.h&gt;</span>
<span class="preprocessor">#include &lt;vector&gt;</span>
<span class="preprocessor">#include &lt;memory&gt;</span>

<span class="keyword">typedef</span> std::shared_ptr&lt; std::vector&lt; OptionData &gt; &gt; option_vector_type;
<span class="keyword">typedef</span> std::shared_ptr&lt; std::vector&lt; fptype &gt; &gt; price_vector_type;

<a class="code" href="group__serialization.html#ga7315edf5ecbcdbc4c086d2ba9a262b3a">CNC_BITWISE_SERIALIZABLE</a>( OptionData );

<span class="comment">// Forward declaration of the context class (also known as graph)</span>
<span class="keyword">struct </span>blackscholes_context;

<span class="comment">// The step classes</span>
<span class="keyword">struct </span>Compute
{
    <span class="keywordtype">int</span> execute( <span class="keyword">const</span> <span class="keywordtype">int</span> &amp;, blackscholes_context &amp; ) <span class="keyword">const</span>;
};

<span class="keyword">struct </span>bs_tuner : <span class="keyword">public</span> CnC::step_tuner&lt;&gt;, <span class="keyword">public</span> CnC::vector_tuner
{
    <span class="keywordtype">int</span> compute_on( <span class="keyword">const</span> <span class="keywordtype">int</span> tag )<span class="keyword"> const </span>{
        <span class="keywordflow">return</span> tag % numProcs();
    }
    <span class="keywordtype">int</span> compute_on( <span class="keyword">const</span> <span class="keywordtype">int</span> tag, blackscholes_context &amp; )<span class="keyword"> const </span>{
        <span class="keywordflow">return</span> compute_on( tag );
    }
    <span class="keywordtype">int</span> consumed_by( <span class="keyword">const</span> <span class="keywordtype">int</span> tag )<span class="keyword"> const </span>{
        <span class="keywordflow">return</span> tag;
    }
    <span class="keywordtype">int</span> consumed_on( <span class="keyword">const</span> <span class="keywordtype">int</span> tag )<span class="keyword"> const </span>{
        <span class="keywordflow">return</span> compute_on( consumed_by( tag ) );
    }
    <span class="keywordtype">int</span> getcount( <span class="keyword">const</span> <span class="keywordtype">int</span> tag ) {
        <span class="keywordflow">return</span> 1;
    }
};

<span class="comment">// The context class</span>
<span class="keyword">struct </span>blackscholes_context : <span class="keyword">public</span> CnC::context&lt; blackscholes_context &gt;
{
    <span class="comment">// Step collections</span>
    <a class="code" href="class_cn_c_1_1step__collection.html" title="A step collection is logical set of step instances.">CnC::step_collection&lt; Compute, bs_tuner &gt;</a> compute;

    <span class="comment">// Item collections</span>
    <a class="code" href="class_cn_c_1_1item__collection.html" title="An item collection is a mapping from tags to items.">CnC::item_collection&lt; int, option_vector_type, bs_tuner &gt;</a> opt_data;
    <a class="code" href="class_cn_c_1_1item__collection.html" title="An item collection is a mapping from tags to items.">CnC::item_collection&lt; int, price_vector_type, bs_tuner &gt;</a>  prices;

    <span class="comment">// Tag collections</span>
    <a class="code" href="class_cn_c_1_1tag__collection.html" title="A tag collection is a set of tags of the same type. It is used to prescribe steps. By default, tags are not stored.">CnC::tag_collection&lt; int &gt;</a> tags;

    <span class="keywordtype">int</span> m_vs;
    <span class="comment">// The context class constructor</span>
    blackscholes_context( <span class="keywordtype">int</span> vs = 0)
        : CnC::context&lt; blackscholes_context &gt;(),
      <span class="comment">// Initialize each step collection</span>
          compute( *this ),
          <span class="comment">// Initialize each item collection</span>
          opt_data( *this ),
          prices( *this ),
          <span class="comment">// Initialize each tag collection</span>
          tags( *this ),
          m_vs( vs )
    {
        <span class="comment">// Prescriptive relations</span>
        tags.prescribes( compute, *<span class="keyword">this</span> );
        compute.produces( prices );
        opt_data.set_max( m_vs );
        prices.set_max( m_vs );
    }
<span class="preprocessor">#ifdef _DIST_</span>
<span class="preprocessor"></span>    <span class="keywordtype">void</span> serialize( <a class="code" href="class_cn_c_1_1serializer.html" title="Handles serilialization of data-objects.">CnC::serializer</a> &amp; ser )
    {
        ser &amp; m_vs;
        <span class="keywordflow">if</span>( ser.is_unpacking() ) {
            opt_data.set_max( m_vs );
            prices.set_max( m_vs );
        }
            
    }
<span class="preprocessor">#endif</span>
<span class="preprocessor"></span>};

<span class="preprocessor">#endif // blackscholes_H_ALREADY_INCLUDED</span>
</pre></div> <h2><a class="anchor" id="cholesky_tuner"></a>
samples/cholesky/cholesky/cholesky.h</h2>
<div class="fragment"><pre class="fragment"><span class="comment">//********************************************************************************</span>
<span class="comment">// Copyright (c) 2007-2014 Intel Corporation. All rights reserved.              **</span>
<span class="comment">//                                                                              **</span>
<span class="comment">// Redistribution and use in source and binary forms, with or without           **</span>
<span class="comment">// modification, are permitted provided that the following conditions are met:  **</span>
<span class="comment">//   * Redistributions of source code must retain the above copyright notice,   **</span>
<span class="comment">//     this list of conditions and the following disclaimer.                    **</span>
<span class="comment">//   * Redistributions in binary form must reproduce the above copyright        **</span>
<span class="comment">//     notice, this list of conditions and the following disclaimer in the      **</span>
<span class="comment">//     documentation and/or other materials provided with the distribution.     **</span>
<span class="comment">//   * Neither the name of Intel Corporation nor the names of its contributors  **</span>
<span class="comment">//     may be used to endorse or promote products derived from this software    **</span>
<span class="comment">//     without specific prior written permission.                               **</span>
<span class="comment">//                                                                              **</span>
<span class="comment">// This software is provided by the copyright holders and contributors &quot;as is&quot;  **</span>
<span class="comment">// and any express or implied warranties, including, but not limited to, the    **</span>
<span class="comment">// implied warranties of merchantability and fitness for a particular purpose   **</span>
<span class="comment">// are disclaimed. In no event shall the copyright owner or contributors be     **</span>
<span class="comment">// liable for any direct, indirect, incidental, special, exemplary, or          **</span>
<span class="comment">// consequential damages (including, but not limited to, procurement of         **</span>
<span class="comment">// substitute goods or services; loss of use, data, or profits; or business     **</span>
<span class="comment">// interruption) however caused and on any theory of liability, whether in      **</span>
<span class="comment">// contract, strict liability, or tort (including negligence or otherwise)      **</span>
<span class="comment">// arising in any way out of the use of this software, even if advised of       **</span>
<span class="comment">// the possibility of such damage.                                              **</span>
<span class="comment">//********************************************************************************</span>
<span class="preprocessor">#ifndef cholesky_H_ALREADY_INCLUDED</span>
<span class="preprocessor"></span><span class="preprocessor">#define cholesky_H_ALREADY_INCLUDED</span>
<span class="preprocessor"></span>
<span class="preprocessor">#ifdef _DIST_</span>
<span class="preprocessor"></span><span class="preprocessor"># include &lt;cnc/dist_cnc.h&gt;</span>
<span class="preprocessor">#else</span>
<span class="preprocessor"></span><span class="preprocessor"># include &lt;cnc/cnc.h&gt;</span>
<span class="preprocessor">#endif</span>
<span class="preprocessor"></span><span class="preprocessor">#include &lt;cnc/debug.h&gt;</span>
<span class="preprocessor">#include &lt;memory&gt;</span>

<span class="comment">// Forward declaration of the context class (also known as graph)</span>
<span class="keyword">struct </span>cholesky_context;

<span class="comment">// The step classes</span>

<span class="keyword">struct </span>S1_compute
{
    <span class="keywordtype">int</span> execute( <span class="keyword">const</span> <span class="keywordtype">int</span> &amp; t, cholesky_context &amp; c ) <span class="keyword">const</span>;
};

<span class="keyword">struct </span>S2_compute
{
    <span class="keywordtype">int</span> execute( <span class="keyword">const</span> pair &amp; t, cholesky_context &amp; c ) <span class="keyword">const</span>;
};

<span class="keyword">struct </span>S3_compute
{
    <span class="keywordtype">int</span> execute( <span class="keyword">const</span> triple &amp; t, cholesky_context &amp; c ) <span class="keyword">const</span>;
};
<span class="comment"></span>
<span class="comment">///////////////</span>
<span class="comment"></span>
<span class="keyword">static</span> <span class="keywordtype">void</span> mark( <span class="keywordtype">int</span> p, <span class="keywordtype">bool</span> * d )
{
    <span class="keywordflow">if</span>( d[p] == <span class="keyword">false</span> ) {
        d[p] = <span class="keyword">true</span>;
    }
}

<span class="keyword">struct </span>cholesky_tuner : <span class="keyword">public</span> CnC::step_tuner&lt;&gt;, <span class="keyword">public</span> CnC::hashmap_tuner
{
    cholesky_tuner( cholesky_context &amp; c, <span class="keywordtype">int</span> p = 0, <span class="keywordtype">int</span> n = 0, dist_type dt = BLOCKED_ROWS )
        : m_context( c ), m_p( p ), m_n( n ),
          m_div( (((p*p) / 2) + 1) / numProcs() ),
          <span class="comment">//          m_div( p ? (((p*(p+1))/2)+((2*numProcs())/2))/(2*numProcs()) : 0 ),</span>
          m_dt( dt )
    {
        <span class="keywordflow">if</span>( myPid() == 0 ) {
            <span class="keywordflow">switch</span>( dt ) {
            <span class="keywordflow">default</span>:
            <span class="keywordflow">case</span> BLOCKED_ROWS :
                std::cerr &lt;&lt; <span class="stringliteral">&quot;Distributing BLOCKED_ROWS\n&quot;</span>;
                <span class="keywordflow">break</span>;
            <span class="keywordflow">case</span> ROW_CYCLIC :
                std::cerr &lt;&lt; <span class="stringliteral">&quot;Distributing ROW_CYCLIC\n&quot;</span>;
                <span class="keywordflow">break</span>;
            <span class="keywordflow">case</span> COLUMN_CYCLIC :
                std::cerr &lt;&lt; <span class="stringliteral">&quot;Distributing COLUMN_CYCLIC\n&quot;</span>;
                <span class="keywordflow">break</span>;
            <span class="keywordflow">case</span> BLOCKED_CYCLIC :
                std::cerr &lt;&lt; <span class="stringliteral">&quot;Distributing BLOCKED_CYCLICS\n&quot;</span>;
                <span class="keywordflow">break</span>;
            }
        }
    }

    <span class="keyword">inline</span> <span class="keyword">static</span> <span class="keywordtype">int</span> compute_on( <span class="keyword">const</span> dist_type dt, <span class="keyword">const</span> <span class="keywordtype">int</span> i, <span class="keyword">const</span> <span class="keywordtype">int</span> j, <span class="keyword">const</span> <span class="keywordtype">int</span> n, <span class="keyword">const</span> <span class="keywordtype">int</span> s )
    {
        <span class="keywordflow">switch</span>( dt ) {
        <span class="keywordflow">default</span>:
        <span class="keywordflow">case</span> BLOCKED_ROWS :
            <span class="keywordflow">return</span> ( ((j*j)/2 + 1 + i ) / s ) % numProcs();
            <span class="keywordflow">break</span>;
        <span class="keywordflow">case</span> ROW_CYCLIC :
            <span class="keywordflow">return</span> j % numProcs();
            <span class="keywordflow">break</span>;
        <span class="keywordflow">case</span> COLUMN_CYCLIC :
            <span class="keywordflow">return</span> i % numProcs();
            <span class="keywordflow">break</span>;
        <span class="keywordflow">case</span> BLOCKED_CYCLIC :
            <span class="keywordflow">return</span> ( (i/2) * n + (j/2) ) % numProcs();
            <span class="keywordflow">break</span>;
        }
    }

    <span class="comment">// step-bits</span>
    <span class="keywordtype">int</span> compute_on( <span class="keyword">const</span> <span class="keywordtype">int</span> tag, cholesky_context &amp; <span class="comment">/*arg*/</span> )<span class="keyword"> const</span>
<span class="keyword">    </span>{
        <span class="keywordflow">return</span> compute_on( m_dt, tag, tag, m_n, m_div );
    }
    
    <span class="keywordtype">int</span> compute_on( <span class="keyword">const</span> pair &amp; tag, cholesky_context &amp; <span class="comment">/*arg*/</span> )<span class="keyword"> const</span>
<span class="keyword">    </span>{
        <span class="keywordflow">return</span> compute_on( m_dt, tag.first, tag.second, m_p, m_div );
    }
    
    <span class="keywordtype">int</span> compute_on( <span class="keyword">const</span> triple &amp; tag, cholesky_context &amp; <span class="comment">/*arg*/</span> )<span class="keyword"> const</span>
<span class="keyword">    </span>{
        <span class="keywordflow">return</span> compute_on( m_dt, tag[2], tag[1], m_p, m_div );
    }
    
    <span class="comment">// item-bits</span>
    <span class="keyword">typedef</span> triple tag_type;

    <span class="keywordtype">int</span> get_count( <span class="keyword">const</span> tag_type &amp; tag )<span class="keyword"> const</span>
<span class="keyword">    </span>{
        <span class="keywordtype">int</span> _k = tag[0], _i = tag[2];
        <span class="keywordflow">if</span>( _k == _i+1 ) <span class="keywordflow">return</span> <a class="code" href="namespace_cn_c.html#a06fc87d81c62e9abb8790b6e5713c55ba2e499248088579f87f684676c9ebac27" title="no get-count specified">CnC::NO_GETCOUNT</a>; <span class="comment">// that&#39;s our result</span>
        <span class="keywordflow">return</span> ( _k &gt; 0 &amp;&amp; _k &gt; _i ) ? ( m_p - _k ) : 1;
    }

    <span class="comment">// First we determine which *steps* are going to consume this item.</span>
    <span class="comment">// Then we use compute_on to determine the *processes* to which the item needs to go.</span>
    <span class="comment">// Mostly the two steps are formulated in one line.</span>
    <span class="comment">// We avoid duplicate entries by using a helper mechanism &quot;mark&quot;</span>
    std::vector&lt; int &gt; consumed_on( <span class="keyword">const</span> tag_type &amp; tag  )<span class="keyword"> const</span>
<span class="keyword">    </span>{
        <span class="keywordtype">int</span> _k = tag[0], _j = tag[1], _i = tag[2];

        <span class="keywordflow">if</span>( _i == _j ) { <span class="comment">// on diagonal</span>
            <span class="keywordflow">if</span>( _i == _k ) <span class="keywordflow">return</span> std::vector&lt; int &gt;( 1, compute_on( _k, m_context ) ); <span class="comment">// S1 only</span>
            <span class="keywordflow">if</span>( _k == m_p ) <span class="keywordflow">return</span> std::vector&lt; int &gt;( 1, 0 ); <span class="comment">// the end</span>
        }
        <span class="keywordflow">if</span>( _i == _k ) <span class="keywordflow">return</span> std::vector&lt; int &gt;( 1, compute_on( pair( _k, _j ), m_context ) ); <span class="comment">// S2 only</span>

        <span class="keywordtype">bool</span> * _d;
        _d = <span class="keyword">new</span> <span class="keywordtype">bool</span>[numProcs()];
        memset( _d, 0, numProcs() * <span class="keyword">sizeof</span>( *_d ) );

        <span class="keywordflow">if</span>( _i == _k-1 ) {
            <span class="keywordflow">if</span>( _i == _j ) { <span class="comment">// on diagonal on S2</span>
                <span class="keywordflow">for</span>( <span class="keywordtype">int</span> j = _k; j &lt; m_p; ++j ) {
                    mark( compute_on( pair( _k - 1, j ), m_context ), _d );
                }
            } <span class="keywordflow">else</span> { <span class="comment">// S3</span>
                <span class="keywordflow">for</span>( <span class="keywordtype">int</span> j = _j; j &lt; m_p; ++j ) {
                    <span class="keywordflow">for</span>( <span class="keywordtype">int</span> i = _k; i &lt;= _j; ++i ) {
                        mark( compute_on( triple( _k-1, j, i ), m_context ), _d );
                    }
                }
            }
        }
        mark( compute_on( triple( _k, _j, _i ), m_context ), _d );
        std::vector&lt; int &gt; _v;
        _v.reserve( numProcs()/2 );
        <span class="keywordflow">if</span>( _d[myPid()] ) _v.push_back( myPid() );
        <span class="keywordflow">for</span>( <span class="keywordtype">int</span> i = 0; i &lt; numProcs(); ++i ) {
            <span class="keywordflow">if</span>( _d[i] &amp;&amp; i != myPid() ) _v.push_back( i );
        }
        <span class="keyword">delete</span> [] _d;
        <span class="keywordflow">return</span> _v;
    }

<span class="preprocessor">#ifdef _DIST_</span>
<span class="preprocessor"></span>    <span class="keywordtype">void</span> serialize( <a class="code" href="class_cn_c_1_1serializer.html" title="Handles serilialization of data-objects.">CnC::serializer</a> &amp; ser )
    {
        ser &amp; m_p &amp; m_div &amp; m_n &amp; m_dt;
    }
<span class="preprocessor">#endif</span>
<span class="preprocessor"></span><span class="keyword">private</span>:
    cholesky_context &amp; m_context;
    <span class="keywordtype">int</span> m_p;
    <span class="keywordtype">int</span> m_n;
    <span class="keywordtype">int</span> m_div;
    dist_type m_dt;
};

<span class="comment">// The context class</span>
<span class="keyword">struct </span>cholesky_context : <span class="keyword">public</span> CnC::context&lt; cholesky_context &gt;
{
    <span class="comment">// tuners</span>
    cholesky_tuner tuner;

    <span class="comment">// Step Collections</span>
    <a class="code" href="class_cn_c_1_1step__collection.html" title="A step collection is logical set of step instances.">CnC::step_collection&lt; S1_compute, cholesky_tuner &gt;</a> sc_s1_compute;
    <a class="code" href="class_cn_c_1_1step__collection.html" title="A step collection is logical set of step instances.">CnC::step_collection&lt; S2_compute, cholesky_tuner &gt;</a> sc_s2_compute;
    <a class="code" href="class_cn_c_1_1step__collection.html" title="A step collection is logical set of step instances.">CnC::step_collection&lt; S3_compute, cholesky_tuner &gt;</a> sc_s3_compute;

    <span class="comment">// Item collections</span>
    <a class="code" href="class_cn_c_1_1item__collection.html" title="An item collection is a mapping from tags to items.">CnC::item_collection&lt; triple, tile_const_ptr_type, cholesky_tuner &gt;</a> Lkji;
    <span class="keywordtype">int</span> p,b;

    <span class="comment">// Tag collections</span>
    <a class="code" href="class_cn_c_1_1tag__collection.html" title="A tag collection is a set of tags of the same type. It is used to prescribe steps. By default, tags are not stored.">CnC::tag_collection&lt; int &gt;</a> control_S1;
    <a class="code" href="class_cn_c_1_1tag__collection.html" title="A tag collection is a set of tags of the same type. It is used to prescribe steps. By default, tags are not stored.">CnC::tag_collection&lt; pair &gt;</a> control_S2;
    <a class="code" href="class_cn_c_1_1tag__collection.html" title="A tag collection is a set of tags of the same type. It is used to prescribe steps. By default, tags are not stored.">CnC::tag_collection&lt; triple &gt;</a> control_S3;

    <span class="comment">// The context class constructor</span>
    cholesky_context( <span class="keywordtype">int</span> _b = 0, <span class="keywordtype">int</span> _p = 0, <span class="keywordtype">int</span> _n = 0, dist_type dt = BLOCKED_ROWS )
        : CnC::context&lt; cholesky_context &gt;(),
          <span class="comment">// init tuners</span>
          tuner( *this, _p, _n, dt ),
          <span class="comment">// init step colls</span>
          sc_s1_compute( *this, tuner, <span class="stringliteral">&quot;Cholesky&quot;</span> ),
          sc_s2_compute( *this, tuner, <span class="stringliteral">&quot;Trisolve&quot;</span> ),
          sc_s3_compute( *this, tuner, <span class="stringliteral">&quot;Update&quot;</span> ),
          <span class="comment">// Initialize each item collection</span>
          Lkji( *this, <span class="stringliteral">&quot;Lkji&quot;</span>, tuner ),
          p( _p ),
          b( _b ),
          <span class="comment">// Initialize each tag collection</span>
          control_S1( *this, <span class="stringliteral">&quot;S1&quot;</span> ),
          control_S2( *this, <span class="stringliteral">&quot;S2&quot;</span> ),
          control_S3( *this, <span class="stringliteral">&quot;S3&quot;</span> )
    {
        <span class="comment">// Prescriptive relations</span>
        control_S1.prescribes( sc_s1_compute, *<span class="keyword">this</span> );
        control_S2.prescribes( sc_s2_compute, *<span class="keyword">this</span> );
        control_S3.prescribes( sc_s3_compute, *<span class="keyword">this</span> );

        <span class="comment">// producer/consumer relations</span>
        sc_s1_compute.consumes( Lkji );
        sc_s1_compute.produces( Lkji );
        sc_s2_compute.consumes( Lkji );
        sc_s2_compute.produces( Lkji );
        sc_s3_compute.consumes( Lkji );
        sc_s3_compute.produces( Lkji );
<span class="preprocessor">#if 0</span>
<span class="preprocessor"></span>        <a class="code" href="struct_cn_c_1_1debug.html#a368be1460b4b38200c2138118584c78f" title="enable tracing of everything in given context (off=0)">CnC::debug::trace_all</a>( *<span class="keyword">this</span> );
<span class="preprocessor">#endif</span>
<span class="preprocessor"></span>    }

<span class="preprocessor">#ifdef _DIST_</span>
<span class="preprocessor"></span>    <span class="keywordtype">void</span> serialize( <a class="code" href="class_cn_c_1_1serializer.html" title="Handles serilialization of data-objects.">CnC::serializer</a> &amp; ser )
    {
        ser &amp; p &amp; b &amp; tuner;
    }
<span class="preprocessor">#endif</span>
<span class="preprocessor"></span>};

<span class="preprocessor">#endif // cholesky_H_ALREADY_INCLUDED</span>
</pre></div> <h2><a class="anchor" id="count_words_code"></a>
samples/count_words/count_words/count_words.cpp</h2>
<div class="fragment"><pre class="fragment"><span class="comment">//********************************************************************************</span>
<span class="comment">// Copyright (c) 2007-2014 Intel Corporation. All rights reserved.              **</span>
<span class="comment">//                                                                              **</span>
<span class="comment">// Redistribution and use in source and binary forms, with or without           **</span>
<span class="comment">// modification, are permitted provided that the following conditions are met:  **</span>
<span class="comment">//   * Redistributions of source code must retain the above copyright notice,   **</span>
<span class="comment">//     this list of conditions and the following disclaimer.                    **</span>
<span class="comment">//   * Redistributions in binary form must reproduce the above copyright        **</span>
<span class="comment">//     notice, this list of conditions and the following disclaimer in the      **</span>
<span class="comment">//     documentation and/or other materials provided with the distribution.     **</span>
<span class="comment">//   * Neither the name of Intel Corporation nor the names of its contributors  **</span>
<span class="comment">//     may be used to endorse or promote products derived from this software    **</span>
<span class="comment">//     without specific prior written permission.                               **</span>
<span class="comment">//                                                                              **</span>
<span class="comment">// This software is provided by the copyright holders and contributors &quot;as is&quot;  **</span>
<span class="comment">// and any express or implied warranties, including, but not limited to, the    **</span>
<span class="comment">// implied warranties of merchantability and fitness for a particular purpose   **</span>
<span class="comment">// are disclaimed. In no event shall the copyright owner or contributors be     **</span>
<span class="comment">// liable for any direct, indirect, incidental, special, exemplary, or          **</span>
<span class="comment">// consequential damages (including, but not limited to, procurement of         **</span>
<span class="comment">// substitute goods or services; loss of use, data, or profits; or business     **</span>
<span class="comment">// interruption) however caused and on any theory of liability, whether in      **</span>
<span class="comment">// contract, strict liability, or tort (including negligence or otherwise)      **</span>
<span class="comment">// arising in any way out of the use of this software, even if advised of       **</span>
<span class="comment">// the possibility of such damage.                                              **</span>
<span class="comment">//********************************************************************************</span>

<span class="preprocessor">#ifdef _DIST_</span>
<span class="preprocessor"></span><span class="preprocessor"># include &lt;cnc/dist_cnc.h&gt;</span>
<span class="preprocessor">#else</span>
<span class="preprocessor"></span><span class="preprocessor"># include &lt;cnc/cnc.h&gt;</span>
<span class="preprocessor">#endif</span>
<span class="preprocessor"></span><span class="preprocessor">#include &lt;cnc/debug.h&gt;</span>
<span class="preprocessor">#include &lt;cnc/reduce.h&gt;</span>
<span class="preprocessor">#include &lt;cassert&gt;</span>
<span class="preprocessor">#include &lt;string&gt;</span>
<span class="preprocessor">#include &lt;sstream&gt;</span>
<span class="preprocessor">#include &lt;fstream&gt;</span>

<span class="comment">// Count the number of occurances of given strings in a file.  An</span>
<span class="comment">// example of using a pre-defined CnC::graph, e.g. a reduction.</span>
<span class="comment">//</span>
<span class="comment">// The file is read line by line (on the host).  A computation unit is</span>
<span class="comment">// tagged by the pair (line-id/block, search-string).  Such a</span>
<span class="comment">// computation gets the line/block to search in.  It looks for the</span>
<span class="comment">// string and puts the number of matches into a collection. The</span>
<span class="comment">// collection is part of a reduction.</span>
<span class="comment">//</span>
<span class="comment">// The input to the reduction is counts_per_block with the matched</span>
<span class="comment">// string as key/above pair as its tag. The selector (a lambda!) maps</span>
<span class="comment">// the input-pair to the string that is matched. The reduction also</span>
<span class="comment">// takes &quot;counts&quot; which provides the number of participating elements</span>
<span class="comment">// per reduction (for each string one reduction!).  The reduction&#39;s</span>
<span class="comment">// output is the overall count per string.</span>
<span class="comment">//</span>
<span class="comment">// This is not optimized in any way. To make this fast, we need to</span>
<span class="comment">// adjust the block size and read in parallel. Additionally,</span>
<span class="comment">// std::strings are used in a very memory-unfriendly and</span>
<span class="comment">// copy-intensive manner.</span>
<span class="comment">//</span>
<span class="comment">// On distributed memory an intelligent distribution plan</span>
<span class="comment">// would probably be helpful.</span>

<span class="keyword">typedef</span> std::pair&lt; int, std::string &gt; tag_type;

<span class="keyword">struct </span>cw_context;

<span class="keyword">struct </span>counter
{
    <span class="keywordtype">int</span> execute( <span class="keyword">const</span> tag_type &amp; t, cw_context &amp; ctxt ) <span class="keyword">const</span>;
};

<span class="keyword">struct </span>cw_context : <span class="keyword">public</span> CnC::context&lt; cw_context &gt;
{
    <span class="comment">// the prescribing tags</span>
    <a class="code" href="class_cn_c_1_1tag__collection.html" title="A tag collection is a set of tags of the same type. It is used to prescribe steps. By default, tags are not stored.">CnC::tag_collection&lt; tag_type &gt;</a> tags;
    <span class="comment">// holds the lines/blocks of the file(s)</span>
    <a class="code" href="class_cn_c_1_1item__collection.html" title="An item collection is a mapping from tags to items.">CnC::item_collection&lt; int, std::string &gt;</a> blocks;
    <span class="comment">// for each pair(block,string) we put the number of occurances of string found in block</span>
    <a class="code" href="class_cn_c_1_1item__collection.html" title="An item collection is a mapping from tags to items.">CnC::item_collection&lt; tag_type, size_type &gt;</a> counts_per_block;
    <span class="comment">// the final number of occurances per string</span>
    <a class="code" href="class_cn_c_1_1item__collection.html" title="An item collection is a mapping from tags to items.">CnC::item_collection&lt; std::string, size_type &gt;</a> counts;
    <span class="comment">// the number of items (e.g. counts per string) participating in a reduction</span>
    <a class="code" href="class_cn_c_1_1item__collection.html" title="An item collection is a mapping from tags to items.">CnC::item_collection&lt; std::string, size_type &gt;</a> red_counts;
    <a class="code" href="class_cn_c_1_1step__collection.html" title="A step collection is logical set of step instances.">CnC::step_collection&lt; counter &gt;</a> steps;
    <span class="comment">// our reduction is provided as a graph, see constructor for its instantiation&amp;wiring</span>
    <a class="code" href="class_cn_c_1_1graph.html" title="Base class for defining and using CnC (sub-)graphs.">CnC::graph</a> * reduce;
    
    cw_context()
        : tags( *this, <span class="stringliteral">&quot;tags&quot;</span> ),
          blocks( *this, <span class="stringliteral">&quot;blocks&quot;</span> ),
          counts_per_block( *this, <span class="stringliteral">&quot;counts_per_block&quot;</span> ),
          counts( *this, <span class="stringliteral">&quot;counts&quot;</span> ),
          red_counts( *this, <span class="stringliteral">&quot;red_counts&quot;</span> ),
          steps( *this, <span class="stringliteral">&quot;counter&quot;</span> ),
          reduce( NULL )
    {
        <span class="comment">// here we wire the graph/reduction</span>
        reduce = <a class="code" href="group__reductions.html#ga700ef577820e594bfc11868817766965">CnC::make_reduce_graph</a>( *<span class="keyword">this</span>,            <span class="comment">// context</span>
                                         <span class="stringliteral">&quot;reduce&quot;</span>,         <span class="comment">// name</span>
                                         counts_per_block, <span class="comment">// input collection</span>
                                         red_counts,       <span class="comment">// number of items per reduction</span>
                                         counts,           <span class="comment">// the final result for each reduction</span>
                                         std::plus&lt;size_type&gt;(), <span class="comment">// the reduction operation</span>
                                         size_type(0),     <span class="comment">// identity element</span>
                                         <span class="comment">// we use a lambda as the selector</span>
                                         <span class="comment">// it maps the item to the reduction identified by t.second (the string)</span>
                                         <span class="comment">// e.g. it reduces over all blocks</span>
                                         []( <span class="keyword">const</span> tag_type &amp; t, std::string &amp; _s )-&gt;<span class="keywordtype">bool</span>{_s=t.second;<span class="keywordflow">return</span> <span class="keyword">true</span>;} );
        tags.prescribes( steps, *<span class="keyword">this</span> );
        steps.consumes( blocks );
        steps.produces( counts_per_block );
        <span class="comment">//CnC::debug::trace( *reduce, 3 );</span>
    }
    
    ~cw_context()
    {
        <span class="keyword">delete</span> reduce;
    }
};

<span class="comment">// get block/line (tag.first) and determine number of occurances of string (tag.second)</span>
<span class="comment">// put result into counts_per_block</span>
<span class="keywordtype">int</span> counter::execute( <span class="keyword">const</span> tag_type &amp; t, cw_context &amp; ctxt )<span class="keyword"> const</span>
<span class="keyword"></span>{
    std::string _str;
    ctxt.blocks.get( t.first, _str );
    <span class="keyword">const</span> size_type _sz = _str.size();
    size_type _pos = -1;
    size_type _cnt = 0;
    <span class="keywordflow">while</span>( ( _pos = _str.find( t.second, _pos+1 ) ) &lt; _sz ) ++_cnt;
    <span class="comment">// always to results, even if 0</span>
    <span class="comment">// this allows us to determine the number of reduced items in main</span>
    ctxt.counts_per_block.put( t, _cnt );
    <span class="keywordflow">return</span> 0;
}

<span class="keywordtype">int</span> main( <span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> * argv[])
{
<span class="preprocessor">#ifdef _DIST_</span>
<span class="preprocessor"></span>    <a class="code" href="struct_cn_c_1_1dist__cnc__init.html">CnC::dist_cnc_init&lt; cw_context &gt;</a> _dc;
<span class="preprocessor">#endif</span>
<span class="preprocessor"></span>    
    <span class="keywordflow">if</span>( argc &lt; 3 ) {
        std::cerr &lt;&lt; <span class="stringliteral">&quot;expected arguments: &lt;file&gt; &lt;word1&gt; [&lt;word2&gt;...]\n&quot;</span>;
            exit(1);
    }
    <span class="comment">// create the context</span>
    cw_context ctxt;
    std::ifstream _file( argv[1] );
    std::string _block;
    <span class="keywordtype">int</span> _id = 0;
    <span class="comment">// read line line</span>
    <span class="keywordflow">while</span>( std::getline( _file, _block ) ) {
        ctxt.blocks.put( _id, _block );
        <span class="keywordtype">int</span> i = 1;
        <span class="comment">// for each line, put control for each searched string</span>
        <span class="keywordflow">while</span>( ++i &lt; argc ) {
            ctxt.tags.put( std::make_pair( _id, argv[i] ) );
        }
        ++_id;
    }

    <span class="comment">// reduction needs number of reduced items</span>
    <span class="comment">// as we always put a number in the step, we know its #blocks</span>
    <span class="comment">// _id holds #blocks</span>
    <span class="keywordtype">int</span> i = 1;
    <span class="keywordflow">while</span>( ++i &lt; argc ) ctxt.red_counts.put( argv[i], _id );

    ctxt.wait();

    std::cout &lt;&lt; <span class="stringliteral">&quot;done&quot;</span> &lt;&lt; std::endl;

    std::cout &lt;&lt; ctxt.counts.size() &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; ctxt.blocks.size() &lt;&lt; std::endl;
    <span class="comment">// iterate and write out all keys/value pairs</span>
    <span class="keywordflow">for</span>( <span class="keyword">auto</span> i = ctxt.counts.begin(); i != ctxt.counts.end(); ++i ) {
        std::cout &lt;&lt; i-&gt;first &lt;&lt; <span class="stringliteral">&quot; \t &quot;</span> &lt;&lt; *i-&gt;second &lt;&lt; std::endl;
    }
    ctxt.wait();
    std::cout &lt;&lt; ctxt.counts.size() &lt;&lt; <span class="stringliteral">&quot; &quot;</span> &lt;&lt; ctxt.blocks.size() &lt;&lt; std::endl;

    <span class="keywordflow">return</span> 0;
}
</pre></div> <h2><a class="anchor" id="count_all_words_code"></a>
samples/count_all_words/count_all_words/count_all_words.cpp</h2>
<div class="fragment"><pre class="fragment"><span class="comment">//********************************************************************************</span>
<span class="comment">// Copyright (c) 2007-2014 Intel Corporation. All rights reserved.              **</span>
<span class="comment">//                                                                              **</span>
<span class="comment">// Redistribution and use in source and binary forms, with or without           **</span>
<span class="comment">// modification, are permitted provided that the following conditions are met:  **</span>
<span class="comment">//   * Redistributions of source code must retain the above copyright notice,   **</span>
<span class="comment">//     this list of conditions and the following disclaimer.                    **</span>
<span class="comment">//   * Redistributions in binary form must reproduce the above copyright        **</span>
<span class="comment">//     notice, this list of conditions and the following disclaimer in the      **</span>
<span class="comment">//     documentation and/or other materials provided with the distribution.     **</span>
<span class="comment">//   * Neither the name of Intel Corporation nor the names of its contributors  **</span>
<span class="comment">//     may be used to endorse or promote products derived from this software    **</span>
<span class="comment">//     without specific prior written permission.                               **</span>
<span class="comment">//                                                                              **</span>
<span class="comment">// This software is provided by the copyright holders and contributors &quot;as is&quot;  **</span>
<span class="comment">// and any express or implied warranties, including, but not limited to, the    **</span>
<span class="comment">// implied warranties of merchantability and fitness for a particular purpose   **</span>
<span class="comment">// are disclaimed. In no event shall the copyright owner or contributors be     **</span>
<span class="comment">// liable for any direct, indirect, incidental, special, exemplary, or          **</span>
<span class="comment">// consequential damages (including, but not limited to, procurement of         **</span>
<span class="comment">// substitute goods or services; loss of use, data, or profits; or business     **</span>
<span class="comment">// interruption) however caused and on any theory of liability, whether in      **</span>
<span class="comment">// contract, strict liability, or tort (including negligence or otherwise)      **</span>
<span class="comment">// arising in any way out of the use of this software, even if advised of       **</span>
<span class="comment">// the possibility of such damage.                                              **</span>
<span class="comment">//********************************************************************************</span>

<span class="preprocessor">#ifdef _DIST_</span>
<span class="preprocessor"></span><span class="preprocessor"># include &lt;cnc/dist_cnc.h&gt;</span>
<span class="preprocessor">#else</span>
<span class="preprocessor"></span><span class="preprocessor"># include &lt;cnc/cnc.h&gt;</span>
<span class="preprocessor">#endif</span>
<span class="preprocessor"></span><span class="preprocessor">#include &lt;cnc/debug.h&gt;</span>
<span class="preprocessor">#include &lt;cnc/reduce.h&gt;</span>
<span class="preprocessor">#include &lt;cassert&gt;</span>
<span class="preprocessor">#include &lt;string&gt;</span>
<span class="preprocessor">#include &lt;sstream&gt;</span>
<span class="preprocessor">#include &lt;algorithm&gt;</span>
<span class="preprocessor">#include &lt;fstream&gt;</span>

<span class="comment">// Count the number of occurances of all words in a file.  An example</span>
<span class="comment">// of using a pre-defined CnC::graph, e.g. a reduction.</span>
<span class="comment">//</span>
<span class="comment">// The file is read line by line (on the host).  A computation unit is</span>
<span class="comment">// tagged by the line-id/block.  Such a computation gets the</span>
<span class="comment">// line/block to search in.  It reads word by word and puts an item</span>
<span class="comment">// into an item-collection &quot;counts_per_block&quot;. To make the tag unique,</span>
<span class="comment">// its a triple (block/line, word#, word) [case-insensitive].  The</span>
<span class="comment">// data itself is just a dummy.  The collection is part of a reduction</span>
<span class="comment">// which will finally compute the number of occurances per word.</span>
<span class="comment">//</span>
<span class="comment">// The input to the reduction is counts_per_block. The selector (a</span>
<span class="comment">// lambda!) maps the input-triple to the word that is matched. The</span>
<span class="comment">// reduction also takes &quot;counts&quot;. As we don&#39;t know which words we will</span>
<span class="comment">// find and count, there is no way to know the number of participating</span>
<span class="comment">// items per reduction.  Instead we have to indicate when all lines</span>
<span class="comment">// have been processed.  After a first call to wait, we know no more</span>
<span class="comment">// computation is done, we then call reduction::flush to indicate that</span>
<span class="comment">// no more input arrives.  A second wait() makes sure that the</span>
<span class="comment">// reduction completes before we access the result.  The reduction&#39;s</span>
<span class="comment">// output is the overall count for ever word in the file.</span>
<span class="comment">//</span>
<span class="comment">// As an opimization, we assign a get-count of 0 to all words we put.</span>
<span class="comment">// In this example the words are used for nothing else than the</span>
<span class="comment">// reduction.  With a get-couhjnt of 0 the items will be passed to the</span>
<span class="comment">// reduction but never really stored.</span>
<span class="comment">//</span>
<span class="comment">// This is not optimized in any way. To make this fast, we need to</span>
<span class="comment">// adjust the block size and read in parallel. Additionally,</span>
<span class="comment">// std::strings are used in a very memory-unfriendly and</span>
<span class="comment">// copy-intensive manner.</span>
<span class="comment">//</span>
<span class="comment">// On distributed memory an intelligent distribution plan would</span>
<span class="comment">// probably be helpful.</span>

<span class="keyword">typedef</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span> <span class="keywordtype">int</span> id_type;
<span class="keyword">typedef</span> std::pair&lt; id_type, const std::string &gt; tag_type;

<span class="keyword">struct </span>cw_context;

<span class="keyword">struct </span>counter
{
    <span class="keywordtype">int</span> execute( <span class="keyword">const</span> <span class="keywordtype">int</span> &amp; t, cw_context &amp; ctxt ) <span class="keyword">const</span>;
};

<span class="keyword">struct </span>gc0_tuner : <span class="keyword">public</span> CnC::hashmap_tuner
{
    <span class="keyword">template</span>&lt; <span class="keyword">typename</span> Tag &gt;
    <span class="keywordtype">int</span> get_count( <span class="keyword">const</span> Tag &amp; )<span class="keyword"> const</span>
<span class="keyword">    </span>{
        <span class="keywordflow">return</span> 0;
    }
};

<span class="keyword">struct </span>cw_context : <span class="keyword">public</span> CnC::context&lt; cw_context &gt;
{
    <span class="comment">// prescribes our computation</span>
    <a class="code" href="class_cn_c_1_1tag__collection.html" title="A tag collection is a set of tags of the same type. It is used to prescribe steps. By default, tags are not stored.">CnC::tag_collection&lt; int &gt;</a> tags;
    <span class="comment">// one input line per item</span>
    <a class="code" href="class_cn_c_1_1item__collection.html" title="An item collection is a mapping from tags to items.">CnC::item_collection&lt; int, std::string &gt;</a> blocks;
    <span class="comment">// every word instance we find we put in here with a unique tag</span>
    <a class="code" href="class_cn_c_1_1item__collection.html" title="An item collection is a mapping from tags to items.">CnC::item_collection&lt; tag_type, size_type, gc0_tuner &gt;</a> counts_per_block;
    <span class="comment">// we don&#39;t really need this, we use flush</span>
    <a class="code" href="class_cn_c_1_1item__collection.html" title="An item collection is a mapping from tags to items.">CnC::item_collection&lt; std::string, int &gt;</a> cnt;
    <span class="comment">// the resulting count per word</span>
    <a class="code" href="class_cn_c_1_1item__collection.html" title="An item collection is a mapping from tags to items.">CnC::item_collection&lt; std::string, size_type &gt;</a> counts;
    <span class="comment">// extracing words</span>
    <a class="code" href="class_cn_c_1_1step__collection.html" title="A step collection is logical set of step instances.">CnC::step_collection&lt; counter &gt;</a> steps;
    <span class="comment">// the reduction sub-graph</span>
    <a class="code" href="class_cn_c_1_1graph.html" title="Base class for defining and using CnC (sub-)graphs.">CnC::graph</a> * reduce;
    
    cw_context()
        : tags( *this, <span class="stringliteral">&quot;tags&quot;</span> ),
          blocks( *this, <span class="stringliteral">&quot;blocks&quot;</span> ),
          counts_per_block( *this, <span class="stringliteral">&quot;counts_per_block&quot;</span> ),
          cnt( *this, <span class="stringliteral">&quot;cnt&quot;</span> ),
          counts( *this, <span class="stringliteral">&quot;counts&quot;</span> ),
          steps( *this, <span class="stringliteral">&quot;counter&quot;</span> ),
          reduce( NULL )
    {
        reduce = <a class="code" href="group__reductions.html#ga700ef577820e594bfc11868817766965">CnC::make_reduce_graph</a>( *<span class="keyword">this</span>, <span class="stringliteral">&quot;reduce&quot;</span>,
                                         counts_per_block, <span class="comment">//input collection</span>
                                         cnt,              <span class="comment">// counts per reduce, not used</span>
                                         counts,           <span class="comment">// result</span>
                                         std::plus&lt;size_type&gt;(), <span class="comment">// reduce operation</span>
                                         size_type(0),     <span class="comment">// identity element</span>
                                         <span class="comment">// we use a lambda as the selector</span>
                                         <span class="comment">// it maps the item to the reduction identified by t.second (the string)</span>
                                         <span class="comment">// e.g. it reduces over all blocks</span>
                                         []( <span class="keyword">const</span> tag_type &amp; t, std::string&amp; _s )-&gt;<span class="keywordtype">bool</span>{_s=t.second;<span class="keywordflow">return</span> <span class="keyword">true</span>;} );
        tags.prescribes( steps, *<span class="keyword">this</span> );
        steps.consumes( blocks );
        steps.produces( counts_per_block );
        <span class="comment">//        CnC::debug::trace_all( *this );</span>
        <span class="comment">//CnC::debug::trace( steps );</span>
        <span class="comment">//        CnC::debug::trace( *reduce, 2 );</span>
    }
    
    ~cw_context()
    {
        <span class="keyword">delete</span> reduce;
    }
};

<span class="comment">// get the line, read word by word and put each instance</span>
<span class="comment">// with unique tag into counts_per_block, which is the</span>
<span class="comment">// input collection of the reduction</span>
<span class="keywordtype">int</span> counter::execute( <span class="keyword">const</span> <span class="keywordtype">int</span> &amp; t, cw_context &amp; ctxt )<span class="keyword"> const</span>
<span class="keyword"></span>{
    std::string _str;
    ctxt.blocks.get( t, _str );
    std::istringstream iss( _str );
    std::string _word;
    id_type _id = (t &lt;&lt; 16);
    <span class="keywordflow">while</span>( iss &gt;&gt; _word ) {
        <span class="comment">// let&#39;s a do a case-insensitive matching</span>
        std::transform(_word.begin(), _word.end(), _word.begin(), ::tolower);
        ctxt.counts_per_block.put( tag_type(_id, _word), 1 );
        ++_id;
    }
    <span class="keywordflow">return</span> 0;
}

<span class="keywordtype">int</span> main( <span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> * argv[])
{
<span class="preprocessor">#ifdef _DIST_</span>
<span class="preprocessor"></span>    <a class="code" href="struct_cn_c_1_1dist__cnc__init.html">CnC::dist_cnc_init&lt; cw_context &gt;</a> _dc;
<span class="preprocessor">#endif</span>
<span class="preprocessor"></span>    
    <span class="keywordflow">if</span>( argc &lt; 2 ) {
        std::cerr &lt;&lt; <span class="stringliteral">&quot;expected arguments: &lt;file&gt;\n&quot;</span>;
            exit(1);
    }
    <span class="comment">// create the context</span>
    cw_context ctxt;
    std::ifstream _file( argv[1] );
    std::string _block;
    <span class="keywordtype">int</span> _id = 0;

    tbb::tick_count startTime = tbb::tick_count::now();
    
    <span class="comment">// read line line</span>
    <span class="keywordflow">while</span>( std::getline( _file, _block ) ) {
        <span class="comment">// put each line</span>
        ctxt.blocks.put( _id, _block );
        <span class="comment">// and control to start searching/matching</span>
        ctxt.tags.put( _id );
        ++_id;
    }
    <span class="comment">// A reduction needs number of reduced items.</span>
    <span class="comment">// We do not know the count in advance.</span>
    <span class="comment">// We do not even know which words are going to show up.</span>
    <span class="comment">// We have to wait until processing is done</span>
    <span class="comment">// and then tell the reduction it can do the final pass</span>
    ctxt.wait();
    ctxt.reduce-&gt;flush();
    ctxt.wait();

    tbb::tick_count endTime = tbb::tick_count::now();
    
    std::cout &lt;&lt; ctxt.counts.size() &lt;&lt; std::endl;
    <span class="comment">// iterate and write out all keys/value pairs with counts &gt; 999</span>
    <span class="keywordflow">for</span>( <span class="keyword">auto</span> i = ctxt.counts.begin(); i != ctxt.counts.end(); ++i ) {
        <span class="keywordflow">if</span>( *i-&gt;second &gt; 999 )
            std::cout &lt;&lt; i-&gt;first &lt;&lt; <span class="stringliteral">&quot; \t &quot;</span> &lt;&lt; *i-&gt;second &lt;&lt; std::endl;
    }

    std::cout &lt;&lt; <span class="stringliteral">&quot;Time: &quot;</span> &lt;&lt; (endTime-startTime).seconds() &lt;&lt; <span class="stringliteral">&quot;s.\n&quot;</span>;
    <span class="keywordflow">return</span> 0;
}
</pre></div> <h2><a class="anchor" id="mapreduce_code"></a>
samples/count_all_words/mapreduce/mapreduce.h</h2>
<div class="fragment"><pre class="fragment"><span class="comment">// *******************************************************************************</span>
<span class="comment">// Copyright (c) 2013-2014 Intel Corporation. All rights reserved.              **</span>
<span class="comment">//                                                                              **</span>
<span class="comment">// Redistribution and use in source and binary forms, with or without           **</span>
<span class="comment">// modification, are permitted provided that the following conditions are met:  **</span>
<span class="comment">//   * Redistributions of source code must retain the above copyright notice,   **</span>
<span class="comment">//     this list of conditions and the following disclaimer.                    **</span>
<span class="comment">//   * Redistributions in binary form must reproduce the above copyright        **</span>
<span class="comment">//     notice, this list of conditions and the following disclaimer in the      **</span>
<span class="comment">//     documentation and/or other materials provided with the distribution.     **</span>
<span class="comment">//   * Neither the name of Intel Corporation nor the names of its contributors  **</span>
<span class="comment">//     may be used to endorse or promote products derived from this software    **</span>
<span class="comment">//     without specific prior written permission.                               **</span>
<span class="comment">//                                                                              **</span>
<span class="comment">// This software is provided by the copyright holders and contributors &quot;as is&quot;  **</span>
<span class="comment">// and any express or implied warranties, including, but not limited to, the    **</span>
<span class="comment">// implied warranties of merchantability and fitness for a particular purpose   **</span>
<span class="comment">// are disclaimed. In no event shall the copyright owner or contributors be     **</span>
<span class="comment">// liable for any direct, indirect, incidental, special, exemplary, or          **</span>
<span class="comment">// consequential damages (including, but not limited to, procurement of         **</span>
<span class="comment">// substitute goods or services; loss of use, data, or profits; or business     **</span>
<span class="comment">// interruption) however caused and on any theory of liability, whether in      **</span>
<span class="comment">// contract, strict liability, or tort (including negligence or otherwise)      **</span>
<span class="comment">// arising in any way out of the use of this software, even if advised of       **</span>
<span class="comment">// the possibility of such damage.                                              **</span>
<span class="comment">// *******************************************************************************</span>

<span class="preprocessor">#ifdef _DIST_</span>
<span class="preprocessor"></span><span class="preprocessor"># include &lt;cnc/dist_cnc.h&gt;</span>
<span class="preprocessor">#else</span>
<span class="preprocessor"></span><span class="preprocessor"># include &lt;cnc/cnc.h&gt;</span>
<span class="preprocessor">#endif</span>
<span class="preprocessor"></span><span class="preprocessor">#include &lt;cnc/debug.h&gt;</span>
<span class="preprocessor">#include &lt;cnc/reduce.h&gt;</span>
<span class="preprocessor">#include &lt;cassert&gt;</span>
<span class="preprocessor">#include &lt;string&gt;</span>
<span class="preprocessor">#include &lt;sstream&gt;</span>
<span class="preprocessor">#include &lt;algorithm&gt;</span>
<span class="preprocessor">#include &lt;fstream&gt;</span>
<span class="preprocessor">#include &lt;cwctype&gt;</span>
<span class="comment"></span>
<span class="comment">/**</span>
<span class="comment">   Map-Reduce for CnC.</span>
<span class="comment">   </span>
<span class="comment">   The mapreduce_context provides a functionality similar to hadoop/mapreduce.</span>
<span class="comment">   At instantiation time it accepts the map- and reduce operations.</span>
<span class="comment">   Input data is accepted by putting files into its read_data collection.</span>
<span class="comment">   A call to wait() makes sure all mapreduce operations are done.</span>
<span class="comment">   Output data is stored in the &quot;results&quot; collection and can then be accessed</span>
<span class="comment">   through get-calls or iterators.</span>
<span class="comment"></span>
<span class="comment">   Like in common mapreduce frameworks the map operation works on streams - not</span>
<span class="comment">   on CnC entities. Also like in mapreduce frameworks the result of the map</span>
<span class="comment">   is stored in a collection (of course here we use a CnC item collection).</span>
<span class="comment"></span>
<span class="comment">   It supports an easy way to distribute computation on distributed memory.</span>
<span class="comment">   By appending&#39;:&lt;processid&gt;&#39; to the input filenames it will execute the corresponding</span>
<span class="comment">   map operation on the given process &#39;&lt;processid&gt;&#39;. The reduction part is </span>
<span class="comment">   automatically distributed.</span>
<span class="comment"></span>
<span class="comment">   Internally we use a step for reading files, a step for mapping and</span>
<span class="comment">   a reduction graph for the reduce part.</span>
<span class="comment"></span>
<span class="comment">   \todo write a driver for HPFS which provides the distribution information (appending&#39;:&lt;processid&gt;&#39;)</span>
<span class="comment">   \todo what about making better use of blocks (not entire files)?</span>
<span class="comment">   \todo what about making this a CnC::graph?</span>
<span class="comment">**/</span>
<span class="keyword">template</span>&lt; <span class="keyword">typename</span> MapOp, <span class="keyword">typename</span> ReduceOp &gt;
<span class="keyword">struct </span>mapreduce_context : <span class="keyword">public</span> CnC::context&lt; mapreduce_context&lt; MapOp, ReduceOp &gt; &gt;
{
    <span class="keyword">typedef</span> std::pair&lt; const std::string, long long int &gt; map_tag_type;
    <span class="keyword">typedef</span> <span class="keyword">typename</span> MapOp::result_type result_type;
    <span class="keyword">typedef</span> <span class="keyword">typename</span> MapOp::key_type key_type;
    <span class="keyword">typedef</span> std::string char_ptr_type;

    <span class="comment">// the step which executes the map operation</span>
    <span class="keyword">struct </span>mapper
    {
        <span class="keywordtype">int</span> execute( <span class="keyword">const</span> map_tag_type &amp; t, mapreduce_context&lt; MapOp, ReduceOp &gt; &amp; ctxt ) <span class="keyword">const</span>;
    };
    
    <span class="comment">// the step which reads individual files</span>
    <span class="keyword">struct </span>reader 
    {
        <span class="keywordtype">int</span> execute( <span class="keyword">const</span> std::string &amp; file, mapreduce_context&lt; MapOp, ReduceOp &gt; &amp; ctxt ) <span class="keyword">const</span>;
    };
    
    <span class="comment">// a generic tuner providing constant get-count</span>
    <span class="comment">// and executes locally (e.g. whereever the step gets prescribed)</span>
    <span class="keyword">template</span>&lt; <span class="keywordtype">int</span> GC &gt;
    <span class="keyword">struct </span>gc_tuner : <span class="keyword">public</span> CnC::hashmap_tuner
    {
        <span class="keyword">template</span>&lt; <span class="keyword">typename</span> Tag &gt;
        <span class="keywordtype">int</span> get_count( <span class="keyword">const</span> Tag &amp; )<span class="keyword"> const</span>
<span class="keyword">        </span>{
            <span class="keywordflow">return</span> GC;
        }
        <span class="keyword">template</span>&lt; <span class="keyword">typename</span> Tag &gt;
        <span class="keywordtype">int</span> consumed_on( <span class="keyword">const</span> Tag &amp; )<span class="keyword"> const</span>
<span class="keyword">        </span>{
            <span class="keywordflow">return</span> <a class="code" href="namespace_cn_c.html#a06fc87d81c62e9abb8790b6e5713c55ba43a7cdb0ac2922d3bfc5c28d1bc0c4d5" title="consumer process of given item is the local process">CnC::CONSUMER_LOCAL</a>;
        }
        <span class="keyword">template</span>&lt; <span class="keyword">typename</span> Tag &gt;
        <span class="keywordtype">int</span> produced_on( <span class="keyword">const</span> Tag &amp; )<span class="keyword"> const</span>
<span class="keyword">        </span>{
            <span class="keywordflow">return</span> <a class="code" href="namespace_cn_c.html#a06fc87d81c62e9abb8790b6e5713c55ba456fc1c1ea987d5ab7632ae5b76e2353" title="producer process of dependent item is local process">CnC::PRODUCER_LOCAL</a>;
        }
    };

    <span class="comment">// tuner for reading files, distributes file-reads</span>
    <span class="keyword">struct </span>read_tuner : <span class="keyword">public</span> CnC::step_tuner&lt; false &gt;
    {
        <span class="comment">// we analyze the input string and search for &#39;:&lt;pid&gt;&#39; prefix.</span>
        <span class="comment">// if found, the corresponding step will be executed on process &lt;pid&gt;.</span>
        <span class="comment">// Otherwise we distribute randomly.</span>
        <span class="keywordtype">int</span> compute_on( <span class="keyword">const</span> std::string &amp; file, mapreduce_context&lt; MapOp, ReduceOp &gt; &amp; )<span class="keyword"> const</span>
<span class="keyword">        </span>{
            <span class="keyword">auto</span> _col = file.rfind( <span class="charliteral">&#39;:&#39;</span> );
            <span class="keywordflow">if</span>( _col == std::string::npos ) {
                <a class="code" href="structcnc__hash_3_01std_1_1string_01_4.html" title="hash for std::string">cnc_hash&lt; std::string &gt;</a> _h;
                <span class="keywordtype">int</span> _x = _h( file ) % <a class="code" href="class_cn_c_1_1tuner__base.html#aef1047092ade8db731c56fbf2f708e76">CnC::tuner_base::numProcs</a>();
                <span class="keywordflow">return</span> _x;
            }
            <span class="comment">// manually convert to int (faster)</span>
            <span class="keyword">const</span> <span class="keywordtype">char</span> * _p = file.c_str() + _col + 1;
            <span class="keywordtype">int</span> _x = 0;
            <span class="keywordflow">while</span>( *_p &gt;= <span class="charliteral">&#39;0&#39;</span> &amp;&amp; *_p &lt;= <span class="charliteral">&#39;9&#39;</span> ) {
                _x = ( _x * 10 ) + ( *_p - <span class="charliteral">&#39;0&#39;</span> );
                ++_p;
            }
            <span class="keywordflow">return</span> _x % <a class="code" href="class_cn_c_1_1tuner__base.html#aef1047092ade8db731c56fbf2f708e76">CnC::tuner_base::numProcs</a>();
        }
    };

    <span class="comment">// the mapping stays local</span>
    <span class="keyword">struct </span>map_tuner : <span class="keyword">public</span> CnC::step_tuner&lt; false &gt;
    {
        <span class="keywordtype">int</span> compute_on( <span class="keyword">const</span> map_tag_type &amp;, mapreduce_context&lt; MapOp, ReduceOp &gt; &amp; )<span class="keyword"> const</span>
<span class="keyword">        </span>{
            <span class="keywordflow">return</span> <a class="code" href="namespace_cn_c.html#a06fc87d81c62e9abb8790b6e5713c55ba35fbeddaf90adeadc3ee9915ab152883" title="let tuner::compute_on return COMPUTE_ON_LOCAL if the step should be executed locally">CnC::COMPUTE_ON_LOCAL</a>;
        }
    };

    <span class="comment">// prescribes reading files</span>
    <a class="code" href="class_cn_c_1_1tag__collection.html" title="A tag collection is a set of tags of the same type. It is used to prescribe steps. By default, tags are not stored.">CnC::tag_collection&lt; std::string &gt;</a> read_tags = { *<span class="keyword">this</span>, <span class="stringliteral">&quot;read_tags&quot;</span> }; <span class="comment">// need recent g++ or icpc</span>
    <span class="comment">// prescribes our computation</span>
    <a class="code" href="class_cn_c_1_1tag__collection.html" title="A tag collection is a set of tags of the same type. It is used to prescribe steps. By default, tags are not stored.">CnC::tag_collection&lt; map_tag_type &gt;</a> map_tags = { *<span class="keyword">this</span>, <span class="stringliteral">&quot;map_tags&quot;</span> }; <span class="comment">// need recent g++ or icpc</span>
    <span class="comment">// one input line per item</span>
    <a class="code" href="class_cn_c_1_1item__collection.html" title="An item collection is a mapping from tags to items.">CnC::item_collection&lt; map_tag_type, char_ptr_type, gc_tuner&lt; 1 &gt;</a> &gt; blocks = { *<span class="keyword">this</span>, <span class="stringliteral">&quot;blocks&quot;</span> }; <span class="comment">// need recent g++ or icpc</span>
    <span class="comment">// every word instance we find we put in here with a unique tag</span>
    <a class="code" href="class_cn_c_1_1item__collection.html" title="An item collection is a mapping from tags to items.">CnC::item_collection&lt; std::string, result_type, gc_tuner&lt; 0 &gt;</a> &gt; map_out = { *<span class="keyword">this</span>, <span class="stringliteral">&quot;map_out&quot;</span> }; <span class="comment">// need recent g++ or icpc</span>
    <span class="comment">// we don&#39;t really need this, we use flush</span>
    <a class="code" href="class_cn_c_1_1item__collection.html" title="An item collection is a mapping from tags to items.">CnC::item_collection&lt; key_type, int &gt;</a> cnt = { *<span class="keyword">this</span>, <span class="stringliteral">&quot;cnt&quot;</span> }; <span class="comment">// need recent g++ or icpc</span>
    <span class="comment">// the results</span>
    <a class="code" href="class_cn_c_1_1item__collection.html" title="An item collection is a mapping from tags to items.">CnC::item_collection</a>&lt; key_type, result_type<span class="comment">/*, OTuner*/</span> &gt; results = { *<span class="keyword">this</span>, <span class="stringliteral">&quot;results&quot;</span> }; <span class="comment">// need recent g++ or icpc</span>
    <span class="comment">// reading files</span>
    <a class="code" href="class_cn_c_1_1step__collection.html" title="A step collection is logical set of step instances.">CnC::step_collection&lt; reader, read_tuner &gt;</a> read_steps = { *<span class="keyword">this</span>, <span class="stringliteral">&quot;reader&quot;</span> }; <span class="comment">// need recent g++ or icpc</span>
    <span class="comment">// extracing words</span>
    <a class="code" href="class_cn_c_1_1step__collection.html" title="A step collection is logical set of step instances.">CnC::step_collection&lt; mapper, map_tuner &gt;</a> map_steps = { *<span class="keyword">this</span>, <span class="stringliteral">&quot;mapper&quot;</span> }; <span class="comment">// need recent g++ or icpc</span>
    <span class="comment">// the reduction sub-graph</span>
    <a class="code" href="class_cn_c_1_1graph.html" title="Base class for defining and using CnC (sub-)graphs.">CnC::graph</a> * reduce;
    <span class="comment">// our private instance/copy of the map operation</span>
    MapOp m_mapOp;
    <span class="comment">// our private instance/copy of the reduce operation</span>
    ReduceOp m_reduceOp;
    
    <span class="comment">// we need a default constructor on distributed memory</span>
    <span class="comment">// the combination with serialize must match what the parametrized constructor does.</span>
    mapreduce_context()
        : reduce( NULL ),
          m_mapOp(),
          m_reduceOp()
    {
        read_tags.prescribes( read_steps, *<span class="keyword">this</span> );
        map_tags.prescribes( map_steps, *<span class="keyword">this</span> );
        read_steps.produces( blocks );
        map_steps.consumes( blocks );
        map_steps.produces( map_out );
    }

    <span class="comment">// this is the cosntructor the user actually sees/uses:</span>
    <span class="comment">// it provides the map- and reduce operations</span>
    mapreduce_context( <span class="keyword">const</span> MapOp &amp; mo, <span class="keyword">const</span> ReduceOp &amp; ro )
        : mapreduce_context&lt; MapOp, ReduceOp &gt;()
    {
        m_mapOp = mo;
        m_reduceOp = ro;
        init_reduce();
    }
    
    <span class="comment">// initing the reduce graph</span>
    <span class="comment">// called by serialize (unpack) and the programmer-used constructor</span>
    <span class="keywordtype">void</span> init_reduce() 
    {
        <span class="keyword">delete</span> reduce;
        reduce = <a class="code" href="group__reductions.html#ga700ef577820e594bfc11868817766965">CnC::make_reduce_graph</a>( *<span class="keyword">this</span>, <span class="stringliteral">&quot;reduce&quot;</span>,
                                         map_out, <span class="comment">//input collection</span>
                                         cnt,           <span class="comment">// counts per reduce, not used</span>
                                         results,       <span class="comment">// result</span>
                                         m_reduceOp,    <span class="comment">// reduce operation</span>
                                         size_type(0),  <span class="comment">// identity element</span>
                                         <span class="comment">// we use a lambda as the selector</span>
                                         <span class="comment">// it maps the item to the reduction identified by t.second (the string)</span>
                                         <span class="comment">// e.g. it reduces over all blocks</span>
                                         []( <span class="keyword">const</span> std::string &amp; t, std::string&amp; _s )-&gt;<span class="keywordtype">bool</span>{_s=t;<span class="keywordflow">return</span> <span class="keyword">true</span>;} );
    }

    ~mapreduce_context()
    {
        <span class="keyword">delete</span> reduce;
    }

    <span class="comment">// we overwrite the normal wait to make it even easier</span>
    <span class="comment">// in some cases this might not be desired, but we don&#39;t care for now.</span>
    <span class="keywordtype">void</span> wait() 
    {
        <span class="comment">// A reduction needs number of reduced items.</span>
        <span class="comment">// We do not know the count in advance.</span>
        <span class="comment">// We do not even know which words are going to show up.</span>
        <span class="comment">// We have to wait until processing is done</span>
        <span class="comment">// and then tell the reduction it can do the final pass.</span>
        <a class="code" href="class_cn_c_1_1context.html" title="CnC context bringing together collections (for steps, items and tags).">CnC::context&lt; mapreduce_context&lt; MapOp, ReduceOp &gt;</a> &gt;::wait();
        reduce-&gt;flush();
        <a class="code" href="class_cn_c_1_1context.html" title="CnC context bringing together collections (for steps, items and tags).">CnC::context&lt; mapreduce_context&lt; MapOp, ReduceOp &gt;</a> &gt;::wait();
    }

<span class="preprocessor">#ifdef _DIST_</span>
<span class="preprocessor"></span>    <span class="keywordtype">void</span> serialize( <a class="code" href="class_cn_c_1_1serializer.html" title="Handles serilialization of data-objects.">CnC::serializer</a> &amp; ser )
    {
        ser &amp; m_mapOp &amp; m_reduceOp;
        <span class="keywordflow">if</span>( ser.is_unpacking() ) init_reduce();
    }
<span class="preprocessor">#endif</span>
<span class="preprocessor"></span>};

<span class="comment">// function templates are easier to use the template classes</span>
<span class="comment">// let&#39;s define a function which returns the right context type by</span>
<span class="comment">// just providing the operations.</span>
<span class="keyword">template</span>&lt; <span class="keyword">typename</span> MapOp, <span class="keyword">typename</span> ReduceOp &gt;
mapreduce_context&lt; MapOp, ReduceOp &gt; * make_mapreduce( <span class="keyword">const</span> MapOp &amp; mo, <span class="keyword">const</span> ReduceOp &amp; ro )
{
    <span class="keywordflow">return</span> <span class="keyword">new</span> mapreduce_context&lt; MapOp, ReduceOp &gt;( mo, ro );
}

<span class="comment">// get the line, read word by word and put each instance</span>
<span class="comment">// with unique tag into map_out, which is the</span>
<span class="comment">// input collection of the reduction</span>
<span class="keyword">template</span>&lt; <span class="keyword">typename</span> MapOp, <span class="keyword">typename</span> ReduceOp &gt;
<span class="keywordtype">int</span> mapreduce_context&lt; MapOp, ReduceOp &gt;::mapper::execute( <span class="keyword">const</span> map_tag_type &amp; t, mapreduce_context&lt; MapOp, ReduceOp &gt; &amp; ctxt )<span class="keyword"> const</span>
<span class="keyword"></span>{
    char_ptr_type _str;
    ctxt.blocks.get( t, _str );
    std::istringstream iss( _str );
    ctxt.m_mapOp( iss, ctxt.map_out );
    <span class="keywordflow">return</span> 0;
}

<span class="comment">// read the given file and trigger map operations</span>
<span class="keyword">template</span>&lt; <span class="keyword">typename</span> MapOp, <span class="keyword">typename</span> ReduceOp &gt;
<span class="keywordtype">int</span> mapreduce_context&lt; MapOp, ReduceOp &gt;::reader::execute( <span class="keyword">const</span> std::string &amp; file, mapreduce_context&lt; MapOp, ReduceOp &gt; &amp; ctxt )<span class="keyword"> const</span>
<span class="keyword"></span>{
    <span class="keyword">const</span> <span class="keywordtype">int</span> MIN_BLK_SZ = 1024;

    std::string _fn( file );
    <span class="keyword">auto</span> _col = file.rfind( <span class="charliteral">&#39;:&#39;</span> );
    <span class="keywordflow">if</span>( _col != std::string::npos ) _fn.resize( _col );
    std::ifstream _file( _fn );
    <span class="keywordflow">if</span>( ! _file ) {
        std::cerr &lt;&lt; <span class="stringliteral">&quot;Could not open file &quot;</span> &lt;&lt; _fn &lt;&lt; std::endl;
        <span class="keywordflow">return</span> <a class="code" href="namespace_cn_c.html#aa098e2701e90eb28bf0f6469eb710c1f" title="Steps return CNC_Failure if execution failed.">CnC::CNC_Failure</a>;
    }

    <span class="keywordtype">long</span> <span class="keywordtype">long</span> <span class="keywordtype">int</span> _id = 0;
    <span class="keywordtype">int</span> _first = 0;
    char_ptr_type _block; <span class="comment">//( new char[MIN_BLK_SZ], std::default_delete&lt;char[]&gt;() );</span>
    _block.resize( MIN_BLK_SZ );
    <span class="comment">// we read blocks of data</span>
    <span class="comment">// as a block might be in the middle of a word, we need some extra stuff</span>
    <span class="comment">// e.g. we find the last whitespace to end the block</span>
    <span class="comment">//      and copy the rest to the next block</span>
    <span class="keywordflow">do</span> {
        <span class="keywordtype">char</span> * _b = <span class="keyword">const_cast&lt;</span> <span class="keywordtype">char</span> * <span class="keyword">&gt;</span>( _block.c_str() );
        _file.read( _b + _first, MIN_BLK_SZ );
        <span class="keywordtype">int</span> _cnt = _first + _file.gcount();
        _block.resize( _cnt );
        <span class="keywordflow">if</span>( _cnt &gt; 0 ) {
            <span class="comment">// we&#39;ll miss the last word if the file doesn&#39;t end with a whitespace.</span>
            <span class="keyword">auto</span> _last = _block.find_last_of( <span class="stringliteral">&quot; \t\n&quot;</span> );
            _first = _cnt - _last - 1;
            std::string _tmp;
            <span class="keywordflow">if</span>( _file ) {
                _tmp.resize( MIN_BLK_SZ + _first );
                <span class="keywordflow">if</span>( _first &gt; 0 ) _tmp.replace( 0, _first, _block, _last + 1, _first );
                <span class="comment">//                _tmp.resize( MIN_BLK_SZ + _first );</span>
            }
            _block.resize( _last );
            <span class="keyword">auto</span> _btag = std::make_pair( file, _id );
            <span class="comment">// put each line</span>
            ctxt.blocks.put( _btag, _block );
            <span class="comment">// and control to start searching/matching</span>
            ctxt.map_tags.put( _btag );
            _block = _tmp;<span class="comment">//.reset( _tmp, std::default_delete&lt;char[]&gt;() );</span>
            ++_id;
        }
    } <span class="keywordflow">while</span>( _file );

    <span class="keywordflow">return</span> 0;
}
</pre></div> <h2><a class="anchor" id="count_all_words_mr_code"></a>
samples/count_all_words/mapreduce/mapreduce.cpp</h2>
<div class="fragment"><pre class="fragment"><span class="comment">// *******************************************************************************</span>
<span class="comment">// Copyright (c) 2013-2014 Intel Corporation. All rights reserved.              **</span>
<span class="comment">//                                                                              **</span>
<span class="comment">// Redistribution and use in source and binary forms, with or without           **</span>
<span class="comment">// modification, are permitted provided that the following conditions are met:  **</span>
<span class="comment">//   * Redistributions of source code must retain the above copyright notice,   **</span>
<span class="comment">//     this list of conditions and the following disclaimer.                    **</span>
<span class="comment">//   * Redistributions in binary form must reproduce the above copyright        **</span>
<span class="comment">//     notice, this list of conditions and the following disclaimer in the      **</span>
<span class="comment">//     documentation and/or other materials provided with the distribution.     **</span>
<span class="comment">//   * Neither the name of Intel Corporation nor the names of its contributors  **</span>
<span class="comment">//     may be used to endorse or promote products derived from this software    **</span>
<span class="comment">//     without specific prior written permission.                               **</span>
<span class="comment">//                                                                              **</span>
<span class="comment">// This software is provided by the copyright holders and contributors &quot;as is&quot;  **</span>
<span class="comment">// and any express or implied warranties, including, but not limited to, the    **</span>
<span class="comment">// implied warranties of merchantability and fitness for a particular purpose   **</span>
<span class="comment">// are disclaimed. In no event shall the copyright owner or contributors be     **</span>
<span class="comment">// liable for any direct, indirect, incidental, special, exemplary, or          **</span>
<span class="comment">// consequential damages (including, but not limited to, procurement of         **</span>
<span class="comment">// substitute goods or services; loss of use, data, or profits; or business     **</span>
<span class="comment">// interruption) however caused and on any theory of liability, whether in      **</span>
<span class="comment">// contract, strict liability, or tort (including negligence or otherwise)      **</span>
<span class="comment">// arising in any way out of the use of this software, even if advised of       **</span>
<span class="comment">// the possibility of such damage.                                              **</span>
<span class="comment">// *******************************************************************************</span>

<span class="preprocessor">#include &quot;mapreduce.h&quot;</span>

<span class="comment">/*</span>
<span class="comment">  Count the number of occurances of all words in a file.  An example</span>
<span class="comment">  of using mapreduce_context.</span>
<span class="comment">  It&#39;s bascially the same functionality as what&#39;s done in count_all_words</span>
<span class="comment">  but using the mapreduce abstraction.</span>
<span class="comment">  </span>
<span class="comment">  Please see mapreduce.h and count_all_words.cpp for details.</span>
<span class="comment">*/</span>

<span class="comment">// we use std::plus as the reduce operation</span>
<span class="keyword">namespace </span>std {
    <span class="keyword">template</span>&lt; <span class="keyword">typename</span> T &gt;
    <span class="keyword">inline</span> <a class="code" href="class_cn_c_1_1bitwise__serializable.html" title="simple structs/classes are bitwise serializable.">CnC::bitwise_serializable</a> <a class="code" href="group__serialization.html#ga0e9f55ae1f7ad188f9f3e9e8f27ba440">serializer_category</a>( <span class="keyword">const</span> std::plus&lt; T &gt;  * ) {
        <span class="keywordflow">return</span> <a class="code" href="class_cn_c_1_1bitwise__serializable.html" title="simple structs/classes are bitwise serializable.">CnC::bitwise_serializable</a>();
    }
}

<span class="comment">// our map function (functor)</span>
<span class="comment">// reads given stream word by word and counts all occuring words</span>
<span class="comment">// by simply putting 1 for each word</span>
<span class="keyword">struct </span>count
{
    <span class="keyword">typedef</span> std::string key_type;
    <span class="keyword">typedef</span> size_type result_type;

    <span class="keyword">template</span>&lt; <span class="keyword">typename</span> IStream, <span class="keyword">typename</span> OutCollection &gt;
    <span class="keyword">inline</span> <span class="keywordtype">void</span> operator()( IStream &amp; iss, OutCollection &amp; out )<span class="keyword"> const</span>
<span class="keyword">    </span>{
        std::string _word;
        <span class="keywordflow">while</span>( iss &gt;&gt; _word ) {
            <span class="comment">// let&#39;s a do a case-insensitive matching</span>
            std::transform(_word.begin(), _word.end(), _word.begin(), ::tolower);
            out.put( _word, 1 );
        }
    }
};
<a class="code" href="group__serialization.html#ga7315edf5ecbcdbc4c086d2ba9a262b3a">CNC_BITWISE_SERIALIZABLE</a>( count );

<span class="keywordtype">int</span> main( <span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> * argv[])
{
    <span class="keyword">typedef</span> mapreduce_context&lt; count, std::plus&lt;size_type&gt; &gt; caw_context;
<span class="preprocessor">#ifdef _DIST_</span>
<span class="preprocessor"></span>    <a class="code" href="struct_cn_c_1_1dist__cnc__init.html">CnC::dist_cnc_init&lt; caw_context &gt;</a> _dc;
<span class="preprocessor">#endif</span>
<span class="preprocessor"></span>    
    <span class="keywordflow">if</span>( argc &lt; 2 ) {
        std::cerr &lt;&lt; <span class="stringliteral">&quot;expected arguments: &lt;file1&gt;[ &lt;file2&gt; ...]\n&quot;</span>;
            exit(1);
    }
    <span class="comment">// create the context</span>
    caw_context * mapred = make_mapreduce( count(), std::plus&lt;size_type&gt;() );

    tbb::tick_count startTime = tbb::tick_count::now();

    <span class="keywordflow">for</span>( <span class="keywordtype">int</span> i = 1; i&lt;argc; ++i ) {
        mapred-&gt;read_tags.put( argv[i] );
        <span class="comment">//        reader_execute( argv[i], mapred );</span>
    }
    mapred-&gt;wait();

    tbb::tick_count endTime = tbb::tick_count::now();

    std::cout &lt;&lt; mapred-&gt;results.size() &lt;&lt; std::endl;
    <span class="comment">// iterate and write out all keys/value pairs with counts &gt; 999</span>
    <span class="keywordflow">for</span>( <span class="keyword">auto</span> i = mapred-&gt;results.begin(); i != mapred-&gt;results.end(); ++i ) {
        <span class="comment">//        if( *i-&gt;second &gt; 999 )</span>
            std::cout &lt;&lt; i-&gt;first &lt;&lt; <span class="stringliteral">&quot; \t &quot;</span> &lt;&lt; *i-&gt;second &lt;&lt; std::endl;
    }

    <span class="keyword">delete</span> mapred;

    std::cout &lt;&lt; <span class="stringliteral">&quot;Time: &quot;</span> &lt;&lt; (endTime-startTime).seconds() &lt;&lt; <span class="stringliteral">&quot;s.\n&quot;</span>;

    <span class="keywordflow">return</span> 0;
}
</pre></div> <h2><a class="anchor" id="reduce_2d_code"></a>
samples/reduce_2d/reduce_2d/reduce_2d.cpp</h2>
<div class="fragment"><pre class="fragment"><span class="comment">//********************************************************************************</span>
<span class="comment">// Copyright (c) 2007-2014 Intel Corporation. All rights reserved.              **</span>
<span class="comment">//                                                                              **</span>
<span class="comment">// Redistribution and use in source and binary forms, with or without           **</span>
<span class="comment">// modification, are permitted provided that the following conditions are met:  **</span>
<span class="comment">//   * Redistributions of source code must retain the above copyright notice,   **</span>
<span class="comment">//     this list of conditions and the following disclaimer.                    **</span>
<span class="comment">//   * Redistributions in binary form must reproduce the above copyright        **</span>
<span class="comment">//     notice, this list of conditions and the following disclaimer in the      **</span>
<span class="comment">//     documentation and/or other materials provided with the distribution.     **</span>
<span class="comment">//   * Neither the name of Intel Corporation nor the names of its contributors  **</span>
<span class="comment">//     may be used to endorse or promote products derived from this software    **</span>
<span class="comment">//     without specific prior written permission.                               **</span>
<span class="comment">//                                                                              **</span>
<span class="comment">// This software is provided by the copyright holders and contributors &quot;as is&quot;  **</span>
<span class="comment">// and any express or implied warranties, including, but not limited to, the    **</span>
<span class="comment">// implied warranties of merchantability and fitness for a particular purpose   **</span>
<span class="comment">// are disclaimed. In no event shall the copyright owner or contributors be     **</span>
<span class="comment">// liable for any direct, indirect, incidental, special, exemplary, or          **</span>
<span class="comment">// consequential damages (including, but not limited to, procurement of         **</span>
<span class="comment">// substitute goods or services; loss of use, data, or profits; or business     **</span>
<span class="comment">// interruption) however caused and on any theory of liability, whether in      **</span>
<span class="comment">// contract, strict liability, or tort (including negligence or otherwise)      **</span>
<span class="comment">// arising in any way out of the use of this software, even if advised of       **</span>
<span class="comment">// the possibility of such damage.                                              **</span>
<span class="comment">//********************************************************************************</span>

<span class="preprocessor">#ifdef _DIST_</span>
<span class="preprocessor"></span><span class="preprocessor"># include &lt;cnc/dist_cnc.h&gt;</span>
<span class="preprocessor">#else</span>
<span class="preprocessor"></span><span class="preprocessor"># include &lt;cnc/cnc.h&gt;</span>
<span class="preprocessor">#endif</span>
<span class="preprocessor"></span><span class="preprocessor">#include &lt;cnc/debug.h&gt;</span>
<span class="preprocessor">#include &lt;cnc/reduce.h&gt;</span>
<span class="preprocessor">#include &lt;cassert&gt;</span>

<span class="comment">/*</span>
<span class="comment">  Demo for connecting 2 dependent graphs (e.g. reductions).</span>
<span class="comment">  The input to the program are values ina  2d-space (a).</span>
<span class="comment">  The output is the sum of all values (sum2).</span>
<span class="comment">  The first reduction computes the sum for each row (sum1)</span>
<span class="comment">  The second takes this output and sums it to the final value (sum2).</span>
<span class="comment">  There is no barrier and only a single wait</span>
<span class="comment">  (ignore whats enclosed in #ifdef _CNC_TESTING_ ... #endif).</span>
<span class="comment">  We just use sum1 as the output for the first reduction (red1)</span>
<span class="comment">  and also as the input to the second (red2).</span>
<span class="comment">  Evaluation executes fully asynchronously.</span>
<span class="comment"></span>
<span class="comment">  Additionally, the selector ignores certain values when summing the rows.</span>
<span class="comment"></span>
<span class="comment">  Last but not least we also increase the stress on the runtime by providing</span>
<span class="comment">  the counts per reduction at different stages (early, mid, late).</span>
<span class="comment"> */</span>

<span class="comment">// size of &quot;matrix&quot;</span>
<span class="keyword">const</span> <span class="keywordtype">int</span> N = 32;
<span class="comment">// threashold for selecting candidates for row-sum</span>
<span class="keyword">const</span> <span class="keywordtype">int</span> MX = 24;
<span class="comment">// describes our 2d space</span>
<span class="keyword">typedef</span> std::pair&lt; int, int &gt; tag_type;


<span class="comment">// selector performing different selections dependening on reduction/tag</span>
<span class="keyword">struct </span>selector
{
    <span class="comment">// functor, assign second as reduction-id</span>
    <span class="comment">// return false if first &gt;= MX (we only reduce items with tag-&gt;first &lt; MX)</span>
    <span class="keyword">template</span>&lt; <span class="keyword">typename</span> T, <span class="keyword">typename</span> S, <span class="keyword">typename</span> R &gt;
    <span class="keywordtype">bool</span> operator()( <span class="keyword">const</span> std::pair&lt; T, S &gt; &amp; t, R &amp; r )<span class="keyword"> const </span>{
        <span class="keywordflow">if</span>( t.first &gt;= MX ) <span class="keywordflow">return</span> <span class="keyword">false</span>;
        r = t.second;
        <span class="keywordflow">return</span> <span class="keyword">true</span>;
    }

    <span class="comment">// here we select all and return singleton 0</span>
    <span class="keyword">template</span>&lt; <span class="keyword">typename</span> T, <span class="keyword">typename</span> R &gt;
    <span class="keywordtype">bool</span> operator()( <span class="keyword">const</span> T &amp; t, R &amp; r )<span class="keyword"> const </span>{
        r = 0;
        <span class="keywordflow">return</span> <span class="keyword">true</span>;
    }
};


<span class="comment">// the step just puts the value to the &quot;matrix&quot;</span>
<span class="comment">// in real life this might first do some meaningful computation</span>
<span class="keyword">struct </span>putter
{
    <span class="comment">// simply puts 1 with same tag to item-coll</span>
    <span class="keyword">template</span>&lt; <span class="keyword">typename</span> T, <span class="keyword">typename</span> C &gt;
    <span class="keywordtype">int</span> execute( <span class="keyword">const</span> T &amp; t, C &amp; ctxt )<span class="keyword"> const</span>
<span class="keyword">    </span>{
        ctxt.a.put( t, 1 );
        <span class="comment">// in some cases we put the count here (just testing)</span>
        <span class="keywordflow">if</span>( t.first &gt;= MX &amp;&amp; t.first == t.second ) ctxt.cnt1.put( t.first, MX );
        <span class="keywordflow">return</span> 0;
    }
};

<span class="keyword">struct </span>reduce_context : <span class="keyword">public</span> CnC::context&lt; reduce_context &gt;
{
    <a class="code" href="class_cn_c_1_1tag__collection.html" title="A tag collection is a set of tags of the same type. It is used to prescribe steps. By default, tags are not stored.">CnC::tag_collection&lt; tag_type &gt;</a> tags;         <span class="comment">// control tags for our step</span>
    <a class="code" href="class_cn_c_1_1item__collection.html" title="An item collection is a mapping from tags to items.">CnC::item_collection&lt; tag_type, int &gt;</a> a;      <span class="comment">// the matrix</span>
    <a class="code" href="class_cn_c_1_1item__collection.html" title="An item collection is a mapping from tags to items.">CnC::item_collection&lt; int, int &gt;</a> cnt1, cnt2;  <span class="comment">// provides number of participating items per reduction</span>
    <a class="code" href="class_cn_c_1_1item__collection.html" title="An item collection is a mapping from tags to items.">CnC::item_collection&lt; int, int &gt;</a> sum1, sum2;  <span class="comment">// outputs of reductions</span>
    <a class="code" href="class_cn_c_1_1step__collection.html" title="A step collection is logical set of step instances.">CnC::step_collection&lt; putter &gt;</a> sc;            <span class="comment">// the steps</span>
    <a class="code" href="class_cn_c_1_1graph.html" title="Base class for defining and using CnC (sub-)graphs.">CnC::graph</a> * red1, * red2;                    <span class="comment">// out 2 sub-graphs: 2 reductions</span>

    reduce_context()
        : tags( *this, <span class="stringliteral">&quot;tags&quot;</span> ),
          a( *this, <span class="stringliteral">&quot;a&quot;</span> ),
          cnt1( *this, <span class="stringliteral">&quot;cnt1&quot;</span> ),
          cnt2( *this, <span class="stringliteral">&quot;cnt2&quot;</span> ),
          sum1( *this, <span class="stringliteral">&quot;sum1&quot;</span> ),
          sum2( *this, <span class="stringliteral">&quot;sum2&quot;</span> ),
          sc( *this, <span class="stringliteral">&quot;step&quot;</span> ),
          red1( NULL ),
          red2( NULL )
    {
        tags.prescribes( sc, *<span class="keyword">this</span> );
        sc.produces( a );
        <span class="comment">// first reduction inputs a and outputs sum1</span>
        red1 = <a class="code" href="group__reductions.html#ga700ef577820e594bfc11868817766965">CnC::make_reduce_graph</a>( *<span class="keyword">this</span>, <span class="stringliteral">&quot;red_row&quot;</span>,
                                       a,            <span class="comment">// input collection: our matrix</span>
                                       cnt1,         <span class="comment">// count of items per reduction</span>
                                       sum1,         <span class="comment">// output collection: sum per row</span>
                                       std::plus&lt;int&gt;(),  <span class="comment">// reduction operation &#39;+&#39;</span>
                                       0,            <span class="comment">//identity element</span>
                                       selector() ); <span class="comment">// selector</span>
        <span class="comment">// second reduction inputs sum1 and outputs sum2</span>
        red2 = <a class="code" href="group__reductions.html#ga700ef577820e594bfc11868817766965">CnC::make_reduce_graph</a>( *<span class="keyword">this</span>, <span class="stringliteral">&quot;red_red&quot;</span>,
                                       sum1,         <span class="comment">// the input collection is the output of red1</span>
                                       cnt2,         <span class="comment">// count of items per reduction</span>
                                       sum2,         <span class="comment">// the final output: sum of all values</span>
                                       std::plus&lt;int&gt;(),  <span class="comment">// reduction operation &#39;+&#39;</span>
                                       0,            <span class="comment">//identity element</span>
                                       selector() ); <span class="comment">// selector</span>
<span class="preprocessor">#ifdef _CNC_TESTING_</span>
<span class="preprocessor"></span>        <a class="code" href="struct_cn_c_1_1debug.html#a037ca57a050741fda23a61a18cac27b3" title="enable tracing of a given tag collection at a given level">CnC::debug::trace</a>( sum1, 1 );
        <a class="code" href="struct_cn_c_1_1debug.html#a037ca57a050741fda23a61a18cac27b3" title="enable tracing of a given tag collection at a given level">CnC::debug::trace</a>( *red1, 2 );
        <a class="code" href="struct_cn_c_1_1debug.html#a037ca57a050741fda23a61a18cac27b3" title="enable tracing of a given tag collection at a given level">CnC::debug::trace</a>( *red2, 2 );
<span class="preprocessor">#endif</span>
<span class="preprocessor"></span>    }

    ~reduce_context()
    {
        <span class="keyword">delete</span> red1;
    }
};

<span class="keywordtype">int</span> main()
{
<span class="preprocessor">#ifdef _DIST_</span>
<span class="preprocessor"></span>    <a class="code" href="struct_cn_c_1_1dist__cnc__init.html">CnC::dist_cnc_init&lt; reduce_context &gt;</a> _dc;
<span class="preprocessor">#endif</span>
<span class="preprocessor"></span>    <span class="comment">// create the context</span>
    reduce_context ctxt;
    <span class="comment">// put the count for some reduction before eveything else</span>
    <span class="keywordflow">for</span>( <span class="keywordtype">int</span> i = 2; i &lt; MX; ++i ) ctxt.cnt1.put( i, MX );
    <span class="comment">// put control tags</span>
    <span class="keywordflow">for</span>( <span class="keywordtype">int</span> i = 0; i &lt; N; ++i ) {
        <span class="keywordflow">for</span>( <span class="keywordtype">int</span> j = N-1; j &gt;= 0; --j ) ctxt.tags.put( tag_type( i, j ) );
    }

<span class="preprocessor">#ifdef _CNC_TESTING_</span>
<span class="preprocessor"></span>    <span class="comment">// wait for all reductions except 3</span>
    ctxt.wait();
<span class="preprocessor">#endif</span>
<span class="preprocessor"></span>
    ctxt.cnt1.put( 0, MX );
    ctxt.cnt2.put(0,N);

<span class="preprocessor">#ifdef _CNC_TESTING_</span>
<span class="preprocessor"></span>    <span class="comment">// wait for all reductions except one to complete</span>
    ctxt.wait();
<span class="preprocessor">#endif</span>
<span class="preprocessor"></span>    <span class="comment">// put the count for one reduction after everything else</span>
    ctxt.cnt1.put( 1, MX );
    <span class="comment">// wait for safe state</span>
    ctxt.wait();

    <span class="comment">// iterate, check and write out all keys/value pairs</span>
    <span class="keyword">auto</span> _sz = ctxt.sum1.size();
    <span class="keywordflow">if</span>( _sz != N ) {
        std::cerr &lt;&lt; <span class="stringliteral">&quot;#reductions is &quot;</span> &lt;&lt; _sz &lt;&lt; <span class="stringliteral">&quot;, expected &quot;</span> &lt;&lt; N &lt;&lt; std::endl;
        <span class="keywordflow">return</span> 1239;
    }
    <span class="keywordflow">for</span>( <span class="keyword">auto</span> i = ctxt.sum1.begin(); i != ctxt.sum1.end(); ++i ) {
        <span class="keywordflow">if</span>( *i-&gt;second != MX ) {
            std::cerr &lt;&lt; <span class="stringliteral">&quot;cnt1 of &quot;</span> &lt;&lt; i-&gt;first &lt;&lt; <span class="stringliteral">&quot; is &quot;</span> &lt;&lt; *i-&gt;second &lt;&lt; <span class="stringliteral">&quot;, expected &quot;</span> &lt;&lt; MX &lt;&lt; std::endl;
            <span class="keywordflow">return</span> 1234;
        }
    }
    <span class="keywordtype">int</span> n = 0;
    ctxt.sum2.get(0, n );
    <span class="keywordflow">if</span>( n != N*MX ) {
        std::cerr &lt;&lt; <span class="stringliteral">&quot;reduce count is &quot;</span> &lt;&lt; n &lt;&lt; <span class="stringliteral">&quot;, expected &quot;</span> &lt;&lt; N*MX &lt;&lt; std::endl;
        <span class="keywordflow">return</span> 1236;
    }
    std::cout &lt;&lt; <span class="stringliteral">&quot;Success with &quot;</span> &lt;&lt; n &lt;&lt; std::endl;

    <span class="keywordflow">return</span> 0;
}
</pre></div> <h2><a class="anchor" id="hidden_graph_code"></a>
samples/hidden_graph/hidden_graph/hidden_graph.cpp</h2>
<div class="fragment"><pre class="fragment"><span class="comment">//********************************************************************************</span>
<span class="comment">// Copyright (c) 2013-2014 Intel Corporation. All rights reserved.              **</span>
<span class="comment">//                                                                              **</span>
<span class="comment">// Redistribution and use in source and binary forms, with or without           **</span>
<span class="comment">// modification, are permitted provided that the following conditions are met:  **</span>
<span class="comment">//   * Redistributions of source code must retain the above copyright notice,   **</span>
<span class="comment">//     this list of conditions and the following disclaimer.                    **</span>
<span class="comment">//   * Redistributions in binary form must reproduce the above copyright        **</span>
<span class="comment">//     notice, this list of conditions and the following disclaimer in the      **</span>
<span class="comment">//     documentation and/or other materials provided with the distribution.     **</span>
<span class="comment">//   * Neither the name of Intel Corporation nor the names of its contributors  **</span>
<span class="comment">//     may be used to endorse or promote products derived from this software    **</span>
<span class="comment">//     without specific prior written permission.                               **</span>
<span class="comment">//                                                                              **</span>
<span class="comment">// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;  **</span>
<span class="comment">// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE    **</span>
<span class="comment">// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE   **</span>
<span class="comment">// ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE     **</span>
<span class="comment">// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR          **</span>
<span class="comment">// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF         **</span>
<span class="comment">// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS     **</span>
<span class="comment">// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN      **</span>
<span class="comment">// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)      **</span>
<span class="comment">// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF       **</span>
<span class="comment">// THE POSSIBILITY OF SUCH DAMAGE.                                              **</span>
<span class="comment">//********************************************************************************</span>

<span class="comment">/*</span>
<span class="comment">  Demonstration of a hidden graph that&#39;s active outside the on_put callbacks.</span>
<span class="comment">  Using leave_quiescence and enter_quiescence to communicate its internal state.</span>
<span class="comment">  Environment puts data that the graph operates on.</span>
<span class="comment">  The graph&#39;s computation is just sleeping random time, but when done it puts </span>
<span class="comment">  control and data that a consumer step outside the hidden graph uses.</span>
<span class="comment">  For distribution we use tuner::consumed_on to assign the input data to remote</span>
<span class="comment">  processes.</span>
<span class="comment"> */</span>

<span class="preprocessor">#ifdef _DIST_</span>
<span class="preprocessor"></span><span class="preprocessor"># include &lt;cnc/dist_cnc.h&gt;</span>
<span class="preprocessor">#else</span>
<span class="preprocessor"></span><span class="preprocessor"># include &lt;cnc/cnc.h&gt;</span>
<span class="preprocessor">#endif</span>
<span class="preprocessor"></span><span class="preprocessor">#include &lt;cnc/debug.h&gt;</span>
<span class="preprocessor">#include &lt;cassert&gt;</span>
<span class="preprocessor">#include &lt;ctime&gt;</span>
<span class="preprocessor">#include &lt;tbb/concurrent_queue.h&gt;</span>
<span class="preprocessor">#include &lt;thread&gt;</span>         <span class="comment">// std::thread</span>
<span class="preprocessor">#include &lt;chrono&gt;</span>         <span class="comment">// std::chrono::milliseconds</span>

<span class="comment">// This is our hidden graph.  It is parametrized by 3 collections: the</span>
<span class="comment">// input data colleciton, an output tag collection and a output data</span>
<span class="comment">// collection.</span>
<span class="comment">//</span>
<span class="comment">// It sets its state to active and registers a on_put callback which</span>
<span class="comment">// stores the input data in an internal queue.</span>
<span class="comment">//</span>
<span class="comment">// An internal thread pops entries from the queue, sleeps for a while</span>
<span class="comment">// and then puts a control tag ana corresponding data item.  When the</span>
<span class="comment">// thread has processed 7 entries it reports quiescence and exits.</span>
<span class="comment">//</span>
<span class="comment">// The environment only puts data, no control. Without quiescence</span>
<span class="comment">// reporting the wait call could return immediately as no steps are</span>
<span class="comment">// prescribed. AS the hidden graph sets its state to active right at</span>
<span class="comment">// the beginning, the wait() call will not succeed until the graph</span>
<span class="comment">// signaled its quiescence.</span>
<span class="keyword">template</span>&lt; <span class="keyword">typename</span> IC_IN, <span class="keyword">typename</span> IC_OUT, <span class="keyword">typename</span> TC_OUT &gt;
<span class="keyword">class </span>hidden_graph : <span class="keyword">public</span> CnC::graph
{
<span class="keyword">private</span>:
    <span class="keyword">typedef</span> tbb::concurrent_bounded_queue&lt; typename IC_IN::data_type &gt; blocking_queue;

    <span class="comment">// the callback for incoming data just pushes the items on our internal queue</span>
    <span class="keyword">struct </span>on_data : <span class="keyword">public</span> IC_IN::callback_type
    {
        on_data( blocking_queue &amp; q ) : m_q(q) {}
        <span class="keywordtype">void</span> on_put( <span class="keyword">const</span> <span class="keyword">typename</span> IC_IN::tag_type &amp; <span class="comment">/*tag*/</span>, <span class="keyword">const</span> <span class="keyword">typename</span> IC_IN::data_type &amp; val )
        {
            m_q.push( val );
        };
        blocking_queue &amp; m_q;
    };

    <span class="comment">// we start a thread which takes data from our internal queue and works on it.</span>
    <span class="comment">// it enters quiescence and exits after processing 7 items</span>
    <span class="comment">// this is just a demo, so our work is simply sleepings</span>
    <span class="keyword">struct </span>observe_and_compute {
        <span class="keywordtype">void</span> operator()( blocking_queue * queue, IC_OUT * dataout, TC_OUT * tagout, <span class="keyword">const</span> hidden_graph&lt; IC_IN, IC_OUT, TC_OUT &gt; * graph )
        {
            <span class="keyword">typename</span> IC_IN::data_type _item;
            <span class="keyword">typename</span> TC_OUT::tag_type _tag(<a class="code" href="class_cn_c_1_1tuner__base.html#ae52a37bb28b0d5fdd7fc105ac989ac46">CnC::tuner_base::myPid</a>()*1000);
            <span class="keywordflow">do</span> {
                <span class="comment">// get next input</span>
                queue-&gt;pop( _item );
                <span class="comment">// and do some work, we just sleep, but it could be anything</span>
                <span class="comment">// ideally of course this would use TBB tasks</span>
                <span class="keywordtype">int</span> _tm = rand() % 1111;
                std::this_thread::sleep_for( std::chrono::milliseconds(_tm) );
                <span class="comment">// now produce our output, to make it a little more intersting let&#39;s make it conditional</span>
                <span class="keywordflow">if</span>( _tm % 4 ) {
                    dataout-&gt;put( _tag, _item + _tm );
                    tagout-&gt;put( _tag );
                    ++_tag;
                }
            } <span class="keywordflow">while</span>( _tag &lt; <a class="code" href="class_cn_c_1_1tuner__base.html#ae52a37bb28b0d5fdd7fc105ac989ac46">CnC::tuner_base::myPid</a>()*1000+7 );
            <span class="comment">// we are done, before exiting we must inform the runtime</span>
            graph-&gt;enter_quiescence();
            CnC::Internal::Speaker oss;
            oss &lt;&lt; <span class="stringliteral">&quot;done observe_and_compute&quot;</span>;
        }
    };
<span class="keyword">public</span>:
    <span class="comment">// the constructor tells the runtime that the graph is not quiescent</span>
    <span class="comment">// it also starts the thread and registers the on_put callback</span>
    <span class="keyword">template</span>&lt; <span class="keyword">typename</span> Ctxt &gt;
    hidden_graph( <a class="code" href="class_cn_c_1_1context.html" title="CnC context bringing together collections (for steps, items and tags).">CnC::context&lt; Ctxt &gt;</a> &amp; ctxt, <span class="keyword">const</span> std::string &amp; name, IC_IN &amp; ic1, IC_OUT &amp; ic2, TC_OUT &amp; tc )
        : CnC::graph( ctxt, name ),
          m_input( ic1 ),
          m_dataout( ic2 ),
          m_tagout( tc ),
          m_queue(),
          m_thread( observe_and_compute(), &amp;m_queue, &amp;m_dataout, &amp;m_tagout, this )
    {
        <span class="comment">// we started a thread, we are not quiescent until it exits</span>
        this-&gt;leave_quiescence();
        <span class="comment">// register the callback</span>
        m_input.on_put( <span class="keyword">new</span> on_data( m_queue ) );
    }
    <span class="keyword">virtual</span> ~hidden_graph()
    {
        m_thread.join();
    }
<span class="keyword">private</span>:
    IC_IN  &amp; m_input;   <span class="comment">// here we expect the input to arrive</span>
    IC_OUT &amp; m_dataout; <span class="comment">// here we put our output data</span>
    TC_OUT &amp; m_tagout;  <span class="comment">// here we put the control tags</span>
    blocking_queue m_queue; <span class="comment">// the queue where we push the data and the threads pops data from</span>
    std::thread m_thread;   <span class="comment">// our internal thread</span>
};

<span class="comment">// a template function is much easier to use than a template class with many template arguments.</span>
<span class="keyword">template</span>&lt; <span class="keyword">typename</span> Ctxt, <span class="keyword">typename</span> IC_IN, <span class="keyword">typename</span> IC_OUT, <span class="keyword">typename</span> TC_OUT &gt;
hidden_graph&lt; IC_IN, IC_OUT, TC_OUT &gt; * make_hgraph( <a class="code" href="class_cn_c_1_1context.html" title="CnC context bringing together collections (for steps, items and tags).">CnC::context&lt; Ctxt &gt;</a> &amp; ctxt, <span class="keyword">const</span> std::string &amp; name, IC_IN &amp; ic1, IC_OUT &amp; ic2, TC_OUT &amp; tc )
{
    <span class="keywordflow">return</span> <span class="keyword">new</span> hidden_graph&lt; IC_IN, IC_OUT, TC_OUT &gt;( ctxt, name, ic1, ic2, tc );
}

<span class="keyword">struct </span>hg_context;

<span class="comment">// here we consume the values produced by the hidden graph</span>
<span class="keyword">struct </span>consume
{
    <span class="keywordtype">int</span> execute( <span class="keyword">const</span> <span class="keywordtype">int</span> tag, hg_context &amp; ctxt ) <span class="keyword">const</span>;
};

<span class="comment">// our tuner makes sure the data gets distributed</span>
<span class="comment">// as it gets produced in the env, we must define the consumed_on method</span>
<span class="keyword">struct </span>hg_tuner : <span class="keyword">public</span> CnC::hashmap_tuner
{
    <span class="keywordtype">int</span> consumed_on( <span class="keyword">const</span> <span class="keywordtype">int</span> &amp; tag )<span class="keyword"> const</span>
<span class="keyword">    </span>{
        <span class="keywordflow">return</span> tag % numProcs();
    }
};

<span class="comment">// our actual &quot;global&quot; context</span>
<span class="keyword">struct </span>hg_context : <span class="keyword">public</span> CnC::context&lt; hg_context &gt;
{
    <a class="code" href="class_cn_c_1_1step__collection.html" title="A step collection is logical set of step instances.">CnC::step_collection&lt; consume &gt;</a>   consumer;
    <a class="code" href="class_cn_c_1_1item__collection.html" title="An item collection is a mapping from tags to items.">CnC::item_collection&lt; int, int, hg_tuner &gt;</a>  input_data;
    <a class="code" href="class_cn_c_1_1item__collection.html" title="An item collection is a mapping from tags to items.">CnC::item_collection&lt; int, int &gt;</a>  processed_data;
    <a class="code" href="class_cn_c_1_1item__collection.html" title="An item collection is a mapping from tags to items.">CnC::item_collection&lt; int, int &gt;</a>  result_data;
    <a class="code" href="class_cn_c_1_1tag__collection.html" title="A tag collection is a set of tags of the same type. It is used to prescribe steps. By default, tags are not stored.">CnC::tag_collection&lt; int &gt;</a>        consumer_tags;
    <a class="code" href="class_cn_c_1_1graph.html" title="Base class for defining and using CnC (sub-)graphs.">CnC::graph</a> * hgraph;

    hg_context()
        : consumer( *this, <span class="stringliteral">&quot;consumer&quot;</span> ),
          input_data( *this, <span class="stringliteral">&quot;input_data&quot;</span> ),
          processed_data( *this, <span class="stringliteral">&quot;processed_data&quot;</span> ),
          result_data( *this, <span class="stringliteral">&quot;result_data&quot;</span> ),
          consumer_tags( *this, <span class="stringliteral">&quot;consumer_tags&quot;</span> )
    {
        consumer_tags.prescribes( consumer, *<span class="keyword">this</span> );
        consumer.consumes( processed_data );
        consumer.produces( result_data );
        hgraph = make_hgraph( *<span class="keyword">this</span>, <span class="stringliteral">&quot;hidden_graph&quot;</span>, input_data, processed_data, consumer_tags );
        <span class="comment">//        CnC::debug::trace_all( *this );</span>
    }
};

<span class="comment">// the consumer just gets the data and puts something into result</span>
<span class="keywordtype">int</span> consume::execute( <span class="keyword">const</span> <span class="keywordtype">int</span> tag, hg_context &amp; ctxt )<span class="keyword"> const</span>
<span class="keyword"></span>{
    <span class="keywordtype">int</span> _val;
    ctxt.processed_data.get( tag, _val );
    ctxt.result_data.put( tag+tag, _val*_val );
    <span class="keywordflow">return</span> 0;
}

<span class="comment">// the env only puts data and waits for completion</span>
<span class="keywordtype">int</span> main()
{
    srand( 11 );
<span class="preprocessor">#ifdef _DIST_</span>
<span class="preprocessor"></span>    <a class="code" href="struct_cn_c_1_1dist__cnc__init.html">CnC::dist_cnc_init&lt; hg_context &gt;</a> _dc;
<span class="preprocessor">#endif</span>
<span class="preprocessor"></span>    hg_context _ctxt;
    <span class="keywordflow">for</span>( <span class="keywordtype">int</span> i = 0; i &lt; 444; ++i ) {
        _ctxt.input_data.put( i, rand() );
    }
    _ctxt.wait();
    <span class="comment">// we use srand, so the number of generated tuples should always be identical</span>
    <span class="keywordflow">if</span>( _ctxt.result_data.size() != 7 * <a class="code" href="class_cn_c_1_1tuner__base.html#aef1047092ade8db731c56fbf2f708e76">CnC::tuner_base::numProcs</a>() ) {
        std::cerr &lt;&lt; <span class="stringliteral">&quot;Error: expected &quot;</span> &lt;&lt; (7 * <a class="code" href="class_cn_c_1_1tuner__base.html#aef1047092ade8db731c56fbf2f708e76">CnC::tuner_base::numProcs</a>()) &lt;&lt; <span class="stringliteral">&quot; items, found &quot;</span> &lt;&lt; _ctxt.result_data.size() &lt;&lt; std::endl;
        exit(11);
    }
    <span class="keywordflow">return</span> 0;
}
</pre></div> <h2><a class="anchor" id="mpicnc_code"></a>
samples/mpicnc/mpicnc/mpicnc.cpp</h2>
<div class="fragment"><pre class="fragment"><span class="comment">/* *******************************************************************************</span>
<span class="comment"> *  Copyright (c) 2013-2014, Intel Corporation</span>
<span class="comment"> *</span>
<span class="comment"> *  Redistribution and use in source and binary forms, with or without</span>
<span class="comment"> *  modification, are permitted provided that the following conditions are met:</span>
<span class="comment"> *</span>
<span class="comment"> *  * Redistributions of source code must retain the above copyright notice,</span>
<span class="comment"> *    this list of conditions and the following disclaimer.</span>
<span class="comment"> *  * Redistributions in binary form must reproduce the above copyright</span>
<span class="comment"> *    notice, this list of conditions and the following disclaimer in the</span>
<span class="comment"> *    documentation and/or other materials provided with the distribution.</span>
<span class="comment"> *  * Neither the name of Intel Corporation nor the names of its contributors</span>
<span class="comment"> *    may be used to endorse or promote products derived from this software</span>
<span class="comment"> *    without specific prior written permission.</span>
<span class="comment"> *</span>
<span class="comment"> *  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;</span>
<span class="comment"> *  AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE</span>
<span class="comment"> *  IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE</span>
<span class="comment"> *  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE</span>
<span class="comment"> *  FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL</span>
<span class="comment"> *  DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR</span>
<span class="comment"> *  SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER</span>
<span class="comment"> *  CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,</span>
<span class="comment"> *  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE</span>
<span class="comment"> *  OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</span>
<span class="comment"> ********************************************************************************/</span>

<span class="comment">/*</span>
<span class="comment">  Showcasing ths SPMD style interface to CnC.  We&#39;ll alternate between</span>
<span class="comment">  MPI and CnC phases.  Additionally we&#39;ll let different groups of</span>
<span class="comment">  processes concurrently operate on separate CnC phases (we&#39;ll use the</span>
<span class="comment">  same context, but different instances of it).</span>
<span class="comment"></span>
<span class="comment">  This is an &quot;ariticial&quot; example, we don&#39;t really compute anything</span>
<span class="comment">  meaningful.  The MPI-phase is a simple All_to_all communication. The</span>
<span class="comment">  CnC phase prescribes a set of steps which simple take an input and</span>
<span class="comment">  produce one output.  We use the control tag as the key of the output</span>
<span class="comment">  item.  We use tag/F as the key of the input item, as tags are</span>
<span class="comment">  integers this makes F many steps depend on the same item instance.</span>
<span class="comment"> */</span>

<span class="preprocessor">#include &lt;mpi.h&gt;</span>
<span class="preprocessor">#ifdef _DIST_</span>
<span class="preprocessor"></span><span class="preprocessor">#include &lt;cnc/dist_cnc.h&gt;</span>
<span class="preprocessor">#else</span>
<span class="preprocessor"></span><span class="preprocessor">#include &lt;cnc/cnc.h&gt;</span>
<span class="preprocessor">#endif</span>
<span class="preprocessor"></span><span class="preprocessor">#include &lt;cnc/debug.h&gt;</span>

<span class="keyword">struct </span>my_context;

<span class="comment">// our simple step</span>
<span class="keyword">struct </span>MyStep
{
    <span class="keywordtype">int</span> execute( <span class="keywordtype">int</span> n, my_context &amp; c ) <span class="keyword">const</span>;
};

<span class="keyword">const</span> <span class="keywordtype">int</span> N = 480; <span class="comment">// number of step-instances, will create control tags 0-N</span>
<span class="keyword">const</span> <span class="keywordtype">int</span> F = 6;   <span class="comment">// number of steps reading the same item</span>

<span class="comment">// include the tuner, needed for testing (only)</span>
<span class="preprocessor">#include &quot;mpicnc.h&quot;</span>

<span class="comment">// The CnC context defines a trivial graph with 3 collections.</span>
<span class="comment">// Nothing specific to our MPI/CNC/SPMD combo</span>
<span class="keyword">struct </span>my_context : <span class="keyword">public</span> CnC::context&lt; my_context &gt;
{
    <a class="code" href="class_cn_c_1_1step__collection.html" title="A step collection is logical set of step instances.">CnC::step_collection&lt; MyStep, my_tuner &gt;</a> m_steps;
    <a class="code" href="class_cn_c_1_1tag__collection.html" title="A tag collection is a set of tags of the same type. It is used to prescribe steps. By default, tags are not stored.">CnC::tag_collection&lt;int&gt;</a>                 m_tags;
    <a class="code" href="class_cn_c_1_1item__collection.html" title="An item collection is a mapping from tags to items.">CnC::item_collection&lt;int, int, my_tuner&gt;</a> m_items;
    my_context() 
        : CnC::context&lt; my_context &gt;(),
          m_steps( *this ),
          m_tags( *this ),
          m_items( *this )
    {
        m_tags.<a class="code" href="class_cn_c_1_1tag__collection.html#a83f2782bc18578a2018851f0356c8b2a" title="Declare the prescription relationship between the tag collection and a step collection.">prescribes</a>( m_steps, *<span class="keyword">this</span> );
        m_steps.<a class="code" href="class_cn_c_1_1step__collection.html#aa91192651c08408d430829b6e4bca8b0" title="Declare this step-collecation as consumer of given item-collection.">consumes</a>( m_items );
        m_steps.<a class="code" href="class_cn_c_1_1step__collection.html#a7e5f64f200a66bba4228f17bfded35ca" title="Declare this step-collecation as producer for given item-collection.">produces</a>( m_items );
        <a class="code" href="struct_cn_c_1_1debug.html#a037ca57a050741fda23a61a18cac27b3" title="enable tracing of a given tag collection at a given level">CnC::debug::trace</a>( m_items );
        <span class="comment">//CnC::debug::trace_all( *this );</span>
    }
};

<span class="comment">// ok, let&#39;s get one item and put another one.</span>
<span class="comment">// we don&#39;t care what the data is.</span>
<span class="keywordtype">int</span> MyStep::execute( <span class="keywordtype">int</span> t, my_context &amp; c )<span class="keyword"> const</span>
<span class="keyword"></span>{
    <span class="keywordtype">int</span> item = 11;
    <span class="comment">// tags are integers; so t/F returns the same value for multiple values of t(ag)</span>
    <span class="keywordflow">if</span>( t ) c.m_items.get( t/F, item );
    c.m_items.put( t, t+item*item );

    <span class="keywordflow">return</span> <a class="code" href="namespace_cn_c.html#ae34016c7f648af87668a0d8115b03860" title="Steps return CNC_Success if execution was successful.">CnC::CNC_Success</a>;
}

<span class="comment">// This is our CnC phase.</span>
<span class="comment">// We instantiate the dist_cnc_init object, put a number of tags and wait.</span>
<span class="comment">// The function can be called with different parameters.  We need the</span>
<span class="comment">// communicator in any case, but of course it can be MPI_Comm_World.</span>
<span class="comment">// If dist_env is true we do it the SPMD-way: every process, not only</span>
<span class="comment">// root, executes everything. If dist_env is false only the root</span>
<span class="comment">// executes things outside the dist_cnc_init constructor.</span>
<span class="keywordtype">void</span> cnc_phase( MPI_Comm mc, <span class="keywordtype">bool</span> dist_env )
{
<span class="preprocessor">#ifdef _DIST_</span>
<span class="preprocessor"></span>    <span class="comment">// Init distribution infrastructure (RAII), most likely behaves like a barrier</span>
    <span class="comment">// if dist_env==false client processes get blocked in here forever.</span>
    <a class="code" href="struct_cn_c_1_1dist__cnc__init.html">CnC::dist_cnc_init&lt; my_context &gt;</a> dc_init( mc, dist_env );
<span class="preprocessor">#endif</span>
<span class="preprocessor"></span>
    <span class="comment">// as we provided a communicator to dc_init, all processes</span>
    <span class="comment">// continue here (by default only rank 0 gets here)</span>

    std::cout &lt;&lt; <span class="stringliteral">&quot;Let&#39;s go\n&quot;</span>;
    <span class="comment">// now let&#39;s get MPI rank etc.</span>
    <span class="keywordtype">int</span> rank = 0, numranks = 0;
    MPI_Comm_rank(mc,&amp;rank);
    MPI_Comm_size(mc,&amp;numranks);

    <span class="comment">// The environment code should be executed on rank 0 and</span>
    <span class="comment">// on all client processes of a distributed environment.</span>
    <span class="comment">// We might have more than one rank 0</span>
    <span class="comment">// if different communicators are in use.</span>
    <span class="comment">// Multiple environments are semantically tricky, combined with</span>
    <span class="comment">// CnC they make sense if the MPI phase creates distributed</span>
    <span class="comment">// data to be used by CnC. We mimic this by distributing</span>
    <span class="comment">// the control-puts across all processes of a distributed env.</span>
    <span class="keywordflow">if</span>( rank == 0 || dist_env ) {
        <span class="comment">// create the context, the runtime will distribute it under the hood</span>
        my_context c;
        <span class="comment">// dist_env requires a sync, e.g. a barrier</span>
        <span class="keywordflow">if</span>( dist_env ) MPI_Barrier( mc );
        <span class="comment">// start tag, 0 if root</span>
        <span class="keywordtype">int</span> s = rank;
        <span class="comment">// in a dist env each process puts a subset of tags</span>
        <span class="comment">// we do this by setting the loop-increment to the number</span>
        <span class="comment">// of processes in the env</span>
        <span class="keywordtype">int</span> inc = dist_env ? numranks : 1;
        <span class="comment">// Simply put all (owned) control tags</span>
        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> number = s; number &lt; N; number += inc) {
            c.m_tags.put(number);
        }
        <span class="comment">// everyone in the env waits for quiescence</span>
        c.wait();
        std::cout &lt;&lt; <span class="stringliteral">&quot;done\n&quot;</span>;
    }
    <span class="comment">// here the CnC distribution infrastructure gets shut down </span>
    <span class="comment">// when the dist_cnc_init object gets destructed (RAII)</span>
}

<span class="keywordtype">int</span> main( <span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> *argv[] )
{
    <span class="keywordtype">int</span>  numranks, rank; 
    <span class="keywordtype">int</span> p;
    MPI_Init_thread( 0, NULL, MPI_THREAD_MULTIPLE, &amp;p );
    <span class="keywordflow">if</span>( p != MPI_THREAD_MULTIPLE ) std::cerr &lt;&lt; <span class="stringliteral">&quot;Warning: not MPI_THREAD_MULTIPLE (&quot;</span> &lt;&lt; MPI_THREAD_MULTIPLE &lt;&lt; <span class="stringliteral">&quot;), but &quot;</span> &lt;&lt; p &lt;&lt; std::endl;

    MPI_Comm_size(MPI_COMM_WORLD,&amp;numranks);
    MPI_Comm_rank(MPI_COMM_WORLD,&amp;rank);

    <span class="keywordflow">if</span>( rank == 0 ) {
        system(<span class="stringliteral">&quot;ldd /home/fschlimb/cnc/trunk/distro/tests_runtime/tests-linux-intel64/distmpicnc&quot;</span>);
    }

    <span class="comment">// Let&#39;s split COMM_WORLD into 2 MPI_Comm&#39;s</span>
    MPI_Comm  newcomm;
    <span class="keywordtype">int</span> color = rank%2;
    MPI_Comm_split(MPI_COMM_WORLD, color, rank, &amp;newcomm);
    
    <span class="comment">// let&#39;s not only iterate through alternating CnC/MPI phases, but</span>
    <span class="comment">// also let 2 CnC &quot;instances&quot; work concurrently (each has its own</span>
    <span class="comment">// MPICommunicator)</span>
    <span class="keywordflow">for</span>( <span class="keywordtype">int</span> i = 0; i &lt; 2; ++i ) { <span class="comment">// you can loop as often as you like</span>
        <span class="comment">// Now let&#39;s do some CnC, all processes execute this, but on different MPI_Comm&#39;s.</span>
        <span class="comment">// One communicator is executed as a dist_env (color==0)</span>
        <span class="comment">// the other as a &quot;normal&quot; single-env on its root (color==1)</span>
        cnc_phase( newcomm, color == 1 );
        <span class="comment">// And some MPI in between</span>
        <span class="comment">// All procs do this together on MPI_COMM_WORLD</span>
        <span class="keywordtype">int</span> res;
        MPI_Allreduce(&amp;color, &amp;res, 1, MPI_INT, MPI_SUM, MPI_COMM_WORLD);
    }
    <span class="comment">// Done: collectively shut down MPI</span>
    MPI_Finalize();

    <span class="keywordflow">if</span>( rank == 0 ) std::cerr &lt;&lt; <span class="stringliteral">&quot;\n\nFinalized and out.\nThis should be the last message.\n&quot;</span>;
}
</pre></div> <h2><a class="anchor" id="matrix_inverse_distenv_code"></a>
matrix_inverse/matrix_inverse_distenv/matrix_inverse.cpp</h2>
<div class="fragment"><pre class="fragment"><span class="comment">//********************************************************************************</span>
<span class="comment">// Copyright (c) 2007-2014 Intel Corporation. All rights reserved.              **</span>
<span class="comment">//                                                                              **</span>
<span class="comment">// Redistribution and use in source and binary forms, with or without           **</span>
<span class="comment">// modification, are permitted provided that the following conditions are met:  **</span>
<span class="comment">//   * Redistributions of source code must retain the above copyright notice,   **</span>
<span class="comment">//     this list of conditions and the following disclaimer.                    **</span>
<span class="comment">//   * Redistributions in binary form must reproduce the above copyright        **</span>
<span class="comment">//     notice, this list of conditions and the following disclaimer in the      **</span>
<span class="comment">//     documentation and/or other materials provided with the distribution.     **</span>
<span class="comment">//   * Neither the name of Intel Corporation nor the names of its contributors  **</span>
<span class="comment">//     may be used to endorse or promote products derived from this software    **</span>
<span class="comment">//     without specific prior written permission.                               **</span>
<span class="comment">//                                                                              **</span>
<span class="comment">// THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS &quot;AS IS&quot;  **</span>
<span class="comment">// AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE    **</span>
<span class="comment">// IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE   **</span>
<span class="comment">// ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE     **</span>
<span class="comment">// LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR          **</span>
<span class="comment">// CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF         **</span>
<span class="comment">// SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS     **</span>
<span class="comment">// INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN      **</span>
<span class="comment">// CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)      **</span>
<span class="comment">// ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF       **</span>
<span class="comment">// THE POSSIBILITY OF SUCH DAMAGE.                                              **</span>
<span class="comment">//********************************************************************************</span>

<span class="comment">/* this version differs from the plain version</span>
<span class="comment">   - it uses smart-pointersm, which avoids data-copies and allows distributed</span>
<span class="comment">   allocation of the tile-array;</span>
<span class="comment">   performance seems to suffer a bit from this, but memory footprint is cut to half</span>
<span class="comment">   - in dist-mode, the array/matrix is generated distributedly, e.g. each</span>
<span class="comment">   process generates what it owns; input to the CnC graph is also done distributedly</span>
<span class="comment">   Mimicking SPMD-style interaction with MPI codes.</span>
<span class="comment">   Search for &quot;FOR_ME&quot; and &quot;_DIST_&quot; to look at these changes.</span>
<span class="comment">*/</span>

<span class="preprocessor">#ifdef _DIST_</span>
<span class="preprocessor"></span><span class="preprocessor">#include &lt;mpi.h&gt;</span>
<span class="preprocessor">#include &lt;cnc/dist_cnc.h&gt;</span>
<span class="preprocessor">#include &lt;cnc/internal/dist/distributor.h&gt;</span>
<span class="preprocessor">#else</span>
<span class="preprocessor"></span><span class="preprocessor">#include &lt;cnc/cnc.h&gt;</span>
<span class="preprocessor">#endif</span>
<span class="preprocessor"></span><span class="preprocessor">#include &quot;cnc/debug.h&quot;</span>

<span class="preprocessor">#include &lt;utility&gt;</span>
<span class="preprocessor">#include &lt;iostream&gt;</span>
<span class="preprocessor">#include &lt;stdio.h&gt;</span>
<span class="preprocessor">#include &lt;stdlib.h&gt;</span>
<span class="preprocessor">#include &lt;time.h&gt;</span>
<span class="preprocessor">#include &lt;math.h&gt;</span>
<span class="preprocessor">#include &lt;string.h&gt;</span>
<span class="preprocessor">#include &lt;cassert&gt;</span>
<span class="preprocessor">#include &lt;memory&gt;</span>

<span class="preprocessor">#ifdef WIN32</span>
<span class="preprocessor"></span><span class="preprocessor">#include &lt;windows.h&gt;</span>
<span class="preprocessor">#include &lt;psapi.h&gt;</span>
<span class="preprocessor">#else</span>
<span class="preprocessor"></span><span class="preprocessor">#include &lt;sys/resource.h&gt;</span>
<span class="preprocessor">#endif</span>
<span class="preprocessor"></span>
<span class="preprocessor">#include &quot;tbb/tick_count.h&quot;</span>
<span class="preprocessor">#include &quot;tbb/atomic.h&quot;</span>

<span class="preprocessor">#include &quot;../tile.h&quot;</span>

<span class="keyword">using namespace </span>CnC;


<span class="keyword">class </span>tile_array;

<span class="keyword">struct </span>tile_tag {
    <span class="keywordtype">int</span> m_i0, m_i1, m_i2, m_dim;
    
    tile_tag( <span class="keywordtype">int</span> dim, <span class="keywordtype">int</span> i0, <span class="keywordtype">int</span> i1, <span class="keywordtype">int</span> i2 ) :
        m_i0(i0), m_i1(i1), m_i2(i2), m_dim(dim) {};

    <span class="keywordtype">bool</span> operator==( <span class="keyword">const</span> tile_tag &amp; t )<span class="keyword"> const </span>{
        <span class="keywordflow">return</span> m_dim == t.m_dim &amp;&amp;
            m_i0 == t.m_i0 &amp;&amp; m_i1 == t.m_i1 &amp;&amp; m_i2 == t.m_i2;
    }
<span class="preprocessor">#ifdef _DIST_</span>
<span class="preprocessor"></span>    tile_tag()
        : m_i0( -1 ), m_i1( -1 ), m_i2( -1 ), m_dim( 0 )
    {}
    <span class="keywordtype">void</span> serialize( <a class="code" href="class_cn_c_1_1serializer.html" title="Handles serilialization of data-objects.">CnC::serializer</a> &amp; ser )
    {
        ser &amp; m_i0 &amp; m_i1 &amp; m_i2 &amp; m_dim;
    }
<span class="preprocessor">#endif</span>
<span class="preprocessor"></span>    
};


<span class="keyword">template</span> &lt;&gt;
<span class="keyword">struct </span><a class="code" href="structcnc__hash.html" title="Provides hash operators for hashing.">cnc_hash</a>&lt; tile_tag &gt; 
{
    <span class="keywordtype">size_t</span> operator()(<span class="keyword">const</span> tile_tag&amp; tt)<span class="keyword"> const</span>
<span class="keyword">    </span>{
        <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> h = (int)tt.m_dim;
        
        <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> high = h &amp; 0xf8000000;
        h = h &lt;&lt; 5;
        h = h ^ (high &gt;&gt; 27);
        h = h ^ tt.m_i0;
        
        <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> high1 = h &amp; 0xf8000000;
        h = h &lt;&lt; 5;
        h = h ^ (high1 &gt;&gt; 27);
        h = h ^ tt.m_i1;

        <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> high2 = h &amp; 0xf8000000;
        h = h &lt;&lt; 5;
        h = h ^ (high2 &gt;&gt; 27);
        h = h ^ tt.m_i2;

        <span class="keywordflow">return</span> size_t(h);
    }
};


<span class="keyword">namespace </span>std {
    std::ostream &amp; cnc_format( std::ostream&amp; os, <span class="keyword">const</span> tile_tag &amp;tt )
    {
        <span class="keywordflow">return</span> os &lt;&lt; <span class="stringliteral">&quot;(&quot;</span> &lt;&lt; tt.m_dim &lt;&lt; <span class="stringliteral">&quot;:&quot;</span>
                  &lt;&lt; tt.m_i0 &lt;&lt; <span class="stringliteral">&quot;,&quot;</span> &lt;&lt; tt.m_i1 &lt;&lt; <span class="stringliteral">&quot;,&quot;</span> &lt;&lt; tt.m_i2 &lt;&lt; <span class="stringliteral">&quot;)&quot;</span>;
    }
}

<span class="keyword">struct </span>my_context;



<span class="keyword">struct </span>compute_inverse
{
    <span class="keywordtype">int</span> execute( <span class="keyword">const</span> tile_tag &amp; t, my_context &amp; c ) <span class="keyword">const</span>;
};

<span class="comment">//#define NO_CONSUMED_ON 1</span>

<span class="keyword">struct </span>my_tuner : <span class="keyword">public</span> CnC::<a class="code" href="struct_cn_c_1_1step__tuner.html" title="Default (NOP) implementations of the step_tuner interface.">step_tuner</a>&lt;&gt;, <span class="keyword">public</span> CnC::<a class="code" href="struct_cn_c_1_1hashmap__tuner.html" title="The tuner base for hashmap-based item-tuners.">hashmap_tuner</a>
{
    <span class="keyword">typedef</span> tile_tag tag_type;

    <span class="keywordtype">int</span> PROC_FOR_TILE( <span class="keywordtype">int</span> _x, <span class="keywordtype">int</span> _y )<span class="keyword"> const </span>{ <span class="keywordflow">return</span> ( ( ( ( (_y) * m_tnx + 31 ) + (_x) ) ) % m_nP ); }
    <span class="keywordtype">int</span> COMPUTE_ON( <span class="keywordtype">int</span> _i, <span class="keywordtype">int</span> _j )<span class="keyword">    const </span>{ <span class="keywordflow">return</span> ( PROC_FOR_TILE( (_i) / m_tsx, (_j) / m_tsy ) ); }

    <span class="keyword">template</span>&lt; <span class="keyword">class</span> dependency_consumer &gt;
    <span class="keywordtype">void</span> depends( <span class="keyword">const</span> tile_tag &amp; tag, my_context &amp; c, dependency_consumer &amp; dC ) <span class="keyword">const</span>;
    my_tuner( <span class="keywordtype">int</span> ntiles = 0 );
    <span class="keywordtype">int</span> compute_on( <span class="keyword">const</span> tile_tag &amp; tag, my_context &amp; ) <span class="keyword">const</span>;

    <span class="keywordtype">int</span> get_count( <span class="keyword">const</span> tag_type &amp; tag ) <span class="keyword">const</span>;
<span class="preprocessor">#ifdef NO_CONSUMED_ON</span>
<span class="preprocessor"></span>    <span class="keywordtype">int</span> consumed_on( <span class="keyword">const</span> tag_type &amp; tag )<span class="keyword"> const </span>{ <span class="keywordflow">return</span> <a class="code" href="namespace_cn_c.html#a06fc87d81c62e9abb8790b6e5713c55ba4e54235189ce408ee733a5a9d9e0d386" title="consumer process of given item is unkown">CnC::CONSUMER_UNKNOWN</a>; }
<span class="preprocessor">#else</span>
<span class="preprocessor"></span>    <span class="keyword">const</span> std::vector&lt; int &gt; &amp; consumed_on( <span class="keyword">const</span> tile_tag &amp; tag ) <span class="keyword">const</span>;
<span class="preprocessor">#endif</span>
<span class="preprocessor"></span>    <span class="keywordtype">int</span> produced_on( <span class="keyword">const</span> tile_tag &amp; tag ) <span class="keyword">const</span>;
    <span class="keywordtype">int</span> m_nP;
    <span class="keywordtype">int</span> m_tnx, m_tny, m_tsx, m_tsy;
    std::vector&lt; std::vector&lt; int &gt; &gt; m_rows, m_cols, m_rowcols, m_procs;
    std::vector&lt; int &gt; m_all;
    <span class="keywordtype">void</span> serialize( <a class="code" href="class_cn_c_1_1serializer.html" title="Handles serilialization of data-objects.">CnC::serializer</a> &amp; ser ) 
    {
        ser &amp; m_nP &amp; m_tnx &amp; m_tny &amp; m_tsx &amp; m_tsy
            &amp; m_rows &amp; m_cols &amp; m_rowcols &amp; m_procs &amp; m_all;
        assert( m_nP &gt; 0 &amp;&amp; m_nP == (<span class="keywordtype">int</span>)m_procs.size() );
    }
};


<span class="keyword">typedef</span> std::shared_ptr&lt; const tile &gt; const_tile_type;
<span class="keyword">typedef</span> std::shared_ptr&lt; tile &gt; tile_type;

              
<span class="keyword">struct </span>my_context : <span class="keyword">public</span> CnC::<a class="code" href="class_cn_c_1_1context.html" title="CnC context bringing together collections (for steps, items and tags).">context</a>&lt; my_context &gt;
{
    my_tuner m_tuner;
    <a class="code" href="class_cn_c_1_1step__collection.html" title="A step collection is logical set of step instances.">CnC::step_collection&lt; compute_inverse, my_tuner &gt;</a> m_steps;
    <a class="code" href="class_cn_c_1_1item__collection.html" title="An item collection is a mapping from tags to items.">CnC::item_collection&lt; tile_tag, const_tile_type, my_tuner &gt;</a>  m_tiles;
    <a class="code" href="class_cn_c_1_1tag__collection.html" title="A tag collection is a set of tags of the same type. It is used to prescribe steps. By default, tags are not stored.">CnC::tag_collection&lt; tile_tag &gt;</a> m_tags;

    my_context( <span class="keywordtype">int</span> nt = 0 )
        : CnC::<a class="code" href="class_cn_c_1_1context.html" title="CnC context bringing together collections (for steps, items and tags).">context</a>&lt; my_context &gt;(),
          m_tuner( nt ),
          m_steps( *this, <span class="stringliteral">&quot;mi&quot;</span>, compute_inverse(), m_tuner ),
          m_tiles( *this, m_tuner ),
          m_tags( *this )
    {
        m_tags.<a class="code" href="class_cn_c_1_1tag__collection.html#a83f2782bc18578a2018851f0356c8b2a" title="Declare the prescription relationship between the tag collection and a step collection.">prescribes</a>( m_steps, *<span class="keyword">this</span> );
<span class="preprocessor">#if 0</span>
<span class="preprocessor"></span>        <a class="code" href="struct_cn_c_1_1debug.html#a037ca57a050741fda23a61a18cac27b3" title="enable tracing of a given tag collection at a given level">CnC::debug::trace</a>( m_tiles, 3 );
        <span class="comment">//        CnC::debug::trace( m_tags, 3 );</span>
        <span class="comment">//        CnC::debug::trace( m_steps, 3 );</span>
<span class="preprocessor">#endif        </span>
<span class="preprocessor"></span>        <a class="code" href="struct_cn_c_1_1debug.html#af8de6416eab708937bbd263a4a17719a" title="enable collection scheduler statistics per context">CnC::debug::collect_scheduler_statistics</a>(*<span class="keyword">this</span>);
    }

    <span class="keyword">virtual</span> <span class="keywordtype">void</span> serialize( <a class="code" href="class_cn_c_1_1serializer.html" title="Handles serilialization of data-objects.">CnC::serializer</a> &amp; ser ) 
    {
        ser &amp; m_tuner;
    }
};


<span class="preprocessor">#ifdef _DIST_</span>
<span class="preprocessor"></span><span class="comment">// returns if the given tile (x,y) is owned by my (r)</span>
<span class="preprocessor">#  define FOR_ME( _c, _r, _x, _y ) ((_r) == _c.m_tuner.COMPUTE_ON( _x, _y ))</span>
<span class="preprocessor"></span><span class="comment">// returns if the given tile (x,y) is owned by my (r)m always true if r==0</span>
<span class="preprocessor">#  define FOR_ME_OR_0( _c, _r, _x, _y ) (((_r)==0) || FOR_ME( _c, _r, _x, _y ))</span>
<span class="preprocessor"></span><span class="preprocessor">#else</span>
<span class="preprocessor"></span><span class="preprocessor">#  define FOR_ME( _c, _r, _x, _y ) true</span>
<span class="preprocessor"></span><span class="preprocessor">#  define FOR_ME_OR_0( _c, _r, _x, _y ) true</span>
<span class="preprocessor"></span><span class="preprocessor">#endif</span>
<span class="preprocessor"></span>

<span class="keyword">class </span>tile_array
{
    <span class="keywordtype">int</span> m_dim;
    <span class="keywordtype">int</span> m_size;
    const_tile_type * m_tiles;
    
<span class="keyword">public</span>:

    <span class="keywordtype">int</span> dim()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> m_dim; }
    <span class="keywordtype">int</span> size()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> m_size; }

    tile_array( <span class="keywordtype">int</span> size = 0 ) :
        m_dim((size + TILESIZE - 1)/TILESIZE), <span class="comment">// Size/TILESIZE rounded up</span>
        m_size(size), 
        m_tiles( NULL )
    {
        <span class="keywordflow">if</span>( m_dim ) m_tiles = <span class="keyword">new</span> const_tile_type[m_dim*m_dim];
    }
    
    ~tile_array()
    {
        <span class="keyword">delete</span>[] m_tiles;
    }

    tile_array(<span class="keyword">const</span> tile_array&amp; t)
    {
        m_size = t.m_size;
        m_dim = t.m_dim;
        <span class="keywordtype">int</span> sz = m_dim*m_dim;
        m_tiles = <span class="keyword">new</span> const_tile_type[sz];
        <span class="keywordflow">for</span>( <span class="keywordtype">int</span> i = 0; i &lt; sz; ++i ) {
            m_tiles[i] = t.m_tiles[i];
        }
    }
    
    tile_array&amp; operator=(<span class="keyword">const</span> tile_array&amp; t)
    {
        <span class="keywordflow">if</span> (<span class="keyword">this</span> != &amp;t) {
            <span class="keywordtype">int</span> sz = t.m_dim*t.m_dim;
            <span class="keywordflow">if</span>( m_dim != t.m_dim ) {
                <span class="keyword">delete</span>[] m_tiles;
                m_tiles = <span class="keyword">new</span> const_tile_type[sz];
                m_size = t.m_size;
                m_dim = t.m_dim;
            }
            <span class="keywordflow">for</span>( <span class="keywordtype">int</span> i = 0; i &lt; sz; ++i ) {
                m_tiles[i] = t.m_tiles[i];
            }
        }
        <span class="keywordflow">return</span> *<span class="keyword">this</span>;
    }
    
    <span class="keywordtype">void</span> dump( <span class="keywordtype">double</span> epsilon = 1e-12 )<span class="keyword"> const </span>{
        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; m_dim; i++ ) {
            <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = 0; j &lt; m_dim; j++ ) {
                std::cout &lt;&lt; <span class="stringliteral">&quot;(&quot;</span> &lt;&lt; i &lt;&lt; <span class="stringliteral">&quot;,&quot;</span> &lt;&lt; j &lt;&lt; <span class="stringliteral">&quot;)&quot;</span> &lt;&lt; std::endl;
                m_tiles[m_dim*i+j]-&gt;dump(epsilon);
            }
            std::cout &lt;&lt; std::endl;
        }
    }

    <span class="keywordtype">int</span> generate_matrix( <span class="keywordtype">int</span> dimension, my_context &amp; c  )
    {
<span class="preprocessor">#ifdef _DIST_</span>
<span class="preprocessor"></span>        <span class="comment">// need rank determine owned fraction of the matrix (FOR_ME)</span>
        <span class="keywordtype">int</span> rank;
        MPI_Comm_rank(MPI_COMM_WORLD,&amp;rank);
<span class="preprocessor">#endif</span>
<span class="preprocessor"></span>        
        printf(<span class="stringliteral">&quot;Floating point elements per matrix: %i x %i\n&quot;</span>, dimension, dimension);
        printf(<span class="stringliteral">&quot;Floating point elements per tile: %i x %i\n&quot;</span>, TILESIZE, TILESIZE);

        <span class="keywordflow">if</span>( m_size != dimension ) {
            <span class="keyword">delete</span>[] m_tiles;
            m_size = dimension;
            m_dim = (m_size + TILESIZE - 1)/TILESIZE; <span class="comment">// Size/TILESIZE rounded up</span>
            m_tiles = <span class="keyword">new</span> const_tile_type[m_dim*m_dim];
        }

        printf(<span class="stringliteral">&quot;tiles per matrix: %i x %i\n&quot;</span>, m_dim, m_dim);
        <span class="keywordtype">int</span> dim = m_dim;
        <span class="keywordtype">int</span> size = m_size;

        std::cout &lt;&lt; <span class="stringliteral">&quot;dim(&quot;</span> &lt;&lt; dim &lt;&lt; <span class="stringliteral">&quot;) size(&quot;</span> &lt;&lt; size &lt;&lt; <span class="stringliteral">&quot;)&quot;</span> &lt;&lt; std::endl;
        <span class="keywordtype">double</span> e = 0.0;
        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> I = 0; I &lt; dim; I++) {
            <span class="keywordflow">for</span> (<span class="keywordtype">int</span> J = 0; J &lt; dim; J++) {
                <span class="keywordflow">if</span>( FOR_ME_OR_0( c, rank, I, J ) ) { <span class="comment">// for the identity check we need the entire matrix on 0</span>
                    srand( I*m_dim+J );
                    <span class="keywordtype">int</span> ii = I * TILESIZE;;
                    tile_type _tile = std::make_shared&lt; tile &gt;();
                    <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; TILESIZE; i++) {
                        <span class="keywordtype">int</span> jj = J * TILESIZE;
                        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = 0; j &lt; TILESIZE; j++) {
                            <span class="keywordflow">if</span> ((ii &lt; size)&amp;(jj &lt; size)) e = double(rand())/RAND_MAX;
                            <span class="keywordflow">else</span> <span class="keywordflow">if</span> (ii == jj) e = 1; <span class="comment">// On-diagonal padding</span>
                            <span class="keywordflow">else</span> e = 0; <span class="comment">// Off-diagonal padding</span>
                            <span class="comment">//                        std::cout &lt;&lt; &quot;m[&quot; &lt;&lt; ii &lt;&lt; &quot;,&quot; &lt;&lt; jj &lt;&lt; &quot;(&quot; &lt;&lt; I &lt;&lt; &quot;,&quot; &lt;&lt; J &lt;&lt; &quot;,&quot; &lt;&lt; i &lt;&lt; &quot;,&quot; &lt;&lt; j &lt;&lt; &quot;)]=&quot; &lt;&lt; e &lt;&lt; std::endl;</span>
                            _tile-&gt;set(i,j,e);
                            jj++;
                        }
                        ii++;
                    }
                    <span class="comment">//                    std::cerr &lt;&lt; rank &lt;&lt; &quot; generated tile &quot; &lt;&lt; I &lt;&lt; &quot;,&quot; &lt;&lt; J &lt;&lt; std::endl;</span>
                    m_tiles[dim*I + J] = _tile;
                }
            }
        }
        <span class="keywordflow">return</span> m_dim;
    }
    
    
    <span class="keywordtype">int</span> identity_check( <span class="keywordtype">double</span> epsilon = MINPIVOT )<span class="keyword"> const</span>
<span class="keyword">    </span>{
        <span class="keywordtype">int</span> ecount = 0;
        
        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; m_dim; i++ ) {
            <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = 0; j &lt; m_dim; j++ ) {
                <span class="keywordtype">int</span> tcount = 0;
                const_tile_type t = m_tiles[m_dim*i+j];

                tcount = (i == j) ?  t-&gt;identity_check(epsilon) : t-&gt;zero_check(epsilon);                
                <span class="keywordflow">if</span> (tcount == 0 ) <span class="keywordflow">continue</span>;
                
                std::cout &lt;&lt; <span class="stringliteral">&quot;problem in tile(&quot;</span> &lt;&lt; i &lt;&lt; <span class="stringliteral">&quot;,&quot;</span> &lt;&lt; j &lt;&lt; <span class="stringliteral">&quot;)&quot;</span> &lt;&lt; std::endl;
                ecount += tcount;
            }
        }
        <span class="keywordflow">return</span> ecount;
    }
    
    <span class="keywordtype">bool</span> equal( <span class="keyword">const</span> tile_array &amp;b )<span class="keyword"> const</span>
<span class="keyword">    </span>{
        <span class="keywordflow">if</span> (b.m_dim != m_dim) <span class="keywordflow">return</span> <span class="keyword">false</span>;
        
        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; m_dim; i++ ) {
            <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = 0; j &lt; m_dim; j++ ) {
                const_tile_type t = m_tiles[m_dim*i+j];
                <span class="keywordflow">if</span> (!t-&gt;equal( *b.m_tiles[m_dim*i+j] )) <span class="keywordflow">return</span> <span class="keyword">false</span>;
            }
        }
        <span class="keywordflow">return</span> <span class="keyword">true</span>;
    }
    
    <span class="comment">// c = this * b</span>
    tile_array multiply(<span class="keyword">const</span> tile_array &amp;b)<span class="keyword"> const</span>
<span class="keyword">    </span>{
        tile_array c(m_size);
        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; m_dim; i++) {
            <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = 0; j &lt; m_dim; j++) {
                tile_type t = std::make_shared&lt; tile &gt;();
                t-&gt;zero();
                <span class="keywordflow">for</span> (<span class="keywordtype">int</span> k = 0; k &lt; m_dim; k++) {
                    t-&gt;multiply_add_in_place(*m_tiles[m_dim*i+k], *b.m_tiles[m_dim*k+j]);
                }
                c.m_tiles[m_dim*i+j] = t;
            }
        }
        <span class="keywordflow">return</span> c;
    }


    tile_array inverse()
    {
        tile_array b = *<span class="keyword">this</span>;
        <span class="keywordtype">int</span> dim = m_dim;

        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> n = 0; n &lt; dim; n++) {
            const_tile_type pivot_inverse = std::make_shared&lt; const tile &gt;( C_INVERSE, *b.m_tiles[dim*n+n] );
            b.m_tiles[dim*n+n] = pivot_inverse;
    
            <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = 0; j &lt; dim; j++) {
                <span class="keywordflow">if</span> (j == n) <span class="keywordflow">continue</span>;
            
                <span class="keyword">const</span> tile&amp; tnj = *b.m_tiles[dim*n+j];
                b.m_tiles[dim*n+j] = std::make_shared&lt; const tile &gt;( C_MULTIPLY, *pivot_inverse, tnj );
            }
        
            <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; dim; i++) {
                <span class="keywordflow">if</span> (i == n) <span class="keywordflow">continue</span>;

                const_tile_type tin = b.m_tiles[dim*i+n];
                b.m_tiles[dim*i+n] = std::make_shared&lt; const tile &gt;( C_MULTIPLY_NEGATE, *tin, *pivot_inverse );
                
                <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = 0; j &lt; dim; j++) {
                    <span class="keywordflow">if</span> (j == n) <span class="keywordflow">continue</span>;
                    const_tile_type tnj = b.m_tiles[dim*n+j];
                    tile_type tmp = std::make_shared&lt; tile &gt;( *b.m_tiles[dim*i+j] );
                    tmp-&gt;multiply_subtract_in_place(*tin, *tnj);
                    b.m_tiles[dim*i+j] = tmp;
                }
            }
        }
        <span class="keywordflow">return</span> b;
    }


    tile_array inverse_cnc( my_context &amp; c )
    {
        <span class="comment">// all participating processes execute this</span>
        <span class="keywordtype">int</span> rank = 0;
<span class="preprocessor">#ifdef _DIST_</span>
<span class="preprocessor"></span>        <span class="comment">// need rank determine owned fraction of the matrix (FOR_ME)</span>
        MPI_Comm_rank(MPI_COMM_WORLD,&amp;rank);
<span class="preprocessor">#endif</span>
<span class="preprocessor"></span>        <span class="comment">// copy what process owns from local array to item-collection</span>
        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; m_dim; i++) {
            <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = 0; j &lt; m_dim; j++) <span class="keywordflow">if</span>( FOR_ME( c, rank, i, j ) ) {
                    tile_tag t( m_dim, 0, i, j);
                    c.m_tiles.put( t, m_tiles[m_dim*i+j] );
                    assert( m_tiles[m_dim*i+j].<span class="keyword">get</span>() );
                }
        }
        <span class="comment">// put control tags (only what this process is reponsible for)</span>
        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; m_dim; i++) {
            <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = 0; j &lt; m_dim; j++) <span class="keywordflow">if</span>( FOR_ME( c, rank, i, j ) ) {
                    c.m_tags.put( tile_tag( m_dim, 0, i, j) );
                }
        }

        <span class="comment">// &quot;wait&quot; is an implicit barrier,</span>
        <span class="comment">// no process returns until entire dsitributed graph evaluation reached quiesence</span>
        c.wait();

        <span class="comment">// now write back data from item-collection to local arry</span>
        tile_array b(m_size);
        <span class="comment">//        c.m_tiles.size(); // not dist-env-ready</span>
        <span class="keywordflow">for</span> (<span class="keywordtype">int</span> i = 0; i &lt; m_dim; i++) {
            <span class="keywordflow">for</span> (<span class="keywordtype">int</span> j = 0; j &lt; m_dim; j++) <span class="keywordflow">if</span>( FOR_ME_OR_0( c, rank, i, j ) ) {<span class="comment">// we need all output on rank 0 for verification</span>
                    const_tile_type _tmp;
                    c.m_tiles.get( tile_tag( m_dim, m_dim, i, j), _tmp );
                    b.m_tiles[m_dim*i+j] = _tmp;
                }
        }
        <span class="keywordflow">return</span> b;
    }
};
    

<span class="keywordtype">int</span> compute_inverse::execute( <span class="keyword">const</span> tile_tag &amp; tag, my_context &amp; c )<span class="keyword"> const</span>
<span class="keyword"></span>{
    <span class="keywordtype">int</span> n = tag.m_i0;
    <span class="keywordtype">int</span> i = tag.m_i1;
    <span class="keywordtype">int</span> j = tag.m_i2;

    tile_tag out_tag( tag.m_dim, n+1, i, j );

    <span class="keywordflow">if</span> (i == n &amp;&amp; j == n ) 
        {
            const_tile_type tnn;
            c.m_tiles.get( tag, tnn );
            <span class="comment">//        tile out_nij = tnn.inverse();</span>
            c.m_tiles.put( out_tag, std::make_shared&lt; const tile &gt;( C_INVERSE, *tnn ) );<span class="comment">//out_nij );</span>
        }
    <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( i == n ) 
        {
            const_tile_type tnj;
            c.m_tiles.get( tag, tnj );
            assert( tnj.get() );
            const_tile_type tn1nn;
            c.m_tiles.get( tile_tag( tag.m_dim, n+1, n, n ), tn1nn );
            <span class="comment">//        tile out_nij = tn1nn.multiply(tnj);</span>
            c.m_tiles.put( out_tag, std::make_shared&lt; const tile &gt;( C_MULTIPLY, *tn1nn, *tnj ) );
        }
    <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( j == n ) 
        {
            const_tile_type tin;
            c.m_tiles.get( tag, tin );
            const_tile_type tn1nn;
            c.m_tiles.get( tile_tag( tag.m_dim, n+1, n, n ), tn1nn );
            <span class="comment">//        tile out_nij = tin.multiply_negate(tn1nn);</span>
            c.m_tiles.put( out_tag, std::make_shared&lt; const tile &gt;( C_MULTIPLY_NEGATE, *tin, *tn1nn ) );<span class="comment">//out_nij );</span>
        }
    <span class="keywordflow">else</span> 
        {
            const_tile_type tij;
            c.m_tiles.get( tag, tij );
            const_tile_type tnin;
            c.m_tiles.get( tile_tag( tag.m_dim, n, i, n ), tnin );
            const_tile_type tn1nj;
            c.m_tiles.get( tile_tag( tag.m_dim, n+1, n, j ), tn1nj );
            tile_type tmp = std::make_shared&lt; tile &gt;( *tij );
            tmp-&gt;multiply_subtract_in_place( *tnin, *tn1nj );
            assert( tmp.get() );
            c.m_tiles.put( out_tag, tmp );
            <span class="comment">//        tile out_nij = tij.multiply_subtract( tnin, tn1nj );</span>
            <span class="comment">//        b.m_tiles[dim*i+j] = tmp;</span>
            <span class="comment">//        c.m_tiles.put( out_tag, std::make_shared&lt; const tile &gt;( tij-&gt;multiply_subtract( *tnin, *tn1nj) ) );//out_nij );</span>
        }
    
    <span class="keywordflow">if</span> ( (n+1) &lt; tag.m_dim ) 
        {
            c.m_tags.put( out_tag );
        }
    <span class="keywordflow">return</span> <a class="code" href="namespace_cn_c.html#ae34016c7f648af87668a0d8115b03860" title="Steps return CNC_Success if execution was successful.">CnC::CNC_Success</a>;
}

<span class="keywordtype">int</span> my_tuner::get_count( <span class="keyword">const</span> tag_type &amp; tt )<span class="keyword"> const</span>
<span class="keyword"></span>{
    <span class="keywordtype">int</span> dim = tt.m_dim;
    <span class="keywordtype">int</span> n = tt.m_i0;
    <span class="keywordflow">if</span>( dim == n ) <span class="keywordflow">return</span> <a class="code" href="namespace_cn_c.html#a06fc87d81c62e9abb8790b6e5713c55ba2e499248088579f87f684676c9ebac27" title="no get-count specified">CnC::NO_GETCOUNT</a>;
    <span class="keywordtype">int</span> i = tt.m_i1;
    <span class="keywordtype">int</span> j = tt.m_i2;
    
    <span class="keywordtype">int</span> count = 1;

    <span class="keywordflow">if</span> (i == (n-1) &amp;&amp; j == (n-1)) count += (dim-1) + (dim-1);
    <span class="keywordflow">if</span> (i == (n-1) &amp;&amp; !(j == n-1)) count += dim-1;
    <span class="keywordflow">if</span> (j == n  &amp;&amp; !(i == n)) count += dim-1;

    <span class="keywordflow">return</span> count;
}


my_tuner::my_tuner( <span class="keywordtype">int</span> ntiles )
    : m_tnx( 0 ),
      m_tny( 0 ),
      m_tsx( 1 ),
      m_tsy( 1 ),
      m_rows(),
      m_cols(),
      m_rowcols(),
      m_procs(),
      m_all( 1, CnC::<a class="code" href="namespace_cn_c.html#a06fc87d81c62e9abb8790b6e5713c55bacb8c5ed4d3811219521bd6e8a1c5adbc" title="all processes consume given item">CONSUMER_ALL</a> )
{
    m_nP = numProcs();
<span class="preprocessor">#ifdef _DIST_</span>
<span class="preprocessor"></span>    <span class="keywordtype">int</span> _np = m_nP * 1;
    assert( _np == 1 || ( ntiles * ntiles ) % _np == 0 );
    <span class="keywordflow">if</span>( _np &gt; 1 &amp;&amp; ntiles ) { 
        <span class="comment">// compute grid dimension for partitioning</span>
        m_tnx = 2, m_tny = _np / 2;
        <span class="keywordflow">while</span>( m_tnx &lt; m_tny &amp;&amp; m_tny % 2 == 0 ) {
            m_tnx *= 2;
            m_tny = _np / m_tnx;
        }
        assert( m_tnx * m_tny == _np );
        m_tsx = ntiles / m_tnx;
        m_tsy = ntiles / m_tny;
        std::cerr &lt;&lt; m_tnx &lt;&lt; <span class="stringliteral">&quot;x&quot;</span> &lt;&lt; m_tny &lt;&lt; <span class="stringliteral">&quot; tiles of &quot;</span> &lt;&lt; m_tsx &lt;&lt; <span class="stringliteral">&quot;x&quot;</span> &lt;&lt; m_tsy &lt;&lt; std::endl;
        assert( m_tnx * m_tsx == ntiles &amp;&amp; m_tny * m_tsy == ntiles );
<span class="preprocessor">#ifndef NO_CONSUMED_ON</span>
<span class="preprocessor"></span>        <span class="comment">// setup vectors to store info for consumed_on</span>
        m_rows.resize( m_tny );
        m_cols.resize( m_tnx );
        m_rowcols.resize( m_tnx * m_tny );
        <span class="keywordflow">for</span>( <span class="keywordtype">int</span> i = 0; i &lt; m_tnx; ++i ) {
            m_cols[i].resize( m_tny );
            <span class="keywordflow">for</span>( <span class="keywordtype">int</span> j = 0; j &lt; m_tny; ++j ) {
                m_rowcols[j*m_tnx+i].resize( m_tnx+m_tny );
            }
        }
        <span class="keywordflow">for</span>( <span class="keywordtype">int</span> j = 0; j &lt; m_tny; ++j ) {
            m_rows[j].resize( m_tnx );
            <span class="keywordflow">for</span>( <span class="keywordtype">int</span> i = 0; i &lt; m_tnx; ++i ) {
                m_rows[j][i] = m_cols[i][j] = PROC_FOR_TILE( i, j );
                <span class="keywordflow">for</span>( <span class="keywordtype">int</span> x = 0; x &lt; m_tnx; ++x ) m_rowcols[j*m_tnx+i][x] = PROC_FOR_TILE( x, j );
                <span class="keywordflow">for</span>( <span class="keywordtype">int</span> y = 0; y &lt; m_tny; ++y ) m_rowcols[j*m_tnx+i][m_tnx+y] = PROC_FOR_TILE( i, y );
                m_rowcols[j*m_tnx+i][i] = m_rowcols[j*m_tnx+i].back();
                m_rowcols[j*m_tnx+i].pop_back();
            }
        }
        m_procs.resize( m_nP );
        <span class="keywordflow">for</span>( <span class="keywordtype">int</span> i = 0; i &lt; m_nP; ++i ) m_procs[i].<a class="code" href="class_cn_c_1_1serializer.html#ad9ae777b4574ea7e54d974251cc822d1" title="(Re)allocates a buffer of the given size.">resize</a>( 1, i );
        assert( m_nP &gt; 0 &amp;&amp; (<span class="keywordtype">int</span>)m_procs.size() == m_nP );
<span class="preprocessor">#endif</span>
<span class="preprocessor"></span>    }
<span class="preprocessor">#endif</span>
<span class="preprocessor"></span>}

<span class="keywordtype">int</span> my_tuner::compute_on( <span class="keyword">const</span> tile_tag &amp; tag, my_context &amp; )<span class="keyword"> const</span>
<span class="keyword"></span>{
    <span class="keywordflow">return</span> COMPUTE_ON( tag.m_i1, tag.m_i2 );
}

<span class="keywordtype">int</span> my_tuner::produced_on( <span class="keyword">const</span> tile_tag &amp; tag )<span class="keyword"> const</span>
<span class="keyword"></span>{
    <span class="keywordflow">return</span> ( tag.m_i0 &gt; 0 ? COMPUTE_ON( tag.m_i1, tag.m_i2 ) : 0 );
}

<span class="keyword">template</span>&lt; <span class="keyword">class</span> dependency_consumer &gt;
<span class="keywordtype">void</span> my_tuner::depends( <span class="keyword">const</span> tile_tag &amp; tag, my_context &amp; c, dependency_consumer &amp; dC )<span class="keyword"> const</span>
<span class="keyword"></span>{
    <span class="keywordtype">int</span> n = tag.m_i0;
    <span class="keywordtype">int</span> i = tag.m_i1;
    <span class="keywordtype">int</span> j = tag.m_i2;

    dC.depends( c.m_tiles, tag ); <span class="comment">//, PROD( tag.m_dim, n-1, i, j ) );</span>
    
    <span class="keywordflow">if</span> (i == n &amp;&amp; j == n ) {
    } <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( i == n ) {
        dC.depends( c.m_tiles, tile_tag( tag.m_dim, n+1, n, n ) );
    } <span class="keywordflow">else</span> <span class="keywordflow">if</span> ( j == n ) {
        dC.depends( c.m_tiles, tile_tag( tag.m_dim, n+1, n, n ) );
    } <span class="keywordflow">else</span> {
        dC.depends( c.m_tiles, tile_tag( tag.m_dim, n, i, n ) );
        dC.depends( c.m_tiles, tile_tag( tag.m_dim, n+1, n, j ) );
    }
}

<span class="preprocessor">#ifndef NO_CONSUMED_ON</span>
<span class="preprocessor"></span><span class="keyword">const</span> std::vector&lt; int &gt; &amp; my_tuner::consumed_on( <span class="keyword">const</span> tile_tag &amp; tag )<span class="keyword"> const</span>
<span class="keyword"></span>{
    assert( 0 &lt; m_procs.size() );
    <span class="keywordtype">int</span> n = tag.m_i0;
    <span class="keywordtype">int</span> i = tag.m_i1;
    <span class="keywordtype">int</span> j = tag.m_i2;
    
    <span class="keywordflow">if</span>( n - 1 == i &amp;&amp; ( i == j || n == j ) ) {
        <span class="keywordflow">return</span> m_rowcols[(j/m_tsy)*m_tnx+(i/m_tsx)];
    } <span class="keywordflow">else</span> <span class="keywordflow">if</span>( n - 1 == i ) {
        <span class="keywordflow">return</span> m_rows[j/m_tsy];
    } <span class="keywordflow">else</span> <span class="keywordflow">if</span>( n == j ) {
        <span class="keywordflow">return</span> m_cols[i/m_tsx];
    }
    <span class="keywordflow">return</span> m_procs[COMPUTE_ON( i, j )]; 
}
<span class="preprocessor">#endif</span>
<span class="preprocessor"></span>
<span class="keywordtype">void</span> report_memory()
{
    std:: cout &lt;&lt; <span class="stringliteral">&quot;tiles created &quot;</span> &lt;&lt; tiles_created &lt;&lt; <span class="stringliteral">&quot; tiles deleted &quot;</span> &lt;&lt; tiles_deleted &lt;&lt; <span class="stringliteral">&quot; tiles remaining &quot;</span> &lt;&lt; tiles_created - tiles_deleted &lt;&lt; std::endl;
    tiles_created = 0;
    tiles_deleted = 0;

    <span class="keyword">static</span> <span class="keywordtype">int</span> lastr = 0;

<span class="preprocessor">#ifdef WIN32</span>
<span class="preprocessor"></span>    HANDLE <span class="keyword">self</span>;
    PROCESS_MEMORY_COUNTERS pmc;
    SIZE_T resident = 0;
    <span class="keyword">self</span> = GetCurrentProcess();
    <span class="keywordflow">if</span> (GetProcessMemoryInfo(<span class="keyword">self</span>, &amp;pmc, <span class="keyword">sizeof</span>(pmc))) {
        resident = pmc.WorkingSetSize;
    }
    CloseHandle(<span class="keyword">self</span>);
<span class="preprocessor">#else</span>
<span class="preprocessor"></span>    FILE *f = fopen(<span class="stringliteral">&quot;/proc/self/statm&quot;</span>, <span class="stringliteral">&quot;r&quot;</span>);
    <span class="keywordtype">int</span> total, resident, share, trs, drs, lrs, dt;
    <span class="keywordflow">if</span>( fscanf(f,<span class="stringliteral">&quot;%d %d %d %d %d %d %d&quot;</span>, &amp;total, &amp;resident, &amp;share, &amp;trs, &amp;drs, &amp;lrs, &amp;dt) != 7 ) std::cerr &lt;&lt; <span class="stringliteral">&quot;error reading /proc/self/statm\n&quot;</span>;
<span class="preprocessor">#endif</span>
<span class="preprocessor"></span>
    std:: cout &lt;&lt; <span class="stringliteral">&quot;resident memory MB &quot;</span> &lt;&lt; double(resident*4096)/1000000 &lt;&lt; <span class="stringliteral">&quot;   increment MB &quot;</span> &lt;&lt; double((resident-lastr)*4096)/1000000 &lt;&lt; std::endl;
    lastr = resident;
}


<span class="keywordtype">void</span> report_time( <span class="keyword">const</span> <span class="keywordtype">char</span> * mode, <span class="keywordtype">int</span> msz, <span class="keywordtype">double</span> time ) 
{
    std::cout &lt;&lt;  mode &lt;&lt; <span class="stringliteral">&quot; Total Time: &quot;</span> &lt;&lt; time &lt;&lt; <span class="stringliteral">&quot; sec&quot;</span> &lt;&lt; std::endl;
    <span class="keywordtype">float</span> Gflops = ((float)2*msz*msz*msz)/((float)1000000000);
    <span class="keywordflow">if</span> (Gflops &gt;= .000001) printf(<span class="stringliteral">&quot;Floating-point operations executed: %f billion\n&quot;</span>, Gflops);
    <span class="keywordflow">if</span> (time &gt;= .001) printf(<span class="stringliteral">&quot;Floating-point operations executed per unit time: %6.2f billions/sec\n&quot;</span>, Gflops/time);
}
    


<span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> *argv[])
{
    <span class="keywordflow">if</span> (!(argc == 2 &amp;&amp; 0 != atoi(argv[1]))) {
        std::cout &lt;&lt; <span class="stringliteral">&quot;Usage: matrix_inverse dim&quot;</span> &lt;&lt; std::endl;
        <span class="keywordflow">return</span> -1;
    }

    <span class="keywordtype">int</span> sz = atoi(argv[1]);
    <span class="keywordtype">int</span> tdim = (sz + TILESIZE - 1)/TILESIZE;

<span class="preprocessor">#ifdef _DIST_</span>
<span class="preprocessor"></span>    <span class="comment">// init MPI to mimick SPMD-style interactino with CnC through MPI</span>
    <span class="keywordtype">int</span> p;<span class="comment"></span>
<span class="comment">    //!! FIXME passing NULL ptr breaks mvapich1 mpi implementation</span>
<span class="comment"></span>    MPI_Init_thread( 0, NULL, MPI_THREAD_MULTIPLE, &amp;p );
    <span class="keywordflow">if</span>( p != MPI_THREAD_MULTIPLE ) std::cerr &lt;&lt; <span class="stringliteral">&quot;Warning: not MPI_THREAD_MULTIPLE (&quot;</span> &lt;&lt; MPI_THREAD_MULTIPLE &lt;&lt; <span class="stringliteral">&quot;), but &quot;</span> &lt;&lt; p &lt;&lt; std::endl;
    <span class="keywordtype">int</span> rank = 0;
    MPI_Comm_rank(MPI_COMM_WORLD,&amp;rank);

    { <span class="comment">// need a scope for dist_init</span>

        <span class="comment">// init CnC here so that we have the context/tuner </span>
        <span class="comment">// the tuner defines the distribution strategy, which we use when generating the matrix</span>
        <a class="code" href="struct_cn_c_1_1dist__cnc__init.html">CnC::dist_cnc_init&lt; my_context &gt;</a> dc_init( MPI_COMM_WORLD, <span class="keyword">true</span> );

        { <span class="comment">// need a scope for the context</span>
<span class="preprocessor">#endif</span>
<span class="preprocessor"></span>            tile_array in_array;
            <span class="keyword">struct </span>my_context c( tdim );
            std::cout &lt;&lt; <span class="stringliteral">&quot;Generating matrix of size &quot;</span> &lt;&lt; argv[1] &lt;&lt; std::endl;
            <span class="comment">// all processes do this, we are SPMD!</span>
            tdim = in_array.generate_matrix(sz, c);

            report_memory();

            <span class="comment">// invert serially</span>
            {
                std::cout &lt;&lt; <span class="stringliteral">&quot;Invert serially&quot;</span> &lt;&lt; std::endl;
                tbb::tick_count t0 = tbb::tick_count::now();
<span class="preprocessor">#ifndef _DIST_</span>
<span class="preprocessor"></span>                tile_array out_array = in_array.inverse();
<span class="preprocessor">#endif</span>
<span class="preprocessor"></span>                tbb::tick_count t1 = tbb::tick_count::now();
                report_time( <span class="stringliteral">&quot;Serial&quot;</span>, sz, (t1-t0).seconds() );
                report_memory();
        
<span class="preprocessor">#ifndef _DIST_</span>
<span class="preprocessor"></span>                tile_array test = in_array.multiply(out_array);
                test.identity_check(1e-5);
<span class="preprocessor">#endif</span>
<span class="preprocessor"></span>            } <span class="comment">// end of scope releases out_array and test</span>
<span class="preprocessor">#ifdef _DIST_</span>
<span class="preprocessor"></span>            <span class="comment">// we need a barrier between CnC context creation and putting stuff</span>
            MPI_Barrier( MPI_COMM_WORLD );
<span class="preprocessor">#endif</span>
<span class="preprocessor"></span>            report_memory();

            {
                std::cout &lt;&lt; <span class="stringliteral">&quot;Invert CnC steps&quot;</span> &lt;&lt; std::endl;
                <span class="comment">//debug::set_num_threads(1);</span>
                tbb::tick_count t2 = tbb::tick_count::now();
                tile_array out_array2 = in_array.inverse_cnc(c);
                tbb::tick_count t3 = tbb::tick_count::now();
                report_time( <span class="stringliteral">&quot;CnC&quot;</span>, out_array2.size(), (t3-t2).seconds() );
                report_memory();
        
<span class="preprocessor">#ifdef _DIST_</span>
<span class="preprocessor"></span>                <span class="comment">// only rank 0 has the full input matrix for the verification</span>
                <span class="keywordflow">if</span>( rank == 0 )
<span class="preprocessor">#endif</span>
<span class="preprocessor"></span>                    {
                        tile_array test2 = in_array.multiply(out_array2);
                        test2.identity_check(1e-5);
                    } <span class="comment">// end of scope releases test2</span>
            } <span class="comment">// end of scope releases out_array2</span>
            report_memory();
<span class="preprocessor">#ifdef _DIST_</span>
<span class="preprocessor"></span>            MPI_Barrier( MPI_COMM_WORLD );
        }
    }

    MPI_Finalize();
<span class="preprocessor">#endif</span>
<span class="preprocessor"></span>    <span class="keywordflow">return</span> 0;
}
</pre></div> <h2><a class="anchor" id="mysql_simple_code"></a>
samples/db/mysql_simple/mysql_simple.cpp</h2>
<div class="fragment"><pre class="fragment"><span class="comment">//********************************************************************************</span>
<span class="comment">// Copyright (c) 2014-2014 Intel Corporation. All rights reserved.              **</span>
<span class="comment">//                                                                              **</span>
<span class="comment">// Redistribution and use in source and binary forms, with or without           **</span>
<span class="comment">// modification, are permitted provided that the following conditions are met:  **</span>
<span class="comment">//   * Redistributions of source code must retain the above copyright notice,   **</span>
<span class="comment">//     this list of conditions and the following disclaimer.                    **</span>
<span class="comment">//   * Redistributions in binary form must reproduce the above copyright        **</span>
<span class="comment">//     notice, this list of conditions and the following disclaimer in the      **</span>
<span class="comment">//     documentation and/or other materials provided with the distribution.     **</span>
<span class="comment">//   * Neither the name of Intel Corporation nor the names of its contributors  **</span>
<span class="comment">//     may be used to endorse or promote products derived from this software    **</span>
<span class="comment">//     without specific prior written permission.                               **</span>
<span class="comment">//                                                                              **</span>
<span class="comment">// This software is provided by the copyright holders and contributors &quot;as is&quot;  **</span>
<span class="comment">// and any express or implied warranties, including, but not limited to, the    **</span>
<span class="comment">// implied warranties of merchantability and fitness for a particular purpose   **</span>
<span class="comment">// are disclaimed. In no event shall the copyright owner or contributors be     **</span>
<span class="comment">// liable for any direct, indirect, incidental, special, exemplary, or          **</span>
<span class="comment">// consequential damages (including, but not limited to, procurement of         **</span>
<span class="comment">// substitute goods or services; loss of use, data, or profits; or business     **</span>
<span class="comment">// interruption) however caused and on any theory of liability, whether in      **</span>
<span class="comment">// contract, strict liability, or tort (including negligence or otherwise)      **</span>
<span class="comment">// arising in any way out of the use of this software, even if advised of       **</span>
<span class="comment">// the possibility of such damage.                                              **</span>
<span class="comment">//********************************************************************************</span>


<span class="comment">/* </span>
<span class="comment"> Attach a database to an item-table.</span>
<span class="comment"></span>
<span class="comment"> We create a very simple graph with one step and one item-collection.</span>
<span class="comment"> It doesn&#39;t do anything sensible, just a demo.  Of course you can</span>
<span class="comment"> write your own application which uses as many DB-attached</span>
<span class="comment"> item_collections as you want. Each item-coll keeps its connection and</span>
<span class="comment"> config separately.</span>
<span class="comment"></span>
<span class="comment"> We use our sql_tuner to attach to the DB. It uses our wrapper</span>
<span class="comment"> sql_item_table.  The sql_config allows configuring the DB (port,</span>
<span class="comment"> table, layout etc) as well as how we actually store (or not) the data</span>
<span class="comment"> in there (by providing SQL statements).  E.g. we might pre-fill the</span>
<span class="comment"> collection at start-up with what&#39;s already in the table; or we might</span>
<span class="comment"> want to delete everything when attaching to it.</span>
<span class="comment"></span>
<span class="comment"> The program uses mysql and assumes a user &quot;cnc&quot; with pw &quot;cnc&quot; and a</span>
<span class="comment"> DB &quot;test&quot;.  You can easily adjust with the SQL config below.  Setup</span>
<span class="comment"> your mysql accordingly.</span>
<span class="comment">*/</span>

<span class="preprocessor">#include &lt;cnc/cnc.h&gt;</span>
<span class="preprocessor">#include &quot;mysql_tuner.h&quot;</span>

<span class="keyword">struct </span>my_context;
<span class="keyword">struct </span>my_sqlstep
{
    <span class="keywordtype">int</span> execute( <span class="keywordtype">int</span>, my_context &amp; ctxt ) <span class="keyword">const</span>;
};

<span class="keyword">struct </span>my_context : <span class="keyword">public</span> CnC::context&lt; my_context &gt;
{
    <span class="comment">// we use the sql_tuner to attach the item-col to a DB</span>
    sql_tuner m_tuner;
    <a class="code" href="class_cn_c_1_1tag__collection.html" title="A tag collection is a set of tags of the same type. It is used to prescribe steps. By default, tags are not stored.">CnC::tag_collection&lt; int &gt;</a> m_tags;
    <a class="code" href="class_cn_c_1_1item__collection.html" title="An item collection is a mapping from tags to items.">CnC::item_collection&lt; int, int, sql_tuner &gt;</a> m_items;
    <a class="code" href="class_cn_c_1_1step__collection.html" title="A step collection is logical set of step instances.">CnC::step_collection&lt; my_sqlstep &gt;</a> m_steps;
    my_context()
        <span class="comment">// the argument to the tuner is a config for the DB</span>
        : m_tuner( {<span class="stringliteral">&quot;tcp://127.0.0.1:3306&quot;</span>,                                  <span class="comment">// port</span>
                    <span class="stringliteral">&quot;cnc&quot;</span>, <span class="stringliteral">&quot;cnc&quot;</span>,                                            <span class="comment">// user, password</span>
                    <span class="stringliteral">&quot;test&quot;</span>,                                                  <span class="comment">// DB/schema,</span>
                    <span class="stringliteral">&quot;DROP TABLE IF EXISTS items;&quot;</span>,                           <span class="comment">// drop statement, set to &quot;&quot; to keep table</span>
                    <span class="stringliteral">&quot;CREATE TABLE If NOT EXISTS items (id INT, value INT);&quot;</span>, <span class="comment">// table creation statement, set to &quot;&quot; to not create table</span>
                    <span class="stringliteral">&quot;SELECT id, value FROM items;&quot;</span>,                          <span class="comment">// read full table statement, set to &quot;&quot; to not read existing entries</span>
                    <span class="stringliteral">&quot;DELETE * FROM items;&quot;</span>,                                  <span class="comment">// clear statements</span>
                    <span class="stringliteral">&quot;SELECT value FROM items WHERE id=?;&quot;</span>,                   <span class="comment">// get statement</span>
                    <span class="stringliteral">&quot;INSERT INTO items( id, value ) VALUES ( ?, ? );&quot;</span>,       <span class="comment">// put statement, set to &quot;&quot; for not putting things into DB</span>
                    <span class="stringliteral">&quot;DELETE FROM items WHERE id=?;&quot;</span>,                         <span class="comment">// erase statement, set to &quot;&quot; to keep things in table upon collection.reset()</span>
                    }),
          m_tags( *<span class="keyword">this</span>, <span class="stringliteral">&quot;tags&quot;</span> ),
          m_items( *<span class="keyword">this</span>, <span class="stringliteral">&quot;items&quot;</span>, m_tuner ),
          m_steps( *<span class="keyword">this</span>, <span class="stringliteral">&quot;steps&quot;</span> )
    {
        m_tags.<a class="code" href="class_cn_c_1_1tag__collection.html#a83f2782bc18578a2018851f0356c8b2a" title="Declare the prescription relationship between the tag collection and a step collection.">prescribes</a>( m_steps, *<span class="keyword">this</span> );
        m_steps.<a class="code" href="class_cn_c_1_1step__collection.html#aa91192651c08408d430829b6e4bca8b0" title="Declare this step-collecation as consumer of given item-collection.">consumes</a>( m_items );
        m_steps.<a class="code" href="class_cn_c_1_1step__collection.html#a7e5f64f200a66bba4228f17bfded35ca" title="Declare this step-collecation as producer for given item-collection.">produces</a>( m_items );
    }
};

<span class="comment">// our step simple gets a piece of data and puts another one</span>
<span class="keywordtype">int</span> my_sqlstep::execute( <span class="keywordtype">int</span> t, my_context &amp; ctxt )<span class="keyword"> const</span>
<span class="keyword"></span>{
    <span class="keywordtype">int</span> r;
    ctxt.m_items.get( t-1, r );
    ctxt.m_items.put( t, t+r );
    <span class="keywordflow">return</span> 0;
}

<span class="comment">// we simply create the graph, put the control tags and the initial data.</span>
<span class="comment">// &quot;mysql -u cnc -p test -pcnc -e &quot;select * from items;&quot; shows what has been stored to the table</span>
<span class="keywordtype">int</span> main(<span class="keywordtype">void</span>)
{
    my_context _ctxt;
    _ctxt.m_items.put( -1, -1 );
    <span class="keywordflow">for</span>( <span class="keywordtype">int</span> i = 0; i&lt;100; ++i ) {
        _ctxt.m_tags.put( i );
    }
    _ctxt.wait();
    <span class="keywordflow">for</span>( <span class="keywordtype">int</span> i = 0; i&lt;10; ++i ) {
        <span class="keywordtype">int</span> _ir = -1;
        _ctxt.m_items.get( i, _ir );
        std::cout &lt;&lt; _ir &lt;&lt; <span class="stringliteral">&quot; for &quot;</span> &lt;&lt; i &lt;&lt; std::endl;
    }

    <span class="keywordflow">return</span> 0;
}
</pre></div> </div></div><!-- contents -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Friends</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>



<hr class="footer"/><address class="footer"><small>
Generated on Fri Jun 6 2014 15:18:34 for CnC by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.7.6.1
</small></address>

</body>
</html>
