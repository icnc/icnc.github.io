<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>CnC: CnC C++ Tutorial</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />

<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>

</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">CnC
   
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="headertitle">
<div class="title"><a class="el" href="namespace_cn_c.html" title="CnC API.">CnC</a> C++ Tutorial </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><b> The <a class="el" href="namespace_cn_c.html" title="CnC API.">CnC</a> programming model is quite different from most other parallel programming models in several important ways. Hence, we highly recommend you carefully read the following introduction sections (<a class="el" href="tutorial.html#intro">CnC in a Nutshell</a>) carefully before diving into the hands-on tutorial. It'll take only a few minutes but you'll have a much easier time, more fun and faster success! Promise, it'll pay off! </b></p>
<ul>
<li><a class="el" href="tutorial.html#intro">CnC in a Nutshell</a></li>
<li><a class="el" href="fib.html">Getting Started with Fibonacci</a></li>
<li><a class="el" href="debug.html">Debugging features</a></li>
<li><a class="el" href="tuning.html">The Tuners</a></li>
<li><a class="el" href="tag_ranges.html">Tag-Ranges</a></li>
<li><a class="el" href="reuse.html">Re-using CnC graphs (reductions, cross/join...)</a></li>
<li><a class="el" href="runtime.html">Runtime Options</a></li>
<li><a class="el" href="distcnc.html">Running CnC applications on distributed memory</a></li>
<li><a class="el" href="dist_tuning.html">Tuning for distributed memory</a></li>
<li><a class="el" href="non_cnc.html">Beyond And With CnC</a></li>
</ul>
<h2><a class="anchor" id="intro"></a>
CnC in a Nutshell</h2>
<p><a class="el" href="namespace_cn_c.html" title="CnC API.">CnC</a> is a new programming model which is different from most others. It designed for creating parallel applications, but not for expressing parallelism explicitly. In <a class="el" href="namespace_cn_c.html" title="CnC API.">CnC</a> the programmer declaratively specifies the dependencies among computation units, but does not in any way indicate how those are to be met. It is specifically designed for addressing the coordination among potentially parallel computation units and data.</p>
<p>In essence, the programmer declares certain dependencies between two (or more) computation units. Specifying the dependencies is simpler than expressing parallelism, because it only makes application semantics explicit - and does not depend on the platform or any specific parallelization technique. Additionally, it exposes more parallelism potential because it does not bind a particular parallelism to the algorithm/program. The <a class="el" href="namespace_cn_c.html" title="CnC API.">CnC</a> runtime will do the hard work of figuring out how to execute things in parallel; it will try to maximize parallelism, limited only by the ordering constraints defined by the programmer.</p>
<p>The only 2 ordering constraints which semantically exist in any program come from the following 2 relationships</p>
<ol type="1">
<li>producer/consumer</li>
<li>controller/controlee</li>
</ol>
<p>It is apparent that a producer needs to executed before the consumer can run. Similarly, if one computation unit decides whether another computation needs to be executed or not, the decision maker (e.g. the controller) needs to go before the controlled computation(s).</p>
<p>These two relationships (producer/consumer and controller/controlee) are the only relations needed to determine semantically correct parallel or sequential execution orders. This information is known to any programmer, even when writing sequential programs. It only gets lost because traditional programming languages have no means to explicitly express it. Exactly this is what a <a class="el" href="namespace_cn_c.html" title="CnC API.">CnC</a> program specifies (on top of the computation functionality of course).</p>
<h2><a class="anchor" id="cook"></a>
Burgers with Fries and Pies for Dessert</h2>
<h3><a class="anchor" id="burgers"></a>
Burgers and fries are parallel</h3>
<p>Let's make burgers and French Fries. Let's say the ready-to-process ingredients (cut potatoes and prepared meat) get delivered to a service hatch, from which the cook can take them for processing. In <a class="el" href="namespace_cn_c.html" title="CnC API.">CnC</a> such hatches are <em>item-collections</em>, which store input and output data/items. Each collection can hold multiple instances of the same data(-type). In our kitchen that would mean we have a hatch for potatoes and a another hatch for the meat. Similarly, whatever we create and cook (our output) would be placed in such a hatch (item-collection). Our hungry guests can pick up the delicacies from this hatch once they have been produced.</p>
<p>The tasks for our cooks are frying the potatoes and barbecuing the meat. In <a class="el" href="namespace_cn_c.html" title="CnC API.">CnC</a> we call such tasks <em>steps</em>, which are basically just normal functions. The interesting question is: are there any dependencies between the two cooking tasks/steps? Of course not: neither uses the result of the other and neither decides whether the other needs to be done (or not). Hence, there is no ordering required, we can fry the potatoes first, or do the meat first or do them in parallel. </p>
<dl class="note"><dt><b>Note:</b></dt><dd>If we insisted on working one-handed and allowed only one cook active at the same time, we needed to decide on a (arbitrary) sequence. In serial languages, the programmer is required to make that arbitrary choice but doesn't indicate that the choice was optional.</dd></dl>
<h3><a class="anchor" id="pies"></a>
Can't bake a pie until it's prepared</h3>
<p>Let's add mini cherry pies to our meal for dessert. A mini-pie has to be prepared and baked (prepare_pie, bake_pie). Altogether, we now have four steps, three of which (barbecue_burger, fry_potatoes, prepare_pie) have no dependencies between them. However, we need the pie in order to bake it. We don't need to know where it comes from, we only need the ready assembled pie: we take it from the hatch once it's there and bake it. Similarly, for the task of preparing a pie we don't need to know what's going to happen with it afterwards, we just create it and put it on the hatch.</p>
<p>Incidentally, there is a <em>producer/consumer</em> relationship between prepare_pie and bake_pie. A producer/consumer relationship constitutes one of the two before-mentioned ordering constraints: the producer needs to be executed before the consumer can use the produced item. Note, the programmer does not explicitly indicate a specific execution order. The runtime takes care of it: as it knows about the relationship, it will never bake a pie before it has been prepared.</p>
<h3><a class="anchor" id="waiter"></a>
Waiter controlling cooks</h3>
<p>Now, let's say our guest are individuals and not all of them want the same menu. Some of them might want the full menu: a burger, fries and a pie. Someone else might prefer 2 burgers, no fries but a pie, and so on. So let's take orders (take_orders) first. Only if they know the orders, our cooks can actually start cooking. When taking orders, we must assign a unique identifier (a tag) to each order so that we later know which burgers, fries and pies are for which guest. To communicate the orders with the kitchen, our <a class="el" href="namespace_cn_c.html" title="CnC API.">CnC</a> kitchen uses special bowls, one for each step (barbecue_burger, fry_potatoes, bake_pie and prepare_pie). Whenever a step needs to be executed for a given order, the waiter simply puts the corresponding guest-tag into the step's bowl. For example, if guestA wants a burger and Fries, we put the tag/token 'A' into barbecue_burger's bowl and into fry_potatoes' bowl. Our cooks will then prepare a burger and fries for guest 'A', but as there is no token/tag in the pie bowl, they will not make a pie for 'A'. <a class="el" href="namespace_cn_c.html" title="CnC API.">CnC</a> calls such bowls <em>tag-collections</em>.</p>
<p>We have just declared a controller/controlee relationship. Our waiter decides which steps need to be executed. Moreover, our <a class="el" href="namespace_cn_c.html" title="CnC API.">CnC</a> kitchen assigns a tag (a unique identifier) to each execution instance. With this our chef (e.g. the <a class="el" href="namespace_cn_c.html" title="CnC API.">CnC</a> runtime) can now coordinate the different tasks as they come in (e.g. to make sure burgers and fries from the same order are ready together).</p>
<h3><a class="anchor" id="done"></a>
We have a CnC specification!</h3>
<p>We have now introduced the dependencies which imply a certain (partial) ordering. This partial ordering allows us (e.g. the <a class="el" href="namespace_cn_c.html" title="CnC API.">CnC</a> runtime) to determine a legal scheduling of the step instances (computation units), be it serial or parallel. If we have ten cooks or one, all they need to know are the ordering constraints (besides knowing how to cook, of course). They could do everything in parallel, except they need to 1. wait for the tags to come in before starting a task 2. wait for each pie to be prepared before baking it.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>The constraints we defined are semantic attributes, they are requirements only of the algorithm. They exist independent of the programming language or programming tool, e.g. even if not using <a class="el" href="namespace_cn_c.html" title="CnC API.">CnC</a> they must be obeyed: a pie simply needs to be prepared before put into the oven. And it doesn't make sense to start frying potatoes unless we know that someone actually wants fries.</dd></dl>
<p>Basically we came up with a <a class="el" href="namespace_cn_c.html" title="CnC API.">CnC</a> specification for our kitchen problem. What we have done is</p>
<ul>
<li>identified the computation units (barbecue_burger, fry_potatoes, prepare_pie, bake_pie and take_orders)</li>
<li>identified the data entities (meat, potatoes, fries, burgers, pies)</li>
<li>identified the control tags (guest-id)</li>
<li>consumer/producer relationships (prepare_pie -&gt; pies -&gt; bake_pie)</li>
<li>controller/controlee relationships (take_orders =&gt; xxx_bowls =&gt; steps)</li>
</ul>
<p>That's what makes a <a class="el" href="namespace_cn_c.html" title="CnC API.">CnC</a> specification; paired with an implementation of each computation step it makes an application ready for parallel execution. Nothing else is needed in the <a class="el" href="namespace_cn_c.html" title="CnC API.">CnC</a> world - the rest is handled by the <a class="el" href="namespace_cn_c.html" title="CnC API.">CnC</a> runtime. The <a class="el" href="namespace_cn_c.html" title="CnC API.">CnC</a> approach leaves the <a class="el" href="namespace_cn_c.html" title="CnC API.">CnC</a> runtime with all freedom to execute things in parallel as long as it satisfies the defined semantics.</p>
<h3><a class="anchor" id="but"></a>
But...</h3>
<p>..of course there are rules when programming in <a class="el" href="namespace_cn_c.html" title="CnC API.">CnC</a>:</p>
<ol type="1">
<li>Computation units (steps) must execute statelessly, e.g. computation must not access or even alter any global data and leave no traces behind other than putting things into <a class="el" href="namespace_cn_c.html" title="CnC API.">CnC</a>'s collections.</li>
<li>Data is immutable. Once put, data-items cannot be altered. instead of changing a value, in <a class="el" href="namespace_cn_c.html" title="CnC API.">CnC</a> you put a new value with a new tag.</li>
</ol>
<p>The rules might sound more restricting than they actually are. Actually, in this tutorial you will almost certainly start appreciating the rules. They are much easier to follow than the common rules of traditional parallel frameworks. For example, almost all threading frameworks tell the programmer "Don't create races". That's a very vague rule and verifying it's correct implementation is close to impossible. <a class="el" href="namespace_cn_c.html" title="CnC API.">CnC</a>'s rules are easy to follow, easy to check and they will actually give race-freedom and determinism without you needing to think about it.</p>
<h2><a class="anchor" id="recipe"></a>
The CnC Recipe</h2>
<p>The challenge in using <a class="el" href="namespace_cn_c.html" title="CnC API.">CnC</a> certainly lies in applying its concepts to a given problem (application). Luckily, once that's accomplished, the remaining tasks are straight forward and later changes to the design are relatively simple to make. The thought process to getting to a complete <a class="el" href="namespace_cn_c.html" title="CnC API.">CnC</a> design for your application can happen in several small phases:</p>
<ol type="1">
<li>Define the data and computation entities of your application (step-, item- and tag-collections)</li>
<li>Define how to distinguish between instances of these entities (what do the identifiers/tags look like?)</li>
<li>Define the relations between the entities (producer/consumer and controller/controlee)</li>
</ol>
<p>This tutorial will guide you through these phases with a simple example program. It'll explain the use of <a class="el" href="namespace_cn_c.html" title="CnC API.">CnC</a> with the C++ API by creating a program to compute Fibonacci numbers. Due to nature of Fibonacci <a class="el" href="namespace_cn_c.html" title="CnC API.">CnC</a> doesn't necessarily provide the most natural expressiveness for it. However, Fibonacci has the right complexity and characteristics to demonstrate <a class="el" href="namespace_cn_c.html" title="CnC API.">CnC</a> and Intel's C++ API without getting lost in details of non-CnC related issues.</p>
<p>After creating a first program, we will introduce a debugging-interface and more advanced features like a tuning interface providing powerful tuning knobs.</p>
<p><a class="el" href="fib.html">I am ready, let's go!</a> </p>
</div></div><!-- contents -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Friends</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>



<hr class="footer"/><address class="footer"><small>
Generated on Fri Jun 6 2014 15:18:33 for CnC by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.7.6.1
</small></address>

</body>
</html>
