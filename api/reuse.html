<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>CnC: Re-using CnC graphs (reductions, cross/join...)</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />

<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>

</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">CnC
   
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="headertitle">
<div class="title">Re-using <a class="el" href="namespace_cn_c.html" title="CnC API.">CnC</a> graphs (reductions, cross/join...) </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="el" href="namespace_cn_c.html" title="CnC API.">CnC</a> programs can be written in a way so that they can be re-used. An example could be a <a class="el" href="namespace_cn_c.html" title="CnC API.">CnC</a> graph which implements matrix-multiplication or a generic reduction. The idea is to reuse such an implementation either multiple times in the same application or in different applications.</p>
<p>On the abstract, every <a class="el" href="namespace_cn_c.html" title="CnC API.">CnC</a> graph has input collections and output collections. The input collections of a given sub-graph must be the output collection of another graph (and/or the environment). Similarly, an output collection of a sub-graph is used as input by another graph (and/or the environment). To make a graph re-usable, all we need is a way of connecting its input and output collections to the rest of the application. The inner of such a re-usable graph is of no interest to the outside - it might be a normal <a class="el" href="namespace_cn_c.html" title="CnC API.">CnC</a> graph or something else. In any case, any communication with the graph is done with the normal semantics of <a class="el" href="namespace_cn_c.html" title="CnC API.">CnC</a> collections. At instantiation time, we simply need to give it the input and output collections that we want it to work on.</p>
<h2><a class="anchor" id="using_graphs"></a>
Using Sub-Graphs</h2>
<p>The <a class="el" href="namespace_cn_c.html" title="CnC API.">CnC</a> distribution ships with a few generic predefined graphs. Some of them are relatively complex template-classes as they aim to be as generic as possible. To facilitate their instantiation they are accompanied with a creator function. It accepts the input/output collections as its argument and returns a parametrized instance of the re-usable graph which is fully wired with the given collections. That's it, now we just use the input/output collections as normal, the sub-graph will automatically "execute" behind the scenes.</p>
<h3><a class="anchor" id="reduce"></a>
Example: Using A Generic Reduction Graph</h3>
<p>Here's a simple example (<a class="el" href="samples.html#count_words_code">samples/count_words/count_words/count_words.cpp</a>) which uses the <a class="el" href="namespace_cn_c.html" title="CnC API.">CnC</a> reduction to count the occurrences of strings in a file. The global graph consists of a collection for all the lines in the file (blocks), a collection with counts of strings per line (counts_per_line) and the collection with the final count per string (counts). Here's how the instantiation (and wiring) of the graph works by assigning the reduction graph to reduce using <a class="el" href="group__reductions.html#ga700ef577820e594bfc11868817766965">CnC::make_reduce_graph</a>:</p>
 <div class="fragment"><pre class="fragment">    cw_context()
        : tags( *<span class="keyword">this</span>, <span class="stringliteral">&quot;tags&quot;</span> ),
          blocks( *<span class="keyword">this</span>, <span class="stringliteral">&quot;blocks&quot;</span> ),
          counts_per_block( *<span class="keyword">this</span>, <span class="stringliteral">&quot;counts_per_block&quot;</span> ),
          counts( *<span class="keyword">this</span>, <span class="stringliteral">&quot;counts&quot;</span> ),
          red_counts( *<span class="keyword">this</span>, <span class="stringliteral">&quot;red_counts&quot;</span> ),
          steps( *<span class="keyword">this</span>, <span class="stringliteral">&quot;counter&quot;</span> ),
          reduce( NULL )
    {
        <span class="comment">// here we wire the graph/reduction</span>
        reduce = <a class="code" href="group__reductions.html#ga700ef577820e594bfc11868817766965">CnC::make_reduce_graph</a>( *<span class="keyword">this</span>,            <span class="comment">// context</span>
                                         <span class="stringliteral">&quot;reduce&quot;</span>,         <span class="comment">// name</span>
                                         counts_per_block, <span class="comment">// input collection</span>
                                         red_counts,       <span class="comment">// number of items per reduction</span>
                                         counts,           <span class="comment">// the final result for each reduction</span>
                                         std::plus&lt;size_type&gt;(), <span class="comment">// the reduction operation</span>
                                         size_type(0),     <span class="comment">// identity element</span>
                                         <span class="comment">// we use a lambda as the selector</span>
                                         <span class="comment">// it maps the item to the reduction identified by t.second (the string)</span>
                                         <span class="comment">// e.g. it reduces over all blocks</span>
                                         []( <span class="keyword">const</span> tag_type &amp; t, std::string &amp; _s )-&gt;<span class="keywordtype">bool</span>{_s=t.second;<span class="keywordflow">return</span> <span class="keyword">true</span>;} );
        tags.prescribes( steps, *<span class="keyword">this</span> );
        steps.consumes( blocks );
        steps.produces( counts_per_block );
        <span class="comment">//CnC::debug::trace( *reduce, 3 );</span>
    }
</pre></div></p>
<p>Providing data as input to the reduction is a normal put. In this example, the step computes the number of occurrences for a given word and line and then just puts the computed value.</p>
<p><div class="fragment"><pre class="fragment"><span class="comment">// get block/line (tag.first) and determine number of occurances of string (tag.second)</span>
<span class="comment">// put result into counts_per_block</span>
<span class="keywordtype">int</span> counter::execute( <span class="keyword">const</span> tag_type &amp; t, cw_context &amp; ctxt )<span class="keyword"> const</span>
<span class="keyword"></span>{
    std::string _str;
    ctxt.blocks.get( t.first, _str );
    <span class="keyword">const</span> size_type _sz = _str.size();
    size_type _pos = -1;
    size_type _cnt = 0;
    <span class="keywordflow">while</span>( ( _pos = _str.find( t.second, _pos+1 ) ) &lt; _sz ) ++_cnt;
    <span class="comment">// always to results, even if 0</span>
    <span class="comment">// this allows us to determine the number of reduced items in main</span>
    ctxt.counts_per_block.put( t, _cnt );
    <span class="keywordflow">return</span> 0;
}
</pre></div></p>
<p>Similarly, using the result of the reduction is a normal get on the graph's output collection. Like in this example, we can also iterate on the output collection (in safe state only):</p>
<p><div class="fragment"><pre class="fragment">    <span class="comment">// iterate and write out all keys/value pairs</span>
    <span class="keywordflow">for</span>( <span class="keyword">auto</span> i = ctxt.counts.begin(); i != ctxt.counts.end(); ++i ) {
        std::cout &lt;&lt; i-&gt;first &lt;&lt; <span class="stringliteral">&quot; \t &quot;</span> &lt;&lt; *i-&gt;second &lt;&lt; std::endl;
    }
</pre></div></p>
<p>Please see <a class="el" href="samples.html#count_words_code">samples/count_words/count_words/count_words.cpp</a> for the details of the code. You will realize that using the reduction (created by <a class="el" href="group__reductions.html#ga700ef577820e594bfc11868817766965">CnC::make_reduce_graph</a>) requires providing the count of items that will be reduced in each reduction. Some might think that this is a strange requirement. In fact, it's a semantic requirement; similar information is required by all reduction implementations in other languages as well. Separating it from providing the data actually increases flexibility and the opportunity for asynchronous operation.</p>
<h4><a class="anchor" id="red_flush"></a>
What If The Number Of Reduced Items Is Unknown?</h4>
<p>Of course there are cases in which the exact number of reduced items is never known until finished. So instead of knowing the number of reduced items we know when the reduction can be completed. For such cases the reduction allows you to provide a done-flag, either for all reductions in the reduce-graph (by calling flush on the reduce-graph) or for individual reductions (by putting -1 as the count).</p>
<p>An example is counting all words in a file (rather than a give set of words), see <a class="el" href="samples.html#count_all_words_code">samples/count_all_words/count_all_words/count_all_words.cpp</a>. Because we do not know the words we count, there is no way to say how many contributions there will be. So when the processing is done, we finalize the reduction by calling flush():</p>
 <div class="fragment"><pre class="fragment">    <span class="comment">// A reduction needs number of reduced items.</span>
    <span class="comment">// We do not know the count in advance.</span>
    <span class="comment">// We do not even know which words are going to show up.</span>
    <span class="comment">// We have to wait until processing is done</span>
    <span class="comment">// and then tell the reduction it can do the final pass</span>
    ctxt.wait();
    ctxt.reduce-&gt;flush();
    ctxt.wait();
</pre></div></p>
<p>Please refer to <a class="el" href="group__reductions.html#ga700ef577820e594bfc11868817766965">CnC::make_reduce_graph</a> for details on using <a class="el" href="namespace_cn_c.html" title="CnC API.">CnC</a> reductions.</p>
<h4><a class="anchor" id="mapreduce"></a>
Map-Reduce</h4>
<p>An obvious application for the reduction is of course the popular map-reduce paradigm. The above example contains almost everything needed to write a mapreduce framework based on <a class="el" href="namespace_cn_c.html" title="CnC API.">CnC</a>. Such a <a class="el" href="namespace_cn_c.html" title="CnC API.">CnC</a> based framework combines the ease of mapreduce with the flexibility of <a class="el" href="namespace_cn_c.html" title="CnC API.">CnC</a> as it allows naturally embedding mapreduce algorithms into <a class="el" href="namespace_cn_c.html" title="CnC API.">CnC</a> programs without introducing artificial constraints. As a proof of concept we implemented a mapreduce_context (<a class="el" href="samples.html#mapreduce_code">samples/count_all_words/mapreduce/mapreduce.h</a>) and use it to implement the same algorithm (count-all-words). To use the mapreduce_context you only need to provide the map-operation (working on a stream like other mapreduce frameworks do it), the reduce operation and then put the data files (see <a class="el" href="samples.html#count_all_words_mr_code">samples/count_all_words/mapreduce/mapreduce.cpp</a>).</p>
<h4><a class="anchor" id="connect_graphs"></a>
Connecting Several Graphs</h4>
<p>The above examples use a single graph to which they input data and take its output at the end. A more interesting case would be to connect two graphs together and let the asynchronous <a class="el" href="namespace_cn_c.html" title="CnC API.">CnC</a> semantics play nicely. Let's sum the entries of a 2d matrix using 2 reductions: the first reduction computes the sums for each row. We then feed this output (the sums of each row) into a second reduction which then sums those into a single value. We don't need barriers or anything like this. Following the <a class="el" href="namespace_cn_c.html" title="CnC API.">CnC</a> spirit, we just declare the dependencies - and everything can happen asynchronously. We just let the same item-collection (sum1) serve as the output for the first reduction and as the input for the second. This implies that as soon as the first reduction (red1) produces something into sum1, the second reduction (red2) can operate on it:</p>
 <div class="fragment"><pre class="fragment">        tags.prescribes( sc, *<span class="keyword">this</span> );
        sc.produces( a );
        <span class="comment">// first reduction inputs a and outputs sum1</span>
        red1 = <a class="code" href="group__reductions.html#ga700ef577820e594bfc11868817766965">CnC::make_reduce_graph</a>( *<span class="keyword">this</span>, <span class="stringliteral">&quot;red_row&quot;</span>,
                                       a,            <span class="comment">// input collection: our matrix</span>
                                       cnt1,         <span class="comment">// count of items per reduction</span>
                                       sum1,         <span class="comment">// output collection: sum per row</span>
                                       std::plus&lt;int&gt;(),  <span class="comment">// reduction operation &#39;+&#39;</span>
                                       0,            <span class="comment">//identity element</span>
                                       selector() ); <span class="comment">// selector</span>
        <span class="comment">// second reduction inputs sum1 and outputs sum2</span>
        red2 = <a class="code" href="group__reductions.html#ga700ef577820e594bfc11868817766965">CnC::make_reduce_graph</a>( *<span class="keyword">this</span>, <span class="stringliteral">&quot;red_red&quot;</span>,
                                       sum1,         <span class="comment">// the input collection is the output of red1</span>
                                       cnt2,         <span class="comment">// count of items per reduction</span>
                                       sum2,         <span class="comment">// the final output: sum of all values</span>
                                       std::plus&lt;int&gt;(),  <span class="comment">// reduction operation &#39;+&#39;</span>
                                       0,            <span class="comment">//identity element</span>
                                       selector() ); <span class="comment">// selector</span>
</pre></div></p>
<p>In this example the step simply puts the items and the environment consumes the final sum. We hope the code <a class="el" href="samples.html#reduce_2d_code">samples/reduce_2d/reduce_2d/reduce_2d.cpp</a> is sufficiently well documented to understand how it works.</p>
<h2><a class="anchor" id="def_graphs"></a>
Writing Re-Usable Sub-Graphs</h2>
<p>When writing a <a class="el" href="class_cn_c_1_1graph.html" title="Base class for defining and using CnC (sub-)graphs.">CnC::graph</a> three hurdles need to be taken</p>
<ul>
<li>providing the graph's functionality</li>
<li>renaming input and output collections</li>
<li>generality</li>
<li>termination/quiescence detection</li>
</ul>
<h3><a class="anchor" id="def_graph_func"></a>
Functionality</h3>
<p>A <a class="el" href="class_cn_c_1_1graph.html" title="Base class for defining and using CnC (sub-)graphs.">CnC::graph</a> defines a piece of an application. Such a graph is part of the overall static <a class="el" href="namespace_cn_c.html" title="CnC API.">CnC</a> structure: it gets instantiated with the rest of <a class="el" href="namespace_cn_c.html" title="CnC API.">CnC</a> and exists until the surrounding <a class="el" href="namespace_cn_c.html" title="CnC API.">CnC</a> context goes away. Such a sub-graph can contain anything it wants, as long as its communication with the <a class="el" href="namespace_cn_c.html" title="CnC API.">CnC</a> environment goes through <a class="el" href="namespace_cn_c.html" title="CnC API.">CnC</a> collections. It can have internal state and/or have internal collections that are not accessible from the outside.</p>
<h3><a class="anchor" id="def_graph_renaming"></a>
Renaming Input And Output Collections</h3>
<p>The graph's connections to and from the <a class="el" href="namespace_cn_c.html" title="CnC API.">CnC</a> context are <a class="el" href="namespace_cn_c.html" title="CnC API.">CnC</a> collections from which a graph takes its inputs and where it puts its output. These input/output collections must live on the outside of the graph but the graph uses them. A generic re-usable graph definition should make as little assumption as possible about these connecting collections - in particular it should not rely on their names on the outside. Moreover, different instantiations of the same graph might be used in the same application, using different collections as input and output.</p>
<p>This implies that the input/output collections should be parameters of a generic re-usable graph. Hence such a graph should accept the connecting collections as arguments of its constructor. Internally it will store references to them and use those in the implementation of its functionality.</p>
<h3><a class="anchor" id="graph_data"></a>
Accessing Input Data</h3>
<p>The conventional way of getting data from collections (using ::get()) is one way to get to the input data. However, this is possible only from within (graph-internal) <a class="el" href="namespace_cn_c.html" title="CnC API.">CnC</a> steps. Step-like data access is limits the things that can be done to what a <a class="el" href="namespace_cn_c.html" title="CnC API.">CnC</a> can express (e.g. it is not possible to operate on a stream of incoming data with unknown tags).</p>
<p>To lift this restriction <a class="el" href="namespace_cn_c.html" title="CnC API.">CnC</a> provides a callback interface to tag- and item collections. A graph can register callbacks on each collection. Whenever something is put into the collection the registered callback is called, providing the tag (and data) of what's currently put. Every collection defines the type of this callback: <a class="el" href="class_cn_c_1_1item__collection.html#abd57cb2f7ad3e2c60b0c8a576c0ab074">CnC::item_collection::callback_type</a> and <a class="el" href="class_cn_c_1_1tag__collection.html#a18f39640662ab28c3f18d87a4684f2fb">CnC::tag_collection::callback_type</a>. The callback needs to implement the corresponding on_put method (see <a class="el" href="class_cn_c_1_1item__collection.html#abd57cb2f7ad3e2c60b0c8a576c0ab074">CnC::item_collection::callback_type</a> and <a class="el" href="class_cn_c_1_1tag__collection.html#a18f39640662ab28c3f18d87a4684f2fb">CnC::tag_collection::callback_type</a>) and is registered with a collection by calling <a class="el" href="class_cn_c_1_1item__collection.html#a515c2f781a8bb1c49ae56fdb920fe051">CnC::item_collection::on_put</a> or <a class="el" href="class_cn_c_1_1tag__collection.html#a515c2f781a8bb1c49ae56fdb920fe051">CnC::tag_collection::on_put</a>. The callback object can carry state and keep references to the graph. This provides a very flexible mechanism to implement almost anything within a <a class="el" href="namespace_cn_c.html" title="CnC API.">CnC</a> graph, even if it's - internally! - not obeying the <a class="el" href="namespace_cn_c.html" title="CnC API.">CnC</a> semantics.</p>
<p>Let's look at a simple example of such a callback. We need a class which derives from <a class="el" href="class_cn_c_1_1item__collection.html#abd57cb2f7ad3e2c60b0c8a576c0ab074">CnC::item_collection::callback_type</a> and implements the on_put method:</p>
 <div class="fragment"><pre class="fragment">    <span class="comment">// the callback for incoming data just pushes the items on our internal queue</span>
    <span class="keyword">struct </span>on_data : <span class="keyword">public</span> IC_IN::callback_type
    {
        on_data( blocking_queue &amp; q ) : m_q(q) {}
        <span class="keywordtype">void</span> on_put( <span class="keyword">const</span> <span class="keyword">typename</span> IC_IN::tag_type &amp; <span class="comment">/*tag*/</span>, <span class="keyword">const</span> <span class="keyword">typename</span> IC_IN::data_type &amp; val )
        {
            m_q.push( val );
        };
        blocking_queue &amp; m_q;
    };
</pre></div></p>
<p>on_put simply stores the incoming data in an internal queue. In the graph's constructor we register an instance of our callback:</p>
<p><div class="fragment"><pre class="fragment">        m_input.on_put( <span class="keyword">new</span> on_data( m_queue ) );
</pre></div></p>
<p>The graph can now operate on the internal copies of the data in any way it wants. When communicating back the <a class="el" href="namespace_cn_c.html" title="CnC API.">CnC</a> environment, the graph must use its output-collections. As a simple example, let's have a thread pop each data from the internal queue, sleep for a while and then produce control tags and output data:</p>
 <div class="fragment"><pre class="fragment">            <span class="keywordflow">do</span> {
                <span class="comment">// get next input</span>
                queue-&gt;pop( _item );
                <span class="comment">// and do some work, we just sleep, but it could be anything</span>
                <span class="comment">// ideally of course this would use TBB tasks</span>
                <span class="keywordtype">int</span> _tm = rand() % 1111;
                std::this_thread::sleep_for( std::chrono::milliseconds(_tm) );
                <span class="comment">// now produce our output, to make it a little more intersting let&#39;s make it conditional</span>
                <span class="keywordflow">if</span>( _tm % 4 ) {
                    dataout-&gt;put( _tag, _item + _tm );
                    tagout-&gt;put( _tag );
                    ++_tag;
                }
            } <span class="keywordflow">while</span>( _tag &lt; <a class="code" href="class_cn_c_1_1tuner__base.html#ae52a37bb28b0d5fdd7fc105ac989ac46">CnC::tuner_base::myPid</a>()*1000+7 );
</pre></div></p>
<p>Please see <a class="el" href="samples.html#hidden_graph_code">samples/hidden_graph/hidden_graph/hidden_graph.cpp</a> for the full code.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>The hidden_graph example uses its own thread and so requires additional care (see <a class="el" href="reuse.html#graph_term">Detection Of Graph Quiescence/Termination</a>).</dd></dl>
<h3><a class="anchor" id="graph_generic"></a>
Writing generic graphs</h3>
<p>As a typed language C++ requires static knowledge of used types. The types of tags and items must be known at compile time. A generic graph definition needs to adjust to these types at compile time. In C++ this is achieved by using templates and the template arguments of a "templated graph" depend at least on the input and output collections. As <a class="el" href="namespace_cn_c.html" title="CnC API.">CnC</a>'s collection templates accept not only the tag and data types but also the tuner type, an increasing number of input/output collections easily leads to a very long list of template parameters.</p>
<p>To instantiate an object of a template class requires specifying all template arguments in the type definition. Template functions are easier to use as the C++ compiler can automatically deduce the template arguments. Hence it is recommended to accompany every template graph with generator function accepting all input/output collections and other initialization parameters.</p>
<p>In addition to the mere type declaration issue, the internals of a (hidden) graph might actually operate on tags and items. A generic definition must ensure that those operations are valid for all types. It should be possible for a user to provide the functionality so that the graph works on custom types. For example, the graph might use the operator '+' on items. If you overload the operator '+' of your custom type it'll work just fine. Instead of overloading you can also make such operators (template) parameters of your graph. The reduction graph is an example, it let's you provide the reduction operation.</p>
<p>Note that this is not only true for the data items but also for tags. Whenever the graph works on a tag, it makes some assumptions about what the tag means or what kind of information it can extract from it. For example, if the graph semantically operates on a one-dimensional data set, it should still be possible to use the graph if the actual tag-space is 2-dimensional (or even higher). In other words, even if the graph's operation is one-dimensional, it should be able to operate on a higher-dimensional item-collection (e.g. apply a reduction on every row for a 2-dimensional matrix). Like with the above operators, this can be addressed by letting the user provide the functionality to extract the information the graph needs. An example is the selector function in the reduction (see also reduce_2d for an sample use).</p>
<h3><a class="anchor" id="graph_term"></a>
Detection Of Graph Quiescence/Termination</h3>
<p>If a graph executes things only within (internal) <a class="el" href="namespace_cn_c.html" title="CnC API.">CnC</a> steps or within the the execution scope of the callbacks the runtime can automatically detect when the graph execution is finished. Examples of such graphs are CnC::reduction (as returned by <a class="el" href="group__reductions.html#ga700ef577820e594bfc11868817766965">CnC::make_reduce_graph</a>) and CnC::join (as returned by <a class="el" href="namespace_cn_c.html#a786de035532c077e7b6a67f942d0e2e4">CnC::make_join_graph</a>).</p>
<p>Restricting executing code to steps and callbacks will suffice in many cases. Some algorithms might require starting threads or reacting on events outside the <a class="el" href="namespace_cn_c.html" title="CnC API.">CnC</a> scope (such as sensors). In such cases the graph is responsible of communicating to the <a class="el" href="namespace_cn_c.html" title="CnC API.">CnC</a> runtime whether it's currently active or quiescent. As soon as the runtime finds everything in quiescent state it will terminate the execution.</p>
<p>For signaling activity and/or quiescence <a class="el" href="class_cn_c_1_1graph.html" title="Base class for defining and using CnC (sub-)graphs.">CnC::graph</a> provides <a class="el" href="class_cn_c_1_1graph.html#ae2c6d143c665ed3541233cffb7679961" title="Tell the runtime that the graph leaves quiescence and goes back to activity. Must be called only with...">CnC::graph::leave_quiescence</a> and <a class="el" href="class_cn_c_1_1graph.html#a5c2c7f8062e36ddc620174c1df0629fa" title="Tell the runtime that the graph reached (temporary) quiescence.">CnC::graph::enter_quiescence</a>. A call to enter_quiescence must be paired with a preceding call to leave_quiescence but can otherwise be allowed at any time. leave_quiescence must be called only within the constructor of the graph, within a (internal) <a class="el" href="namespace_cn_c.html" title="CnC API.">CnC</a> step or within a on_put callback.</p>
<p>Our hidden_graph example starts a thread which operates on the data. This is outside any <a class="el" href="namespace_cn_c.html" title="CnC API.">CnC</a> call so we must communicate when it leaves and enters quiescence. As a graph gets born in quiescent state we call leave_quiescence (to enter active state) in the constructor and then register our callback:</p>
 <div class="fragment"><pre class="fragment">    <span class="comment">// the constructor tells the runtime that the graph is not quiescent</span>
    <span class="comment">// it also starts the thread and registers the on_put callback</span>
    <span class="keyword">template</span>&lt; <span class="keyword">typename</span> Ctxt &gt;
    hidden_graph( <a class="code" href="class_cn_c_1_1context.html" title="CnC context bringing together collections (for steps, items and tags).">CnC::context&lt; Ctxt &gt;</a> &amp; ctxt, <span class="keyword">const</span> std::string &amp; name, IC_IN &amp; ic1, IC_OUT &amp; ic2, TC_OUT &amp; tc )
        : CnC::graph( ctxt, name ),
          m_input( ic1 ),
          m_dataout( ic2 ),
          m_tagout( tc ),
          m_queue(),
          m_thread( observe_and_compute(), &amp;m_queue, &amp;m_dataout, &amp;m_tagout, this )
    {
        <span class="comment">// we started a thread, we are not quiescent until it exits</span>
        this-&gt;leave_quiescence();
        <span class="comment">// register the callback</span>
        m_input.on_put( <span class="keyword">new</span> on_data( m_queue ) );
    }
</pre></div></p>
<p>When our thread is done, it calls enter_quiescence before it terminates.</p>
 <div class="fragment"><pre class="fragment">            } <span class="keywordflow">while</span>( _tag &lt; <a class="code" href="class_cn_c_1_1tuner__base.html#ae52a37bb28b0d5fdd7fc105ac989ac46">CnC::tuner_base::myPid</a>()*1000+7 );
            <span class="comment">// we are done, before exiting we must inform the runtime</span>
            graph-&gt;enter_quiescence();
            CnC::Internal::Speaker oss;
            oss &lt;&lt; <span class="stringliteral">&quot;done observe_and_compute&quot;</span>;
        }
</pre></div></p>
<p>Note that this is a very simple and artificial example. In particular, our graph has only one region of activity. However, conceptually and in practice there is no problem letting the graph alternate between quiescent and active state - as long as it obeys the above rules.</p>
<dl class="note"><dt><b>Note:</b></dt><dd>The usual caveats apply to distributed memory: each remote "clone" of a sub-graph must report quiescence for the runtime to detect global quiescence. This might require explicit communication (see <a class="el" href="reuse.html#def_graph_dist">Sub-Graphs on Distributed Memory</a>).</dd></dl>
<h3><a class="anchor" id="def_graph_dist"></a>
Sub-Graphs on Distributed Memory</h3>
<p>Sub-graphs, in particular hidden ones, might require explicitly addressing distributed memory. A "clone" of the graph exists on each process, hence, as soon as you're using non-CnC things you have to explicitly take care for any communication that's needed between the siblings.</p>
<p>Examples for such explicit communication are reductions (<a class="el" href="reduce_8h_source.html">reduce.h</a>) and joins (<a class="el" href="join_8h_source.html">join.h</a>).</p>
<p>The tuners can be used to configure where items go in the usual way. If your graph has internal <a class="el" href="namespace_cn_c.html" title="CnC API.">CnC</a> steps you might consider letting the user provide a tuner for it and so control its distribution.</p>
<p>Please see <a class="el" href="class_cn_c_1_1graph.html" title="Base class for defining and using CnC (sub-)graphs.">CnC::graph</a>, <a class="el" href="class_cn_c_1_1item__collection.html" title="An item collection is a mapping from tags to items.">CnC::item_collection</a> and <a class="el" href="class_cn_c_1_1tag__collection.html" title="A tag collection is a set of tags of the same type. It is used to prescribe steps. By default, tags are not stored.">CnC::tag_collection</a> for the details about communication between siblings and where callbacks get executed.</p>
<p>Next: <a class="el" href="runtime.html">Runtime Options</a> </p>
</div></div><!-- contents -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Friends</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>



<hr class="footer"/><address class="footer"><small>
Generated on Fri Jun 6 2014 15:18:33 for CnC by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.7.6.1
</small></address>

</body>
</html>
