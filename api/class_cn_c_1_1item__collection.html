<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>CnC: item_collection&lt; Tag, Item, Tuner &gt; Class Template Reference</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />

<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>

</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">CnC
   
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Friends</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="namespace_cn_c.html">CnC</a>      </li>
      <li class="navelem"><a class="el" href="class_cn_c_1_1item__collection.html">item_collection</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a>  </div>
  <div class="headertitle">
<div class="title">item_collection&lt; Tag, Item, Tuner &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">
<!-- doxytag: class="CnC::item_collection" -->
<p>An item collection is a mapping from tags to items.  
 <a href="class_cn_c_1_1item__collection.html#details">More...</a></p>

<p><a href="class_cn_c_1_1item__collection-members.html">List of all members.</a></p>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3b26d0881c5b7629ee838282197b6d60"></a><!-- doxytag: member="CnC::item_collection::tag_type" ref="a3b26d0881c5b7629ee838282197b6d60" args="" -->
typedef Tag&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_cn_c_1_1item__collection.html#a3b26d0881c5b7629ee838282197b6d60">tag_type</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">the tag type <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1073416fd030d42dee3bcb454dee611e"></a><!-- doxytag: member="CnC::item_collection::data_type" ref="a1073416fd030d42dee3bcb454dee611e" args="" -->
typedef Item&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_cn_c_1_1item__collection.html#a1073416fd030d42dee3bcb454dee611e">data_type</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">the data/item type <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <br class="typebreak"/>
base_coll_type::callback_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_cn_c_1_1item__collection.html#abd57cb2f7ad3e2c60b0c8a576c0ab074">callback_type</a></td></tr>
<tr><td colspan="2"><h2><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;class Derived &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_cn_c_1_1item__collection.html#a8992d4121ab3c9055b1dc8c10b46c477">item_collection</a> (<a class="el" href="class_cn_c_1_1context.html">context</a>&lt; Derived &gt; &amp;ctxt, const std::string &amp;name, const Tuner &amp;tnr)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">constructor which registers collection with given context  <a href="#a8992d4121ab3c9055b1dc8c10b46c477"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_cn_c_1_1item__collection.html#afaf915c9dc91d08d10fdd2ef0ddb700e">set_max</a> (size_t mx)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Declares the maxium tag value.  <a href="#afaf915c9dc91d08d10fdd2ef0ddb700e"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_cn_c_1_1item__collection.html#a94140b9dd02a243fc708aef255618354">put</a> (const Tag &amp;tag, const Item &amp;item)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">make copies of the item and the tag and store them in the collection.  <a href="#a94140b9dd02a243fc708aef255618354"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_cn_c_1_1item__collection.html#a9aeb05ed2987e6fbf39d6f0ca761ee18">get</a> (const Tag &amp;tag, Item &amp;item) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">get an item  <a href="#a9aeb05ed2987e6fbf39d6f0ca761ee18"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_cn_c_1_1item__collection.html#a8ffe4bb2760d25d10e7201f043bca481">unsafe_get</a> (const Tag &amp;tag, Item &amp;item) const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">try to get an item and store it in given object (non-blocking)  <a href="#a8ffe4bb2760d25d10e7201f043bca481"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_cn_c_1_1item__collection.html#aa4b02d4f1a8500fb07a551069060709f">begin</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">returns <a class="el" href="class_cn_c_1_1item__collection.html#aa4b02d4f1a8500fb07a551069060709f" title="returns begin() as in STL containers">begin()</a> as in STL containers  <a href="#aa4b02d4f1a8500fb07a551069060709f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_cn_c_1_1item__collection.html#a350132543d80a1c1e5be844e6d2878ea">end</a> () const </td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">returns <a class="el" href="class_cn_c_1_1item__collection.html#a350132543d80a1c1e5be844e6d2878ea" title="returns end() as in STL containers">end()</a> as in STL containers  <a href="#a350132543d80a1c1e5be844e6d2878ea"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_cn_c_1_1item__collection.html#ac1613bccb510f68af520d6d410d3f303">unsafe_reset</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">removes all of the item instances from the collection  <a href="#ac1613bccb510f68af520d6d410d3f303"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a0b6b70701c46e22849f0f363861351cd"></a><!-- doxytag: member="CnC::item_collection::size" ref="a0b6b70701c46e22849f0f363861351cd" args="()" -->
size_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_cn_c_1_1item__collection.html#a0b6b70701c46e22849f0f363861351cd">size</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">returns number of elements in collection <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a3f37b042a1e7cd4bd38fc564de81f0da"></a><!-- doxytag: member="CnC::item_collection::empty" ref="a3f37b042a1e7cd4bd38fc564de81f0da" args="()" -->
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_cn_c_1_1item__collection.html#a3f37b042a1e7cd4bd38fc564de81f0da">empty</a> ()</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">returns true if <a class="el" href="class_cn_c_1_1item__collection.html#a0b6b70701c46e22849f0f363861351cd" title="returns number of elements in collection">size()</a>==0, false otherwise <br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_cn_c_1_1item__collection.html#a515c2f781a8bb1c49ae56fdb920fe051">on_put</a> (<a class="el" href="class_cn_c_1_1item__collection.html#abd57cb2f7ad3e2c60b0c8a576c0ab074">callback_type</a> *cb)</td></tr>
</table>
<hr/><a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename Tag, typename Item, typename Tuner = hashmap_tuner&gt;<br/>
class CnC::item_collection&lt; Tag, Item, Tuner &gt;</h3>

<p>An item collection is a mapping from tags to items. </p>
<p>Tag and Item must provide copy and default constructors and the assigment operator.</p>
<p>Th last template argument is an optional tuner. The tuner provides tuning hints, such as the type of the data store or information about its use in distributed environments. Most importantly it tells the runtime and compiler which type of data store it should use. By default that's a hash-map (<a class="el" href="struct_cn_c_1_1hashmap__tuner.html" title="The tuner base for hashmap-based item-tuners.">hashmap_tuner</a>). For non default-supported tag types (e.g. those that are not convertable into size_t) a suitable <a class="el" href="structcnc__hash.html" title="Provides hash operators for hashing.">cnc_hash</a> template specialization must be provided. If in addition your type does not support std::equal_to you also need to specialize <a class="el" href="structcnc__equal.html" title="Provides equality operators for hashing.">cnc_equal</a>. For the vector-based data store (<a class="el" href="struct_cn_c_1_1vector__tuner.html" title="The tuner base for vector-based item-tuners.">vector_tuner</a>) that's not necessary, but the tag-type must then be convertible to and from size_t. </p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="struct_cn_c_1_1item__tuner.html" title="Default implementations of the item-tuner interface for item-collections.">CnC::item_tuner</a> for more information.</dd></dl>
<p>The <a class="el" href="namespace_cn_c.html" title="CnC API.">CnC</a> runtime will make a copy of your item when it is 'put' into the <a class="el" href="class_cn_c_1_1item__collection.html" title="An item collection is a mapping from tags to items.">item_collection</a>. The <a class="el" href="namespace_cn_c.html" title="CnC API.">CnC</a> runtime will delete the copied item copy once the get-count reaches 0 (or, if no get-count was provided, once the collection is destroyed). If the item-type is a pointer type, the runtime will not delete the memory the item points to. If you store pointeres, you have to care for the appropriate garbage collection, e.g. you might consider using smart pointers. </p>

<p>Definition at line <a class="el" href="cnc_8h_source.html#l00259">259</a> of file <a class="el" href="cnc_8h_source.html">cnc.h</a>.</p>
</div><hr/><h2>Member Typedef Documentation</h2>
<a class="anchor" id="abd57cb2f7ad3e2c60b0c8a576c0ab074"></a><!-- doxytag: member="CnC::item_collection::callback_type" ref="abd57cb2f7ad3e2c60b0c8a576c0ab074" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef base_coll_type::callback_type <a class="el" href="class_cn_c_1_1item__collection.html#abd57cb2f7ad3e2c60b0c8a576c0ab074">callback_type</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>callback type for item-collections. </p>
<dl class="see"><dt><b>See also:</b></dt><dd>register_callback </dd></dl>

<p>Definition at line <a class="el" href="cnc_8h_source.html#l00341">341</a> of file <a class="el" href="cnc_8h_source.html">cnc.h</a>.</p>

</div>
</div>
<hr/><h2>Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a8992d4121ab3c9055b1dc8c10b46c477"></a><!-- doxytag: member="CnC::item_collection::item_collection" ref="a8992d4121ab3c9055b1dc8c10b46c477" args="(context&lt; Derived &gt; &amp;ctxt, const std::string &amp;name, const Tuner &amp;tnr)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_cn_c_1_1item__collection.html">item_collection</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_cn_c_1_1context.html">context</a>&lt; Derived &gt; &amp;&#160;</td>
          <td class="paramname"><em>ctxt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Tuner &amp;&#160;</td>
          <td class="paramname"><em>tnr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>constructor which registers collection with given context </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">ctxt</td><td>the context this collection belongs to </td></tr>
    <tr><td class="paramname">name</td><td>an optional name, used for debug output and tracing </td></tr>
    <tr><td class="paramname">tnr</td><td>a tuner object which must persist throughout the lifetime of the step-collection by default a default-constructed tuner will be used. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/><h2>Member Function Documentation</h2>
<a class="anchor" id="aa4b02d4f1a8500fb07a551069060709f"></a><!-- doxytag: member="CnC::item_collection::begin" ref="aa4b02d4f1a8500fb07a551069060709f" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const_iterator <a class="el" href="class_cn_c_1_1item__collection.html#aa4b02d4f1a8500fb07a551069060709f">begin</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>returns <a class="el" href="class_cn_c_1_1item__collection.html#aa4b02d4f1a8500fb07a551069060709f" title="returns begin() as in STL containers">begin()</a> as in STL containers </p>
<dl class="note"><dt><b>Note:</b></dt><dd>iteration through collections is not thread safe; use it only between calls to <a class="el" href="class_cn_c_1_1context.html#a6b3af26508001c5c4b1b179ce532bb7a" title="wait until all the steps prescribed by this context have completed execution.">CnC::context::wait()</a> and putting tags </dd></dl>

</div>
</div>
<a class="anchor" id="a350132543d80a1c1e5be844e6d2878ea"></a><!-- doxytag: member="CnC::item_collection::end" ref="a350132543d80a1c1e5be844e6d2878ea" args="() const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const_iterator <a class="el" href="class_cn_c_1_1item__collection.html#a350132543d80a1c1e5be844e6d2878ea">end</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>returns <a class="el" href="class_cn_c_1_1item__collection.html#a350132543d80a1c1e5be844e6d2878ea" title="returns end() as in STL containers">end()</a> as in STL containers </p>
<dl class="note"><dt><b>Note:</b></dt><dd>iteration through collections is not thread safe; use it only between calls to <a class="el" href="class_cn_c_1_1context.html#a6b3af26508001c5c4b1b179ce532bb7a" title="wait until all the steps prescribed by this context have completed execution.">CnC::context::wait()</a> and putting tags </dd></dl>

</div>
</div>
<a class="anchor" id="a9aeb05ed2987e6fbf39d6f0ca761ee18"></a><!-- doxytag: member="CnC::item_collection::get" ref="a9aeb05ed2987e6fbf39d6f0ca761ee18" args="(const Tag &amp;tag, Item &amp;item) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_cn_c_1_1item__collection.html#a9aeb05ed2987e6fbf39d6f0ca761ee18">get</a> </td>
          <td>(</td>
          <td class="paramtype">const Tag &amp;&#160;</td>
          <td class="paramname"><em>tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Item &amp;&#160;</td>
          <td class="paramname"><em>item</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>get an item </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">tag</td><td>the tag identifying the item </td></tr>
    <tr><td class="paramname">item</td><td>reference to item to store result in </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">DataNotReady</td><td>throws exception if data not yet available. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a515c2f781a8bb1c49ae56fdb920fe051"></a><!-- doxytag: member="CnC::item_collection::on_put" ref="a515c2f781a8bb1c49ae56fdb920fe051" args="(callback_type *cb)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_cn_c_1_1item__collection.html#a515c2f781a8bb1c49ae56fdb920fe051">on_put</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_cn_c_1_1item__collection.html#abd57cb2f7ad3e2c60b0c8a576c0ab074">callback_type</a> *&#160;</td>
          <td class="paramname"><em>cb</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">
<p>Call this to register a on-put-callback for the item-collection. When registered, callback.on_put( tag, item ) gets called when an item was put successfully. The call is blocking, e.g. the triggering/calling "put" will not return to its caller until the callback has terminated.</p>
<p>The provided object will be deleted when the collection is deleted.</p>
<p>In distCnC, the callback will be executed on the (first) process returned by tuner::consumed_on (which defaults to execution on the process which puts the item).</p>
<dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="class_cn_c_1_1graph.html" title="Base class for defining and using CnC (sub-)graphs.">graph</a> for more details, in particular about thread-safety issues </dd></dl>
<dl class="note"><dt><b>Note:</b></dt><dd>not thread-safe, to be called in safe state only (between program start or calling <a class="el" href="class_cn_c_1_1context.html#a6b3af26508001c5c4b1b179ce532bb7a" title="wait until all the steps prescribed by this context have completed execution.">context::wait()</a> and putting the first tag or item). </dd>
<dd>
not needed for regular <a class="el" href="namespace_cn_c.html" title="CnC API.">CnC</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a94140b9dd02a243fc708aef255618354"></a><!-- doxytag: member="CnC::item_collection::put" ref="a94140b9dd02a243fc708aef255618354" args="(const Tag &amp;tag, const Item &amp;item)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_cn_c_1_1item__collection.html#a94140b9dd02a243fc708aef255618354">put</a> </td>
          <td>(</td>
          <td class="paramtype">const Tag &amp;&#160;</td>
          <td class="paramname"><em>tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Item &amp;&#160;</td>
          <td class="paramname"><em>item</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>make copies of the item and the tag and store them in the collection. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">tag</td><td>the tag identifying the item </td></tr>
    <tr><td class="paramname">item</td><td>the item to be copied and stored </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="afaf915c9dc91d08d10fdd2ef0ddb700e"></a><!-- doxytag: member="CnC::item_collection::set_max" ref="afaf915c9dc91d08d10fdd2ef0ddb700e" args="(size_t mx)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_cn_c_1_1item__collection.html#afaf915c9dc91d08d10fdd2ef0ddb700e">set_max</a> </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>mx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Declares the maxium tag value. </p>
<p>Must be called prior to accessing the collection if the data store is a vector. Useful only for dense tag-spaces. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">mx</td><td>the largest tag-value ever used for this collection </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a8ffe4bb2760d25d10e7201f043bca481"></a><!-- doxytag: member="CnC::item_collection::unsafe_get" ref="a8ffe4bb2760d25d10e7201f043bca481" args="(const Tag &amp;tag, Item &amp;item) const " -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool <a class="el" href="class_cn_c_1_1item__collection.html#a8ffe4bb2760d25d10e7201f043bca481">unsafe_get</a> </td>
          <td>(</td>
          <td class="paramtype">const Tag &amp;&#160;</td>
          <td class="paramname"><em>tag</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Item &amp;&#160;</td>
          <td class="paramname"><em>item</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>try to get an item and store it in given object (non-blocking) </p>
<dl class="attention"><dt><b>Attention:</b></dt><dd>This method is unsafe: you can create non-deterministic results if you decide to to perform semantically relevant actions if an item is unavailable (returns false)</dd></dl>
<p>If the item is unavailable, it does not change item. Make sure you call flush_gets() after last call to this method (of any item collection) within a step. In any case, you must check the return value before accessing the item. </p>
<dl class="params"><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">tag</td><td>the tag identifying the item </td></tr>
    <tr><td class="paramname">item</td><td>reference to item to store result in </td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>true if item is available </dd></dl>
<dl class="exception"><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">DataNotReady</td><td>might throw exception if data not available (yet) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac1613bccb510f68af520d6d410d3f303"></a><!-- doxytag: member="CnC::item_collection::unsafe_reset" ref="ac1613bccb510f68af520d6d410d3f303" args="()" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_cn_c_1_1item__collection.html#ac1613bccb510f68af520d6d410d3f303">unsafe_reset</a> </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>removes all of the item instances from the collection </p>
<dl class="note"><dt><b>Note:</b></dt><dd>not thread-safe, to be called in safe state only (between program start or calling <a class="el" href="class_cn_c_1_1context.html#a6b3af26508001c5c4b1b179ce532bb7a" title="wait until all the steps prescribed by this context have completed execution.">context::wait()</a> and putting the first tag or item). </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li><a class="el" href="cnc_8h_source.html">cnc.h</a></li>
</ul>
</div><!-- contents -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Friends</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>



<hr class="footer"/><address class="footer"><small>
Generated on Fri Jun 6 2014 15:18:34 for CnC by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.7.6.1
</small></address>

</body>
</html>
