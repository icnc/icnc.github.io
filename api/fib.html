<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>CnC: Getting Started with Fibonacci</title>

<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="doxygen.css" rel="stylesheet" type="text/css" />

<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>

</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">CnC
   
   </div>
   
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="headertitle">
<div class="title">Getting Started with Fibonacci </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>We use Fibonacci as an educative example; what we show here is not meant to be an ideal or elegant implementation of Fibonacci. We only use Fibonacci as a simple enough problem to demonstrate <a class="el" href="namespace_cn_c.html" title="CnC API.">CnC</a> and highlight some of its features.</p>
<p>Let's start.</p>
<p>The Fibonacci number of a given value n is recursively defined as fib(n) = fib(n-1) + fib(n-2). As the values can grow very large, let's define our own data type that we can adjust if needed:  <div class="fragment"><pre class="fragment"><span class="keyword">typedef</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">long</span> <span class="keywordtype">long</span> fib_type;
</pre></div></p>
<h2><a class="anchor" id="fibsepc"></a>
The CnC Specification</h2>
<h3><a class="anchor" id="compent"></a>
Identifying Computation Units</h3>
<p>Fibonacci is a very simple algorithm. There only one computation which simply adds the values of the two previous Fibonacci numbers. Let's call it "fib_step". In <a class="el" href="namespace_cn_c.html" title="CnC API.">CnC</a> all execution instances of such a function are held in one collection, a <a class="el" href="class_cn_c_1_1step__collection.html" title="A step collection is logical set of step instances.">CnC::step_collection</a>. Declaring such a step-collection instance (with name m_steps) for steps of type "fib_step" is as simple as this:  <div class="fragment"><pre class="fragment">    <a class="code" href="class_cn_c_1_1step__collection.html" title="A step collection is logical set of step instances.">CnC::step_collection&lt; fib_step &gt;</a>       m_steps;
</pre></div> As we do not need any other function to compute Fibonacci, one step-collection is enough. More complex programs will of course use more than just a single step-collection.</p>
<h3><a class="anchor" id="dataent"></a>
Data entities</h3>
<p>The only data we seem to care about are the Fibonacci numbers that we compute. The only way in <a class="el" href="namespace_cn_c.html" title="CnC API.">CnC</a> to read values from a computation is through item-collections. So we clearly need to store the final result in such an item-collection. Additionally we need to get the result of another computation to compute a new value. Luckily, Fibonacci is recursive and the kind of the input data is the same as the output data (and with kind we mean that it not only has the same data-type but it also has the same meaning). So we can use one item-collection for the intermediate results and for the final result. More complex programs will of course use more than just a single item-collection.</p>
<p>Defining an item-collection is straight forward: <div class="fragment"><pre class="fragment">    <a class="code" href="class_cn_c_1_1item__collection.html" title="An item collection is a mapping from tags to items.">CnC::item_collection&lt; int, fib_type &gt;</a>  m_fibs;
</pre></div> Again, the C++ API provides a template class to define item-collections (<a class="el" href="class_cn_c_1_1item__collection.html" title="An item collection is a mapping from tags to items.">CnC::item_collection</a>). The second type-argument is the type of the data to be stored. For our Fibonacci numbers we declared our own type "fib_type", so "fib_type" is the second argument. But what about the first? The first type argument is the tag-type for identifying each data-instance. Just like a traditional key/value pair, the value of our item is accessible (only) through its identifier, the tag. What would make a good identifier for a Fibonacci number? Of course we can simply use an integer; so semantically, the above item-collection maps an integer key to its Fibonacci value. Our "fib_step" will fill this data structure during execution.</p>
<p>In general you can use any C++ type or class for tags and items as long as they provide a copy-constructor (which is true for most types). The tag types must also separately be supported by a hash-function (by default <a class="el" href="structcnc__tag__hash__compare.html" title="Provides hash and equality operators for hashing as used by item_collections.">cnc_tag_hash_compare</a>).</p>
<h3><a class="anchor" id="steps"></a>
Steps: The Computation Units</h3>
<p>Apparently we need the step which actually computes the Fibonacci number from a given value. Computation units in <a class="el" href="namespace_cn_c.html" title="CnC API.">CnC</a> are defined as steps. Such a step is a class with an execute method which accepts two arguments: a control tag and a second argument, which usually is the context (see below) but could also be anything else.  <div class="fragment"><pre class="fragment"><span class="keyword">struct </span>fib_step
{
    <span class="comment">// declaration of execute method goes here</span>
    <span class="keywordtype">int</span> execute( <span class="keyword">const</span> <span class="keywordtype">int</span> &amp; tag, fib_context &amp; c ) <span class="keyword">const</span>;
};
</pre></div> Note that the execute method must be "const" and is not allowed to have side-effects (other than on item-collections).</p>
<p>From the step's perspective, the control tag distinguishes between execution instances of the same step. For example the control tag tells the above fib_step for which Fibonacci number it is currently executed; this should not be confused with input data, which is handled by item-collections.</p>
<p>It is recommended to pass the tag by const-reference, in particular if you are not using standard data types.</p>
<h3><a class="anchor" id="tags"></a>
Control Tags</h3>
<p>In <a class="el" href="namespace_cn_c.html" title="CnC API.">CnC</a> steps are never called explicitly. If a step needs to be executed with a given tag, this tag is put into a so called tag-collection. The tag-collection will make sure that the step gets executed eventually. So putting a tag tells the <a class="el" href="namespace_cn_c.html" title="CnC API.">CnC</a> runtime that a step-instance needs to be executed, but does not (and can not) say when it is going to run. So let's define the tag-collection which we will use to control our step-collections above: <div class="fragment"><pre class="fragment">    <a class="code" href="class_cn_c_1_1tag__collection.html" title="A tag collection is a set of tags of the same type. It is used to prescribe steps. By default, tags are not stored.">CnC::tag_collection&lt; int &gt;</a>             m_tags;
</pre></div> The <a class="el" href="namespace_cn_c.html" title="CnC API.">CnC</a> C++ API once achieves generality through templates; tags can be of any type, as long as it provides a copy-constructor.</p>
<h3><a class="anchor" id="ctxt"></a>
The Context: Bringing it all together</h3>
<p>Before we can actually write the step-code, we need the before mentioned context. The context is what in the <a class="el" href="namespace_cn_c.html" title="CnC API.">CnC</a> literature is often referred to as "graph". It brings together the different collections (tags, items and steps) by defining them as members. Internally it takes care for the runtime mechanics and is used to control the graph evaluation (e.g. waiting for completion). Hence it is recommended to define tag- and item-collections as members of the context.</p>
<p>Each context must be derived from a base class, which again is a template. The accepted template argument is the newly defined derived class. Don't bother about the recursive nature if you are not used to it, it's legal C++. In our case it could look like this  <div class="fragment"><pre class="fragment"><span class="keyword">struct </span>fib_context : <span class="keyword">public</span> CnC::context&lt; fib_context &gt; <span class="comment">// derive from CnC::context</span>
{
    <span class="comment">// the step collection for the instances of the compute-kernel</span>
    <a class="code" href="class_cn_c_1_1step__collection.html" title="A step collection is logical set of step instances.">CnC::step_collection&lt; fib_step &gt;</a>       m_steps;
    <span class="comment">// item collection holding the fib number(s)</span>
    <a class="code" href="class_cn_c_1_1item__collection.html" title="An item collection is a mapping from tags to items.">CnC::item_collection&lt; int, fib_type &gt;</a>  m_fibs;
    <span class="comment">// tag collection to control steps</span>
    <a class="code" href="class_cn_c_1_1tag__collection.html" title="A tag collection is a set of tags of the same type. It is used to prescribe steps. By default, tags are not stored.">CnC::tag_collection&lt; int &gt;</a>             m_tags;

    <span class="comment">// constructor</span>
    fib_context();
};
</pre></div></p>
<p>So far we have all the definitions of all collections and the context. Now we need the mechanics, e.g. the relations between the different collections. Producer and consumer relations are declared by calling the respective produces/consumes methods. Then we want that for each tag which is put into the tag-collection m_tags a step from m_steps is executed. We do this by simply calling prescribe on m_tags. We declare all these relations in the context-constructor: <div class="fragment"><pre class="fragment">fib_context::fib_context()
        : <a class="code" href="class_cn_c_1_1context.html" title="CnC context bringing together collections (for steps, items and tags).">CnC::context&lt; fib_context &gt;</a>(),
          <span class="comment">// pass context to collection constructors</span>
          m_steps( *<span class="keyword">this</span> ),
          m_fibs( *<span class="keyword">this</span> ),
          m_tags( *<span class="keyword">this</span> )
{
    <span class="comment">// prescribe compute steps with this (context) as argument</span>
    m_tags.<a class="code" href="class_cn_c_1_1tag__collection.html#a83f2782bc18578a2018851f0356c8b2a" title="Declare the prescription relationship between the tag collection and a step collection.">prescribes</a>( m_steps, *<span class="keyword">this</span> );
    <span class="comment">// step consumes m_fibs</span>
    m_steps.<a class="code" href="class_cn_c_1_1step__collection.html#aa91192651c08408d430829b6e4bca8b0" title="Declare this step-collecation as consumer of given item-collection.">consumes</a>( m_fibs );
    <span class="comment">// step also produces m_fibs</span>
    m_steps.<a class="code" href="class_cn_c_1_1step__collection.html#a7e5f64f200a66bba4228f17bfded35ca" title="Declare this step-collecation as producer for given item-collection.">produces</a>( m_fibs );
}
</pre></div></p>
<h2><a class="anchor" id="stp"></a>
Writing the step</h2>
<p>Now we have set up the graph and are ready to define the step functionality. The second argument to our step is the context, through which we have access to the tag- and item-collections. To compute the result for a given value, we need the results for the previous two values, which is expressed through getting them from the item-collection. Publishing/producing the result is the reverse operation: a put to the item-collection. The step-code could look as follows: <div class="fragment"><pre class="fragment"><span class="keywordtype">int</span> fib_step::execute( <span class="keyword">const</span> <span class="keywordtype">int</span> &amp; tag, fib_context &amp; ctxt ) <span class="keyword">const</span>
{
    <span class="keywordflow">switch</span>( tag ) {
        <span class="keywordflow">case</span> 0 : ctxt.m_fibs.put( tag, 0 ); <span class="keywordflow">break</span>;
        <span class="keywordflow">case</span> 1 : ctxt.m_fibs.put( tag, 1 ); <span class="keywordflow">break</span>;
        <span class="keywordflow">default</span> : 
            <span class="comment">// get previous 2 results</span>
            fib_type f_1; ctxt.m_fibs.get( tag - 1, f_1 );
            fib_type f_2; ctxt.m_fibs.get( tag - 2, f_2 );
            <span class="comment">// put our result</span>
            ctxt.m_fibs.put( tag, f_1 + f_2 );
    }
    <span class="keywordflow">return</span> <a class="code" href="namespace_cn_c.html#ae34016c7f648af87668a0d8115b03860" title="Steps return CNC_Success if execution was successful.">CnC::CNC_Success</a>;
}
</pre></div></p>
<dl class="note"><dt><b>Note:</b></dt><dd>A step does not care about where the input data comes from, nor does it care about were the output goes to. It only requests/gets the exact data instances it needs and puts the ones it produces. The <a class="el" href="namespace_cn_c.html" title="CnC API.">CnC</a> runtime will take care of all the coordination between producers and consumers. The programmer does not need to think about it (not even if it is run on distributed memory).</dd></dl>
<h2><a class="anchor" id="env"></a>
Writing main, the environment</h2>
<p>Let's now complete the program by providing the "main", in which we instantiate our context <div class="fragment"><pre class="fragment">    fib_context ctxt; 
</pre></div> trigger the Fibonacci evaluation <div class="fragment"><pre class="fragment">    <span class="keywordflow">for</span>( <span class="keywordtype">int</span> i = 0; i &lt;= n; ++i ) ctxt.m_tags.put( i );
</pre></div> You might have noticed that the fib(n-1) will not become available until a corresponding step-instances has been executed. Hence, it will not be sufficient to prescribe only the desired step-instances, that's why we need to put all tags up to that number.</p>
<p>Now we wait for the evaluation to complete <div class="fragment"><pre class="fragment">    ctxt.wait(); 
</pre></div> . The full main could read the desired input value from the command line and print it to stdout:  <div class="fragment"><pre class="fragment"><span class="keywordtype">int</span> main( <span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>* argv[] )
{
    <span class="keywordtype">int</span> n = 42;
    <span class="comment">// eval command line args</span>
    <span class="keywordflow">if</span>( argc &lt; 2 ) {
        std::cerr &lt;&lt; <span class="stringliteral">&quot;usage: &quot;</span> &lt;&lt; argv[0] &lt;&lt; <span class="stringliteral">&quot; n\nUsing default value &quot;</span> &lt;&lt; n &lt;&lt; std::endl;
    } <span class="keywordflow">else</span> n = atol( argv[1] );

    <span class="comment">// create context</span>
    fib_context ctxt; 

    <span class="comment">// put tags to initiate evaluation</span>
    <span class="keywordflow">for</span>( <span class="keywordtype">int</span> i = 0; i &lt;= n; ++i ) ctxt.m_tags.put( i );

    <span class="comment">// wait for completion</span>
    ctxt.wait(); 

    <span class="comment">// get result</span>
    fib_type res2;
    ctxt.m_fibs.get( n, res2 );

    <span class="comment">// print result</span>
    std::cout &lt;&lt; <span class="stringliteral">&quot;fib (&quot;</span> &lt;&lt; n &lt;&lt; <span class="stringliteral">&quot;): &quot;</span> &lt;&lt; res2 &lt;&lt; std::endl;

    <span class="keywordflow">return</span> 0;
}
</pre></div></p>
<p>Here is the full example code: <a class="el" href="samples.html#fib_code">samples/fib/fib_tutorial/fibTutorial.cpp</a></p>
<p>The code can also be found in the "Samples" directory, including project files for VS on MS Windows* and Makefiles for Linux.</p>
<p>Next: <a class="el" href="debug.html">Debugging features</a> </p>
</div></div><!-- contents -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Classes</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Namespaces</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Friends</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>



<hr class="footer"/><address class="footer"><small>
Generated on Fri Jun 6 2014 15:18:33 for CnC by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.7.6.1
</small></address>

</body>
</html>
