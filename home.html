<!DOCTYPE html>
<html>
        <h1>Parallelism Without the Pain</h1>
          <h2>Why CnC?</h2>
            <p>
             CnC makes it easy to write C++ programs which take full
             advantage of the available parallelism.  Whether run on
             multicore systems, Xeon Phi&trade; or clusters CnC will
             seamlessly exploit the performance potential of your
             hardware. Through its portababilty and composability
             (with itself and other tools) it provides future-proof
             scalability.
            <p/>

        <h2>Intel&copy; Concurrent Collections for C++</h2>
            Intel&copy; Concurrent Collections for C++ is a C++ template
            library for letting C++ programmers implement CnC applications
            which run in parallel on shared and distributed memory.

	<h2>Primary features</h2>
	<table>
	  <col class='firstcol' />
	  <tr>
	    <td class='fc'>Easy parallelism</td>
            <td>There is no need to think about lower level parallelization
              techniques like threading primitives or message passing; no
              need to understand pthreads, MPI, Windows threads,
              TBB,... Intel&copy; Concurrent Collections for C++ provides
              a separation of concerns between what the application means
              and how to tune it for a specific platform.
	    </td>
	  </tr>
          <tr><td class='fc'>Portability</td>
            <td>The same source runs on Windows and
              Linux. The same binary runs on shared memory multi-core
              systems and clusters of workstations.
	    </td>
	  </tr>
          <tr><td class='fc'>Efficiency</td>
            <td>Intel&copy; Concurrent Collections for C++ provides a way
              to express an algorithm with minimal scheduling constraints.
              this makes it very efficient.
	    </td>
	  </tr>
          <tr><td class='fc'>Scalability</td>
            <td>Intel&copy; Concurrent Collections for C++ achieves scalable
              performance on a wide range of configurations from small
              multicore systems to large clusters. No need to re-write or
              re-compile application in order to target a new
              configuration.
	    </td>
	  </tr>
	</table>
</html>
